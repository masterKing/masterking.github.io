<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>设计模式</title>
    <url>/2019/04/04/2019-04-04-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>#关于设计模式</p>
<table>
<thead>
<tr>
<th>*</th>
<th>*</th>
<th align="left">创建型</th>
<th align="left">结构型</th>
<th align="left">行为型</th>
</tr>
</thead>
<tbody><tr>
<td>范围</td>
<td>类</td>
<td align="left">Factory Method</td>
<td align="left">Adapter(类)</td>
<td align="left">Interpreter<br>Template Method</td>
</tr>
<tr>
<td>*</td>
<td>对象</td>
<td align="left">Abstract Factory<br>Builder<br>Prototype<br>Singleton</td>
<td align="left">Adapter(对象)<br>Bridge<br>Composite<br>Decorator<br>Facade<br>Flyweight<br>Proxy<br></td>
<td align="left">Chain of Responsibility<br>Command<br>Iterator<br>Mediator<br>Memento<br>Observer<br>State<br>Stragegy<br>Visitor</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>OC与iOS混编</title>
    <url>/2019/04/12/2019-04-12-OC%E4%B8%8EiOS%E6%B7%B7%E7%BC%96/</url>
    <content><![CDATA[<h1 id="记录一下-OC和Swift混编的问题"><a href="#记录一下-OC和Swift混编的问题" class="headerlink" title="记录一下,OC和Swift混编的问题"></a>记录一下,OC和Swift混编的问题</h1><p>在OC项目中,需要使用Swift的时候,一般情况下,在你的OC项目中新建一个Swift文件的时候,系统会自动提示你是否需要配置一个Objective-C桥接头文件,如下图:<img src="https://github.com/masterKing/markDownPictures/blob/master/Snip20190412_4.png?raw=true"><br>点击最右侧的创建桥接头文件,系统就会帮你配置创建并配置好一个桥接头文件…这个桥接头文件的作用是,让你可以在Swift代码中使用OC中的类;只需要将你需要在Swift代码中使用的类的头文件在桥接头文件中导入一下就可以使用了;如果一不小心点击了Don’t Create按钮,那就需要你自己再手动创建一个头文件,将它配置成桥接头文件,才可以使用.配置步骤如下:</p>
<ol>
<li>创建一个头文件<br> <img src="https://github.com/masterKing/markDownPictures/blob/master/Snip20190412_5.png?raw=true"><br> <img src="https://github.com/masterKing/markDownPictures/blob/master/Snip20190412_6.png?raw=true"></li>
<li>配置成为OC桥接头文件<br> <img src="https://github.com/masterKing/markDownPictures/blob/master/Snip20190412_7.png?raw=true"><br>在里面导入OC的头文件,就可以在Swift代码中使用了</li>
</ol>
<p>如果是想要在OC的代码中使用Swift的类的话,这个就更加简单了,只需要导入一个系统自动生成的头文件就可以访问了,这个头文件在项目目录中看不到;但是在上图标记③的框框下面你可以看到它的名字,直接导入这个头文件就可以使用了,需要注意的是系统并不会自动补全这个头文件…没有提示,需要你自己一个一个字母敲进去</p>
<hr>

<p>再来说一下,在Swift项目中,想要使用OC代码;跟上面的步骤是一样的,第一次在Swift项目中创建OC类的时候,系统就会提示你是否创建Objective-C桥接头文件;这个头文件的作用跟上是一样的,让你可以在Swift代码中使用OC的类,只需在这个头文件导入OC类就行了…在OC代码中想要使用Swift类也跟上面一样,导入系统自动生成的那个头文件就可以使用了</p>
]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一个报错</title>
    <url>/2019/04/25/2019-04-25-%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%AA%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<h1 id="Undefined-symbols-for-architecture-arm64"><a href="#Undefined-symbols-for-architecture-arm64" class="headerlink" title="Undefined symbols for architecture arm64"></a>Undefined symbols for architecture arm64</h1><p><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/master/Snip20190425_23.png">上面这个报错经常会遇到…但是一直不知道是为啥出现的…今天碰巧知道了出现的原因</p>
<p>错误出现的步骤是这样的</p>
<ul>
<li><ol>
<li>首先我新建了Director和ConcreteBuild两个类</li>
</ol>
</li>
<li><ol start="2">
<li>在viewController.m中我使用这两个类写了一些代码</li>
</ol>
</li>
<li><ol start="3">
<li>这个时候我觉得这两个类写的不好不想要了,于是全部删除了…</li>
</ol>
</li>
</ul>
<p>但此时在viewController.m中的代码还没有移除掉;再次编译运行的时候就会报<br>Undefined symbols for architecture arm64:<br>“_OBJC_CLASS_$_Director”, referenced from:<br>objc-class-ref in ViewController.o<br>知道了错误产生的原因之后,再解决问题就很容易了…去viewController.m文件中把相关的代码全删了就好了…<br>只是有点儿疑惑为什么xcode不报找不到头文件Director或ConcreteBuild错误,而报这个Undefined symbols for architecture arm64:错误…一脸懵</p>
]]></content>
  </entry>
  <entry>
    <title>MBProgressHUD源码解析</title>
    <url>/2020/06/24/2020-06-24-MBProgressHUD%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="MBProgressHUD"><a href="#MBProgressHUD" class="headerlink" title="MBProgressHUD"></a>MBProgressHUD</h1><p>从入行以来,就经常听说,学习编程进步最快的方式,就是阅读优秀作品的源码…</p>
<p>那么,今天我来阅读一下MBProgressHUD这个库的源码…</p>
<p>查看一下文件,非常简单的俩个MBProgressHUD.h和MBProgressHUD.m文件</p>
<p>没什么说的,从MBProgressHUD.h文件开始看吧;</p>
<p>头文件首先声明了一个自定义的类 <code>MBBackgroundView</code> 和 一个协议 <code>MBProgressHUDDelegate</code>,自定义类放在这里声明一下,应该是因为<code>MBProgressHUD</code>里面使用到了<code>MBBackgroundView</code>类,且<code>MBProgressHUD</code>的声明与实现都放在了<code>MBBackgroundView</code>的前面,将<code>MBBackgroundView</code>的位置挪到比<code>MBProgressHUD</code>靠前的地方就不需要提前声明了,这个很简单,不需要多说了吧;而代理协议<code>MBProgressHUDDelegate</code>,对于做过iOS的开发人来说,应该说是再熟悉不过了…</p>
<p>接下来声明了一个供外部使用的变量<code>extern CGFloat const MBProgressMaxOffset;</code>,使用<code>extern</code>修饰了的变量能够在其他文件也可以访问到;往下查看头文件的时候,发现是为了给属性<code>offset</code>使用的,注释里面写到可以使用CGPointMake(0.f, MBProgressMaxOffset)来使HUD的位置处于底部边缘的中心位置</p>
<p>然后是4个自定义类型,<code>MBProgressHUDMode``MBProgressHUDAnimation``MBProgressHUDBackgroundStyle``MBProgressHUDCompletionBlock</code>;这四个类型也都比较简单,见名字大概就知道是什么意思了,简单提一下;<br><code>MBProgressHUDMode</code>mode翻译过来叫(设备的)模式,方式,风格,样式…在这里取风格或者样式应该更加恰当;它有6种不同的样式:</p>
<ul>
<li><code>MBProgressHUDModeIndeterminate </code>	&#x2F;&#x2F;iOS系统原生的UIActivityIndicatorView</li>
<li><code>MBProgressHUDModeDeterminate </code>	&#x2F;&#x2F;一个圆形的饼状进度视图样式</li>
<li><code>MBProgressHUDModeDeterminateHorizontalBar </code>	&#x2F;&#x2F;一个水平的条状进度视图样式</li>
<li><code>MBProgressHUDModeAnnularDeterminate </code>	&#x2F;&#x2F;圆环形的进度视图样式</li>
<li><code>MBProgressHUDModeCustomView </code>	&#x2F;&#x2F;自定义视图样式</li>
<li><code>MBProgressHUDModeText </code> &#x2F;&#x2F;纯文字样式</li>
</ul>
<p><code>MBProgressHUDAnimation</code>动画类型</p>
<ul>
<li><code>MBProgressHUDAnimationFade</code> &#x2F;&#x2F;淡入淡出</li>
<li><code>MBProgressHUDAnimationZoom</code> &#x2F;&#x2F;出现时放大,消失时缩小</li>
<li><code>MBProgressHUDAnimationZoomOut</code> &#x2F;&#x2F;缩小</li>
<li><code>MBProgressHUDAnimationZoomIn</code> &#x2F;&#x2F;放大</li>
</ul>
<p><code>MBProgressHUDBackgroundStyle</code>背景风格</p>
<ul>
<li><code>MBProgressHUDBackgroundStyleSolidColor</code> &#x2F;&#x2F;纯色</li>
<li><code>MBProgressHUDBackgroundStyleBlur</code> &#x2F;&#x2F;模糊,毛玻璃效果</li>
</ul>
<p><code>MBProgressHUDCompletionBlock</code>是一个无返回值无参数的block</p>
<p>接来下是<code>MBProgressHUD</code>的正式声明了<br>首先是7个方法声明</p>
<p>前三个为类方法:</p>
<p><code>+ (instancetype)showHUDAddedTo:(UIView *)view animated:(BOOL)animated;</code></p>
<p><code>+ (BOOL)hideHUDForView:(UIView *)view animated:(BOOL)animated;</code></p>
<p><code>+ (nullable MBProgressHUD *)HUDForView:(UIView *)view;</code></p>
<p>后面为对象方法:</p>
<p><code>- (instancetype)initWithView:(UIView *)view;</code></p>
<p><code>- (void)showAnimated:(BOOL)animated;</code></p>
<p><code>- (void)hideAnimated:(BOOL)animated;</code></p>
<p><code>- (void)hideAnimated:(BOOL)animated afterDelay:(NSTimeInterval)delay;</code></p>
<p>每个方法的注释都很详细,不需要多介绍什么的,接下来看看属性</p>
<p><code>@property (weak, nonatomic) id&lt;MBProgressHUDDelegate&gt; delegate;</code><br><code>@property (copy, nullable) MBProgressHUDCompletionBlock completionBlock;</code><br>这两个属性都是用来回传HUD消失事件的,代理协议里面也只有一个HUD已经隐藏的方法</p>
<p><code>@property (assign, nonatomic) NSTimeInterval graceTime;</code>这个属性很有意思,一开始我理解成下面那个属性<code>minShowTime</code>了,往下看到<code>minShowTime</code>之后,我才发现理解错了;这个属性的意思是:如果有graceTime,那么HUD在graceTime之后才显示.作用就是不让时间非常短的任务显示HUD(嗯,用处好像不是很大,我看了下我们项目,没有一个地方使用…)举个例子:我们一般会在网络请求发起之前显示HUD,在网络请求返回时隐藏HUD,在不考虑下面<code>minShowTime</code>属性的情况下,如果这个时间间隔非常短,就会出现显示了HUD瞬间就消失了的尴尬情况,那么这个时候,设置一个graceTime,对于那些时间非常短的异步任务就根本不会显示也没有必要显示HUD了</p>
<p><code>@property (assign, nonatomic) NSTimeInterval minShowTime;</code>这个属性的作用就容易理解多了,最小显示时间;同样也是为了解决时间间隔很短的异步任务问题,你还察觉不到就结束了,那么这个HUD压根就看不见…所以加上这么一个时间</p>
<p><code>@property (assign, nonatomic) BOOL removeFromSuperViewOnHide;</code>这个也是非常好理解,隐藏的时候是否从父视图移除</p>
<h6 id="下面的属性时跟外观-Appearance-相关的"><a href="#下面的属性时跟外观-Appearance-相关的" class="headerlink" title="下面的属性时跟外观(Appearance)相关的"></a>下面的属性时跟外观(Appearance)相关的</h6><p><code>@property (assign, nonatomic) MBProgressHUDMode mode;</code> 样式<br><code>@property (strong, nonatomic, nullable) UIColor *contentColor</code> 内容颜色<br><code>@property (assign, nonatomic) MBProgressHUDAnimation animationType</code> 显示或隐藏时的动画类型<br><code>@property (assign, nonatomic) CGPoint offset</code> 相对于视图中心的边框偏移量<br><code>@property (assign, nonatomic) CGFloat margin</code> HUD边缘和HUD元素之间的间距<br><code>@property (assign, nonatomic) CGSize minSize</code> HUD边框的最小尺寸<br><code>@property (assign, nonatomic, getter = isSquare) BOOL square</code> 如果可能的话，强制HUD尺寸相等。<br><code>@property (assign, nonatomic, getter=areDefaultMotionEffectsEnabled) BOOL defaultMotionEffectsEnabled</code> 当启用时，bezel center会受到设备加速计数据的轻微影响</p>
<h6 id="进度相关属性-Progress"><a href="#进度相关属性-Progress" class="headerlink" title="进度相关属性(Progress)"></a>进度相关属性(Progress)</h6><p><code>@property (assign, nonatomic) float progress;</code> 进度指示器的进度,取值0.0~1.0,默认为0.0</p>
<h6 id="进度对象相关属性-ProgressObject"><a href="#进度对象相关属性-ProgressObject" class="headerlink" title="进度对象相关属性(ProgressObject)"></a>进度对象相关属性(ProgressObject)</h6><p><code>@property (strong, nonatomic, nullable) NSProgress *progressObject;</code> 不是太明白干什么的</p>
<h6 id="视图相关属性-Views"><a href="#视图相关属性-Views" class="headerlink" title="视图相关属性(Views)"></a>视图相关属性(Views)</h6><p><code>@property (strong, nonatomic, readonly) MBBackgroundView *bezelView;</code> 包含文本标签和指示器(或者自定义视图)的边框视图<br><code>@property (strong, nonatomic, readonly) MBBackgroundView *backgroundView;</code> 覆盖整个HUD区域，放置在bezelView后面的视图<br><code>@property (strong, nonatomic, nullable) UIView *customView;</code> 当HUD样式为MBProgressHUDModeCustomView的时候,显示的视图;视图应该实现intrinsicContentSize方法已显示正确的大小,为了得到最好的效果,建议使用37x37像素<br><code>@property (strong, nonatomic, readonly) UILabel *label;</code> 显示在活动指示器下方的文本标签,HUD会自动调整大小以适应整个文本<br><code>@property (strong, nonatomic, readonly) UILabel *detailsLabel;</code> 一个标签，其中包含一个可选的详细信息消息，显示在labelText消息下面。细节文本可以跨越多行。<br><code>@property (strong, nonatomic, readonly) UIButton *button;</code> 放在标签下面的按钮。只有在添加target和action后才可见。</p>
<p>好了,MBProgressHUD的方法属性就这些了…<br>接下来看看MBProgressHUD头文件里,其他的类的声明;</p>
<p>首先是<code>MBRoundProgressView</code>这个应该是饼图样式时使用到的视图,只有4个属性<br><code>@property (nonatomic, assign) float progress;</code> 进度<br><code>@property (nonatomic, strong) UIColor *progressTintColor;</code> 指示器进度的颜色<br><code>@property (nonatomic, strong) UIColor *backgroundTintColor;</code> 指示器背景色<br><code>@property (nonatomic, assign, getter = isAnnular) BOOL annular;</code> 是否环形,不是很清楚什么效果…</p>
<p>然后是<code>MBBarProgressView</code>,这个应该是一个扁平的进度条视图<br><code>@property (nonatomic, assign) float progress;</code> 进度<br><code>@property (nonatomic, strong) UIColor *lineColor;</code> 条状边框线颜色<br><code>@property (nonatomic, strong) UIColor *progressRemainingColor;</code> 条状背景色<br><code>@property (nonatomic, strong) UIColor *progressColor;</code> 条状进度颜色</p>
<p>最后是<code>MBBackgroundView</code>,这个是背景视图<br><code>@property (nonatomic) MBProgressHUDBackgroundStyle style;</code> 背景样式,毛玻璃或者纯色,iOS7和它之后都是毛玻璃效果,之前是纯色<br><code>@property (nonatomic) UIBlurEffectStyle blurEffectStyle;</code> 模糊效果样式<br><code>@property (nonatomic, strong) UIColor *color;</code> 背景色</p>
<p>以上就是MBProgressHUD.h文件的全部内容了,其实还有一部分,是遗弃的旧版本的代码就不看了</p>
<p>下面,我来看看.m文件源码,这才是重点啊</p>
]]></content>
  </entry>
  <entry>
    <title>2023年10月了黑苹果还香吗？性价比超高黑苹果台式机搭配&amp;黑苹果安装教程</title>
    <url>/2023/10/19/2023-10-19-2023%E5%B9%B410%E6%9C%88%E4%BA%86%E9%BB%91%E8%8B%B9%E6%9E%9C%E8%BF%98%E9%A6%99%E5%90%97%EF%BC%9F%E6%80%A7%E4%BB%B7%E6%AF%94%E8%B6%85%E9%AB%98%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%8F%B0%E5%BC%8F%E6%9C%BA%E6%90%AD%E9%85%8D-%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h1><p>最近一段时间对 iOS 逆向开发进行了一定的研究，之前也更新过一段时间的相关文章（后续由于搬家，不幸感染病毒🦠等一些原因断更了个把月），在学习和探索过程中，非常明显的感受到逆向分析对电脑的性能要求很高尤其是 CPU，在使用逆向分析工具 ghidra，hopper 等程序对 MachO 文件进行分析的时候，常常一分析就要等上大几个小时，而且我使用了 n 年的 MacBook Pro 在分析过程中 CPU 温度总是会飙升到 90 度以上，同时 CPU 散热风扇转速也高达 4500 转以上，甚至经常满转速 6000 转运行，噪音可想而知。等待的时间，加上风扇的噪音真的会让人失去耐性，忍无可忍之下决定购买一台性能强劲的，性价比超高的 Mac 电脑。</p>
<p>翻到苹果官网查看，动辄 3 万，5 万，甚至高达 10 万+ 的 iMac，Mac Pro，随随便便几千元的选配，让人直呼**，好奇是什么配置居然敢卖到如此价格，研究一番配置才发现价格真的是太离谱了。。。呃，苹果产品从来就不是主打一个性价比的啊。于是让人想到何不自己动手组装一台台式电脑，既能安装 windows 打打游戏娱乐放松，又能安装黑苹果日常学习工作使用。但是要注意安装黑苹果并不是一件简单，方便，快速，愉悦的事情。而且不建议在公司使用黑苹果，网上看到会收到 Apple 的律师函，尤其是一些大公司。个人作为兴趣爱学习交流使用倒也不必担心那么多。</p>
<p>对组装电脑配置和苹果 Mac 产品有些了解的人应该都知道，苹果的产品毫无性价比，尤其是台式电脑，同等配置的产品，苹果卖的贵很多，的确不可否认的是苹果的产品做的非常优秀，不论是电脑还是手机，从硬件，软件到外观设计，都属于一流的水平。笔记本电脑的确没有几家公司能做到像 MacBook 这样的水平，所以你不想要台式电脑，MacBook 还是可以推荐上车的，台式机是真的不推荐购买。但如果你是富哥想买台式机，有 MacOS 需求，对性能又没有特别高的要求，也不想折腾的，那还是直接去购买 iMac，Mac Pro 吧。但本人不是富哥，对性能还有一定的要求，还愿意折腾的选择自己组装台式机安装黑苹果就是最好的选择。</p>
<h1 id="黑苹果的现状与未来"><a href="#黑苹果的现状与未来" class="headerlink" title="黑苹果的现状与未来"></a>黑苹果的现状与未来</h1><p>最近这两年还能赶上黑苹果的末班车，再过个三五年，最多可能不超过 10 年，市面上所有 Intel + AMD 的白苹果被苹果公司抛弃，不再支持安装最新的 MacOS 系统的时候，应该就再也看不到黑苹果了。</p>
<p>今年 6 月 5 号，最后一代 Intel CPU （至强系列，属于服务器CPU） + AMD GPU 的 Mac Pro 停产了。而最后一代的家用桌面级 CPU 也就是 Intel 酷睿 10910 的 iMac （搭配的 GPU 是 RX 5700XT） 也已经早在 2022 年 3 月 8 号停产了。数据来源：<a href="https://everymac.com/">everymac</a> 。经过网上对黑苹果的一番研究，特别是 GitHub 上的一个开源项目 <a href="https://dortania.github.io/OpenCore-Install-Guide/">OpenCore</a>，感谢开源，感谢hacker，国内的大部分教程其实都是对这个项目的中文翻译加自己的整理，建议想要安装黑苹果的不管英文行的不行的都先看看这个（网页有翻译工具，阅读起来也没那么困难）得出以下一些结论：</p>
<p>到写这篇文章为止，目前能安装黑苹果的最顶级搭配，应该是：</p>
<ul>
<li>CPU i9 13900KS + GPU RX 6950XT，最近刚出的 14 代酷睿还不确定能不能安装黑苹果。</li>
</ul>
<p>最后一代能最完美实现黑苹果的顶级搭配：</p>
<ul>
<li>CPU i9 10910 + GPU RX 5700XT，这个是苹果 iMac 最后一代桌面级 Intel CPU + AMD GPU 产品，已于 2022 年 3 月 8 号停产，之后的 iMac 都是搭配苹果自研的 M 芯片了。购买跟这个同样的配置完全不担心黑苹果安装的问题，完美适配的问题。2022 年 3 月的机型配置，这个配置用个三五年也完全不成问题。</li>
</ul>
<p>个人经过对价格，性能一番分析之后认为，目前最具性价比的黑苹果搭配是：</p>
<ul>
<li>CPU i9 11900KF + GPU RX 6600XT。</li>
</ul>
<h1 id="配件选择"><a href="#配件选择" class="headerlink" title="配件选择"></a>配件选择</h1><p>组装一台台式电脑所需的配件大概是以下 8 个部分。其中对安装黑苹果影响最大的就是 CPU，GPU 了，其次是硬盘，最后稍微可能有点影响的就是内存了，最新的 DDR5 内存频率太高的不太推荐，听说是会影响黑苹果系统的稳定性。其余的就跟能否安装黑苹果没有任何关系了。我将有影响的配件放在前面讲，后续没有影响的配件都简单带过。</p>
<h2 id="CPU-的选择"><a href="#CPU-的选择" class="headerlink" title="CPU 的选择"></a>CPU 的选择</h2><p>原本以为 10 代的 CPU 会比 11 代的 CPU 会更便宜，毕竟是电子产品，年代又更久远一些，万万没有想到 10 代酷睿不知道是有哪些魔力，居然卖的比 11 代酷睿更贵。目前，11900KF 不过 ¥1200 出头，RX 6600XT 如果接受矿卡的话，也只需要 ¥1100 上下，不接受矿卡的可以选择 RX 6650XT。而且性能功耗也比 iMac 最后一代的 RX 5700XT 更加优秀。这样 CPU + GPU 买下来也只需要 ¥2300 左右。而如果买 10910 或者 10900K&#x2F;KF 的话光一个 CPU 就差不多要这个价钱了。其中 </p>
<ul>
<li>10910 价格在 ¥2050 左右。</li>
<li>10900KF 价格在 ¥1950 左右。</li>
<li>10900K 的价格要 ¥2300 以上。</li>
</ul>
<p>这样光一个 CPU 的价格就赶上 11900KF + RX 6600XT 的组合了，性能却还不如这个组合。当然如果你没有 GPU 的需求，购买 10900K 使用它的核显也是可以的。10900K 的核显理论上也能搭配 4k 显示器日常使用。</p>
<p>12 代 i5 12600 及以上等级的 CPU 和 13 代的 i5 13490F 及以上等级的 CPU 单核性能理论上都比 i9 11900KF 强一些（<a href="https://www.mydrivers.com/zhuanti/tianti/cpu/index.html">CPU性能天梯图</a>），但是这几代产品不像魔幻的 10 代酷睿，都是一分钱一分货，都要比 11900KF 贵上一些。如果不追求很高的性价比，希望性能更强一些的，也可以选择这两款或以上的 CPU。</p>
<p><img src="/../images/11900KF.jpg" alt="11900KF"></p>
<h2 id="GPU-的选择"><a href="#GPU-的选择" class="headerlink" title="GPU 的选择"></a>GPU 的选择</h2><p>其实本来是打算照着苹果的最后一代 Intel iMac 的配置去搭配台式机的，这样不用担心能不能成功安装黑苹果，MacOS 系统能不能完美支持。也就是 10 代 i9 搭配 RX 5700XT。但是 10 代酷睿 i9 的价格让我放弃了这个想法，发现了更具性价比的 11 代 i9，于是想着既然 CPU 提升了一个等级，那么显卡要不也提升一下等级吧，RX 6600XT 性能略强于 RX 5700XT（<a href="https://www.mydrivers.com/zhuanti/tianti/gpu/index.html">显卡性能天梯图</a>），功耗却比 RX 5700XT 更低，价格也只贵了两三百元左右，这就是电子产品技术的进步吧，新出的产品性能比老产品强，功耗还要比老产品低。</p>
<p>至于为什么不选择更好的 RX 6800，RX 6800XT，RX 6900XT 的原因（6700系列目前不支持黑苹果），一个是由于价格原因，这几张显卡都不是 1k+ 能够拿得下来的。第二是由于本人对显卡的需求也不是那么高，RX 6600XT 在 1k 分辨率下也能无压力的运行。甚至在 2k 分辨率下也可以流畅运行满足大部分需求。搭配 4k，5k 显示器日常使用也完全没有问题，iMac 搭配的显卡 RX 5700XT 性能差不多就是配置的 5k 显示器，日常使用肯定没问题，当然如果你想要这张显卡搭配 4k 及以上分辨率显示器在 Windows 下愉快玩大型3A游戏，那可能还是有点强卡所难了，要么降低游戏的分辨率，要么直接上最顶级的 RX 6900XT&#x2F;6950XT。</p>
<h2 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h2><p>硬盘部分不是我这篇文章的重点，大部分硬盘都是没问题的，只有某些 nvme 硬盘无法安装，推荐看一下 <a href="https://hpglw.com/cdc6109c.html">这篇文章</a>。本人选择的前段时间性价比很高的宏碁掠夺者 GM7000 2T 带独立缓存，对于开发者来说应该是特别适合的。实测安装黑苹果没有问题。</p>
<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>本人选择的是金百达银爵 16g * 2 3200 Mhz DDR4。搭配后面的主板开启 XMP 之后轻轻松松上到 3600 Mhz。虽然我也不甚了解现在越来越高的内存频率有什么特别大的实际作用。。。</p>
<h2 id="主板"><a href="#主板" class="headerlink" title="主板"></a>主板</h2><p>已经上到 i9 处理器了，主板毫无疑问推荐 Z 系列主板。Intel CPU 和主板搭配有个规律，就是 CPU 代数和主板芯片组有一个 6 的差距，比如：</p>
<ul>
<li>10 代 i9，那么搭配的主板芯片组应该是 Z490，但其实大部分 Z490 芯片组更新 BIOS 之后也能安装 11 代 CPU。</li>
<li>11 代 i9，那么搭配的主板芯片组应该是 Z590，Z590 芯片组可以安装 10 代和 11 代的 CPU。</li>
<li>12 代 i9，推荐搭配的主板芯片组是 Z690，大部分 Z690 芯片组更新 BIOS 也能安装 13 代 CPU。</li>
<li>13 代 i9，推荐搭配的主板芯片组是 Z790</li>
</ul>
<p>大概这样理解是没有问题的，只是有一些主板的兼容性好一点，多兼容几代 CPU，其实关键的地方在于 CPU 的针脚是否发生变化。主板个人选择的是某爱国嘉的 Z590M GAMING X，选择 MATX 主板的原因是不想要那么大的机箱。但是目前这款主板已经不好买到了，二手市场也几乎见不到几块了，不在乎机箱尺寸的可以选择常规 ATX 大小主板 Z590 GAMING X，这款市面上还是有不少在售卖的。</p>
<h2 id="CPU散热器"><a href="#CPU散热器" class="headerlink" title="CPU散热器"></a>CPU散热器</h2><p>CPU散热器的选择大体上分为两种，风冷和水冷。本人并不喜欢和信任水冷所以优先考虑的是风冷，11900KF 这种 11 代顶级 CPU 在满载的时候的发热量巨大，原本考虑的是利民风冷之王 FC140 ，无奈在准备购买的时候听客服说，这款产品会挡住 Z590M GAMING X 这款主板的内存，无法考证客服的说法。但按客服的推荐，选择了一款新出的利民 PS120 综合比较下来散热不输 FC140 ，尺寸也较小一圈不挡内存。</p>
<p>遗憾的是，经过实测这款散热器即使换上了台达的 12cm 3000 转暴力风扇也无法让 11900KF 不降频通过烤机测试。不过这是在开启了 AVX512 指令集的情况下。实测关闭了 AVX512 指令集之后，可以不降频通过烤机测试，温度在 80 多度左右。说实话我也一直想尝试搞懂这个 AVX512 指令集的实际作用，奈何太专业了，没搞明白。所以如果你不介意的话，关闭它之后 PS120 完全可以压制住 11900KF 这个 CPU。</p>
<p>但如果你实在介意买了这颗 CPU ，还不能完全使用它的功能，还要关闭这个虽然不知道有什么实际用途的 AVX512 指令集。那么还是建议上顶级的 240 水冷，或者 360 水冷吧。由于我机箱的限制，最多只能上到 240 水冷。不过目前并没有换的打算，因为我实在想不到除了烤机测试，还有哪些场景下能够让 CPU 满载运行很长时间。实在有这个需求了，关掉 AVX512 指令集在 PS120 的压制下也能长期满载运行。</p>
<h2 id="电源"><a href="#电源" class="headerlink" title="电源"></a>电源</h2><p>电源的选择最重要的是功率。根据你的 CPU 和 GPU 的搭配选择适合的功率，不然你的电脑可能连开机都成问题。一开始本人并不是特别了解，随便看到几篇抖音说 RX 6600XT 显卡搭配 600W 电源就行了。于是一开始买了个 600W 的长城 V6 600W 金牌全模组电源，结果在装机的时候常常发生显示器点不亮的情况，有时候重新开机几次又能点亮，有时候开机多次也无法点亮。甚至一度怀疑是显卡，或者主板的问题去了。。。后来在 <a href="https://seasonic.com/wattage-calculator">SEASONIC<em>海韵电源</em></a> 和 <a href="https://www.msi.cn/power-supply-calculator">MSI 微星</a> 的官网找到了电源功率计算器这个工具，计算下来才发现，我的配置 i9 11900KF + RX 6600XT 最低要求的电源功率也要 650W ，推荐上 700W 及以上功率的电源更好，这样可以应对以后配件升级的情况。至于其他的什么电容啊，80PLUS认证，模组化啊，本人倒觉得不是那么必要，功率才是必须要选择对的。由于本人并没有后期升级的打算，于是就换成了长城的 V7 700W 金牌全模组电源。</p>
<h2 id="机箱"><a href="#机箱" class="headerlink" title="机箱"></a>机箱</h2><p>机箱之前说过，本人不喜欢特别大的机箱，电脑的发展历史，就是越做越小的一段历史。现在的商家为了把产品卖出更高的价格，往往高配置的电脑喜欢搭配巨大的机箱。。。本人真的是接受不了。所以选择了一块 mATX 主板，那么机箱自然也是选择搭配 mATX 主板的小机箱。本人选择的是旅行者，机箱上方附带一个把手，可以很方便的一只手提起来。机箱不自带风扇，本人额外购买了两把台达 12cm 3000转静音温控风扇，只要 ¥17 元人民币1把。真的是物美价廉，风量比太多所谓的品牌风扇大多了。</p>
<h1 id="安装-Hackintosh"><a href="#安装-Hackintosh" class="headerlink" title="安装 Hackintosh"></a>安装 Hackintosh</h1><p>硬件都选配好了，接下来就是安装系统了。如果你选择的是 10 代酷睿 CPU，那么按照 OpenCore 官方文档的步骤来进行黑苹果安装，会十分的顺利，因为 OpenCore 目前对 10 代及以内的 CPU 的文档都特别详细。10 代之后的 CPU 有一些官方文档没有明确写明的地方需要自己摸索。</p>
<p>安装黑苹果的步骤，概括的来说，跟安装 window 没有太大区别，多了一个自己配置 EFI 文件的步骤。</p>
<h2 id="1-将-U-盘制作成系统安装盘"><a href="#1-将-U-盘制作成系统安装盘" class="headerlink" title="1. 将 U 盘制作成系统安装盘"></a>1. 将 U 盘制作成系统安装盘</h2><p>制作 U 盘系统安装盘的方式多种多样，这里我只讲诉我自己的使用过的方式，就是在 MacOS 上制作。其他的方式自己参考 <a href="https://dortania.github.io/OpenCore-Install-Guide/installer-guide/">OpenCore文档</a>。</p>
<h3 id="1-1-下载-macOS-安装程序"><a href="#1-1-下载-macOS-安装程序" class="headerlink" title="1.1 下载 macOS 安装程序"></a>1.1 下载 macOS 安装程序</h3><p>使用 App Store 搜索你想要安装的 Mac OS 系统，下面以 macOS Ventura 为例。</p>
<p><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/4af03ee077ece3249a40d34b6003ff43c1809189/20231019/01.png" alt="image.png"></p>
<p>点击获取就可以等待下载完成了。。。下载完成之后可以在启动台中看到，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/4af03ee077ece3249a40d34b6003ff43c1809189/20231019/02.png" alt="Xnip2023-10-18_14-58-49.png"></p>
<p>在等待下载的过程中，可以先执行下一步格式化 U 盘。</p>
<h3 id="1-2-格式化-U-盘"><a href="#1-2-格式化-U-盘" class="headerlink" title="1.2 格式化 U 盘"></a>1.2 格式化 U 盘</h3><p>U 盘大小建议至少是 16G 以上的。<br><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/4af03ee077ece3249a40d34b6003ff43c1809189/20231019/03.png" alt="image.png"></p>
<p>然后点击右上角的抹掉，之后按照下图的选择进行抹掉操作。</p>
<p><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/4af03ee077ece3249a40d34b6003ff43c1809189/20231019/04.png" alt="Xnip2023-10-18_16-52-01.png"></p>
<p>这里的名称一定要记住，后面还要用到的。我的建议是改成 OpenCoreUSB，当然这个无所谓，只要记得后面要用到就行。</p>
<h3 id="1-3-将-U-盘制作成系统安装盘"><a href="#1-3-将-U-盘制作成系统安装盘" class="headerlink" title="1.3 将 U 盘制作成系统安装盘"></a>1.3 将 U 盘制作成系统安装盘</h3><p>等到 macOS 安装程序下载好了之后，也即是在 1.1 中的第二张图片那样，在启动台中能看到安装 macOS Ventura 了。打开系统自带的终端app，输入以下指令（友情提示，太长的指令可以输入前几个字母之后按 TAB 键自动补全）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo /Applications/Install\ macOS\ Ventura.app/Contents/Resources/createinstallmedia --volume /Volumes/OpenCoreUSB</span><br></pre></td></tr></table></figure>
<p>输入电脑开机密码之后，再输入 y 按回车确认。安装时间有点慢，取决于你的 U 盘读写速度。如下图所示</p>
<p><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/4af03ee077ece3249a40d34b6003ff43c1809189/20231019/05.png" alt="Xnip2023-10-18_17-33-34.png"></p>
<p>跟上面结果一样就表示你的U盘系统安装盘制作好了</p>
<h2 id="2-配置-EFI-文件夹"><a href="#2-配置-EFI-文件夹" class="headerlink" title="2. 配置 EFI 文件夹"></a>2. 配置 EFI 文件夹</h2><p>安装黑苹果的步骤当中，最麻烦的就是这一步了。很多人会去网上搜索跟自己配置相同的人分享出来的 EFI 文件。但是实际上往往很难搜到完全相同的配置，或者即使是完全相同的配置依然是无法成功安装黑苹果。所以还是推荐照着 OpenCore 官方文档的步骤一步步自己动手配置 EFI 文件最靠谱。我这里会大概讲一下我自己配置的过程，具体的很多细节可以查阅官方文档中。</p>
<h3 id="2-1-下载-OpenCore-最新的版本"><a href="#2-1-下载-OpenCore-最新的版本" class="headerlink" title="2.1 下载 OpenCore 最新的版本"></a>2.1 下载 OpenCore <a href="https://github.com/acidanthera/OpenCorePkg/releases/">最新的版本</a></h3><p>这里会有 Debug 和 Release 两个版本，虽然官方推荐第一次使用选择 Debug 版本，但是我个人的经验来看还是建议直接选择 Release 版本，因为只要是按照教程一步步来的，基本不会出现问题，而就算你使用 Debug 版本出现了报错，也基本上看不懂任何一点报错的代码。。。太抽象了，反正我的确是用过 Debug 版本也遇到无法安装的情况，结果就是完全看不懂一点报错信息，也搜不到任何相关的资料。反而是认认真真照着教程又重新配置了几遍，才成功安装上的，最后还要回过头将所有 Debug 版本文件替换为 Release 版本。</p>
<p>我们将要使用的 EFI 文件夹：</p>
<p><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/4af03ee077ece3249a40d34b6003ff43c1809189/20231019/06.png" alt="image.png"></p>
<h3 id="2-2-挂载-U-盘上的-EFI-分区"><a href="#2-2-挂载-U-盘上的-EFI-分区" class="headerlink" title="2.2 挂载 U 盘上的 EFI 分区"></a>2.2 挂载 U 盘上的 EFI 分区</h3><p>在前面格式化 U 盘的过程中，我们选择的格式化方案会在 U 盘上自动创建一个隐藏的没有挂载到系统的 EFI 分区，现在需要将这个分区挂载到系统上，以便我们操作这个分区。挂载的方式有很多种</p>
<ul>
<li>有通过终端纯命令行的方式 <a href="https://github.com/corpnewt/MountEFI">MountEFI</a>。</li>
<li>也有通过使用一个 app 的图形化的方式 <a href="https://mackie100projects.altervista.org/download-opencore-Configurator/">OpenCore Configurator</a>。</li>
</ul>
<p>以下是使用 OpenCore Configurator 的截图。</p>
<p><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/4af03ee077ece3249a40d34b6003ff43c1809189/20231019/07.png" alt="image.png"></p>
<p>挂载之后就可以看到 U 盘的隐藏 EFI 分区了。然后将上一步中下载的 EFI 文件夹复制到这个 EFI 分区中。注意 EFI 分区下有一个 EFI 文件夹不要搞糊涂了。</p>
<h3 id="2-3-添加文件到各个子文件中"><a href="#2-3-添加文件到各个子文件中" class="headerlink" title="2.3 添加文件到各个子文件中"></a>2.3 添加文件到各个子文件中</h3><p>从现在开始，要确保我们所有的操作都是对 U 盘 EFI 分区的 EFI 文件夹进行操作。现在，先简单认识一下 EFI 文件夹里的子文件夹：</p>
<p><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/4af03ee077ece3249a40d34b6003ff43c1809189/20231019/08.png" alt="image.png"></p>
<ul>
<li><p>ACPI：说实话，这个文件夹我一直没有完全搞明白，翻译的内容，英文的缩写太多了，只知道这里面的内容大概跟 CPU 架构和电源管理等内容相关，官方文档只讲到了 10 代酷睿，后面的 11，12，13 以及刚出的 14 代酷睿并不在官方文档中，但我从其他资料中看到，10 代之后的酷睿 CPU 都可以按照 10 代酷睿的那样配置。所以按照我的配置，我们需要以下三个文件：</p>
<p>  <img src="https://raw.githubusercontent.com/masterKing/markDownPictures/4af03ee077ece3249a40d34b6003ff43c1809189/20231019/09.png" alt="image.png"></p>
<ul>
<li><a href="https://github.com/dortania/Getting-Started-With-ACPI/blob/master/extra-files/compiled/SSDT-AWAC.aml">SSDT-AWAC.aml</a></li>
<li><a href="https://github.com/dortania/Getting-Started-With-ACPI/blob/master/extra-files/compiled/SSDT-EC-USBX-DESKTOP.aml">SSDT-EC-USBX-DESKTOP.aml</a> </li>
<li><a href="https://github.com/dortania/Getting-Started-With-ACPI/blob/master/extra-files/compiled/SSDT-PLUG-DRTNIA.aml">SSDT-PLUG-DRTNIA.aml</a></li>
</ul>
</li>
<li><p>Drivers：固件驱动程序是 OpenCore 在 UEFI 环境中使用的驱动程序。大部分情况下我们只需要两个文件</p>
<p>  <img src="https://raw.githubusercontent.com/masterKing/markDownPictures/4af03ee077ece3249a40d34b6003ff43c1809189/20231019/10.png" alt="image.png"></p>
<ul>
<li><a href="https://github.com/acidanthera/OcBinaryData/blob/master/Drivers/HfsPlus.efi">HfsPlus.efi</a></li>
<li><a href="https://github.com/acidanthera/OpenCorePkg/releases">OpenRuntime.efi</a></li>
</ul>
<p>  虽然下载的 OpenCore 自带的 Drivers 里面会有很多文件，其中也包括上面这些文件，但我个人还是建议删掉自带的所有 efi 文件，点击上面的链接自己下载。因为自带的文件有些名字都改了，搞的人不知道该怎么处理。</p>
</li>
<li><p>Kexts：kext 是一个内核扩展，您可以将其视为 macOS 的驱动程序。大多数 kext 都可以在 <a href="https://dortania.github.io/builds/">构建存储库</a> 中找到已编译好的。每次有新提交时都会编译此处的 Kext。对于我的配置，需要以下这些文件</p>
<p>  <img src="https://raw.githubusercontent.com/masterKing/markDownPictures/4af03ee077ece3249a40d34b6003ff43c1809189/20231019/11.png" alt="image.png"></p>
<ul>
<li><a href="https://dortania.github.io/builds/?product=Lilu&viewall=true">Lilu.kext</a> 用于修补许多处理器的补丁，也是很多其他内核扩展的基础。</li>
<li><a href="https://github.com/acidanthera/VirtualSMC/releaseshttps://github.com/acidanthera/VirtualSMC/releases">SMCProcessor.kext</a> 用于监控 Intel CPU 温度</li>
<li><a href="https://github.com/ChefKissInc/RadeonSensor/releases">SMCRadeonGPU.kext</a> 用于监控 GPU 温度</li>
<li><a href="https://github.com/ChefKissInc/RadeonSensor/releases">RadeonSensor.kext</a> 还有一个 RadeonGadget 是一个 app 用于在右上角显示 GPU 温度的，需要搭配当前内核扩展使用，所以并不需要放在 Kexts 下。</li>
<li><a href="https://github.com/acidanthera/VirtualSMC/releaseshttps://github.com/acidanthera/VirtualSMC/releases">SMCSuperIO.kext</a> 这个和 SMCProcessor.kext 在一块</li>
<li><a href="https://dortania.github.io/builds/?product=WhateverGreen&viewall=true">WhateverGreen.kext</a> 显卡驱动，可以从构建存储库中下载最新版本。</li>
<li><a href="https://dortania.github.io/builds/?product=AppleALC&viewall=true">AppleeAlc.kext</a> 声卡驱动，还需要在配置文件中添加一个配置。在官方文档上可以看到。</li>
<li><a href="https://www.insanelymac.com/forum/files/file/1004-lucyrtl8125ethernet/">LucyRTL8125Ethernet.kext</a> 有线网卡驱动</li>
<li><a href="https://github.com/USBToolBox/kext/releases">USBToolBox.kext</a> 用于修复 USB 端口连接的</li>
<li>UTBMap.kext 这个扩展需要借助这个<a href="https://github.com/USBToolBox/tool/releases">工具</a>自己制作自己的。</li>
<li><a href="https://github.com/acidanthera/NVMeFix/releases">NVMeFix.kext</a> 用于修复非 Apple NVMe 上的电源管理和初始化</li>
<li><a href="https://github.com/acidanthera/RestrictEvents/releases">RestrictEvents.kext</a> 这个对我来说主要是为了修复在模仿使用 MacPro7,1 机型的时候，右上角会弹出“内存模块配置错误”的问题的。<!--但是我使用了一段时间后才发现，右上角有一个小的矩形区域无法点击的bug，不知道是不是它导致的。其实不要这个扩展也没什么问题，要么换成 iMacPro1.1 机型就不会有这个提示，要么不在乎提示，每次启动后出现的时候点击关闭就好了。--></li>
</ul>
</li>
<li><p>Resources：这里主要是美化 OpenCore 启动时的外观界面的，如果不配置就使用纯字母的形式显示，配置了会有图标，好看一点，就像白苹果里那样显示。感兴趣的可以去官网搜索自行配置。不影响安装。</p>
</li>
<li><p>Tools：工具类的文件，可以放在这里，不过不懂如何使用的也没什么必要放了，毕竟也不影响安装。</p>
</li>
</ul>
<p>这里我并没有添加无线网卡蓝牙相关的驱动，因为我没有 macOS 上能驱动的无线网卡，如果有这个需要打算购置的话可以查看 <a href="https://dortania.github.io/Wireless-Buyers-Guide/">无线网卡购买指南</a>。</p>
<h3 id="2-4-配置-config-plist-文件"><a href="#2-4-配置-config-plist-文件" class="headerlink" title="2.4 配置 config.plist 文件"></a>2.4 配置 config.plist 文件</h3><p>plist 文件对于 iOS 开发者来说并不陌生，对其他开发者来说可以理解成一种特殊的 XML 文件。上一步添加需要的文件麻烦，这一步则可能是最麻烦的了。需要按照 <a href="https://dortania.github.io/OpenCore-Install-Guide/config.plist/comet-lake.html">官方文档</a> 仔细比对每个需要的键。先从下载的 OpenCore 文件夹中找到 Sample.plist 文件，然后复制到 U 上 EFI 分区的 OC 文件夹下并重命名为 config.plist。</p>
<p><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/4af03ee077ece3249a40d34b6003ff43c1809189/20231019/12.png" alt="image.png"></p>
<p>虽然可以直接通过 Xcode 对 config.plist 进行编辑，不过由于大多数人对这个文件的修改都不熟悉，不知道哪些能不能删，如何修改，所以还是建议使用一些专门的工具进行编辑，就比如我们之前挂载 EFI 分区使用到的 <a href="https://mackie100projects.altervista.org/download-opencore-Configurator/">OpenCore Configurator</a>。这个 plist 文件主要的工作其实就是对当前文件夹下的其他文件，建立一个关联，当然还有它本身自带一个配置需要修改。</p>
<p>绝大部分的配置，官方文档都写的很清楚了，我不再重复，只有以下几点，官方文档没有写明的：</p>
<ol>
<li><p>Kernel -&gt; Emulate<br> 也就是仿冒 CPU。 对于 10 代酷睿之后的 CPU 都需要配置这个键。其实这个配置可以在 OpenCore 下载的文档里可以找到。Rocket Lake 就是 11 代酷睿的 CPU 代号</p>
<p> <img src="https://raw.githubusercontent.com/masterKing/markDownPictures/4af03ee077ece3249a40d34b6003ff43c1809189/20231019/13.png" alt="image.png"></p>
<p> 在 OpenCore Configurator 中的设置如下：</p>
<p> <img src="https://raw.githubusercontent.com/masterKing/markDownPictures/4af03ee077ece3249a40d34b6003ff43c1809189/20231019/14.png" alt="image.png"></p>
</li>
<li><p>如何使用 OpenCore Configurator。用它打开你 OC 文件夹下的 config.plist 可能会有一些默认的配置，使用右下角的 - 号全部删除。点击快照&#x2F;浏览会自动添加对应的文件夹下的文件。修改完成后记得保存，最后可以用 Xcode 或预览查看刚刚的修改是否真的保存了。</p>
</li>
</ol>
<p>如果你有足够的耐心，照着官方的文档，一步步完成了所有应该的配置。那么恭喜🎉你可以进入下一步，安装系统了</p>
<h2 id="3-安装系统"><a href="#3-安装系统" class="headerlink" title="3. 安装系统"></a>3. 安装系统</h2><h3 id="3-1-调整主板-BIOS"><a href="#3-1-调整主板-BIOS" class="headerlink" title="3.1 调整主板 BIOS"></a>3.1 调整主板 BIOS</h3><p>在正式开始安装之前，还需要对主板的 BIOS 进行一些设置。<a href="https://dortania.github.io/OpenCore-Install-Guide/config.plist/comet-lake.html#cleaning-up">官网</a> 和 <a href="https://apple.sqlsec.com/3-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/3-1/">国光</a> 的教程都很全面了，我这里只讲一下自己的主板 z590m gaming x 有的一些设置。这里我已经将 BIOS 更新到最新的 F8 版本了，在技嘉官网下载并更新最新版本的 <a href="https://www.gigabyte.com/Motherboard/Z590M-GAMING-X-rev-10/support#support-dl-bios">BIOS</a> ，这一步可能不是必须的。因为即使是最新的版本，依然有很多设置没有出现在 BIOS 中。以下是我这个主板的一些 BIOS 设置。</p>
<h4 id="禁用"><a href="#禁用" class="headerlink" title="禁用"></a>禁用</h4><ul>
<li>Fast Boot 这个有，在 Boot 选项下</li>
<li>Secure Boot 这个有，在 Boot 选项下</li>
<li>Serial&#x2F;COM Port 有，在 Settings -&gt; IO Ports -&gt; Super IO Configuration 下</li>
<li>Parallel Port 没找到</li>
<li>VT-d 有，Favorites 下就有，同样出现在 Settings -&gt; Miscellaneous 下</li>
<li>Compatibility Support Module (CSM) 有，在 Boot 下</li>
<li>Thunderbolt 没找到</li>
<li>Intel SGX 没找到</li>
<li>Intel Platform Trust 有，在 Setting -&gt; Miscellaneous 下</li>
<li>CFG Lock (MSR 0xE2 write protection) 有，在 Boot 下</li>
</ul>
<h4 id="开启"><a href="#开启" class="headerlink" title="开启"></a>开启</h4><ul>
<li>VT-x 没找到</li>
<li>Above 4G Decoding 有，在 Settings -&gt; IO Ports 下</li>
<li>Hyper-Threading 有，在 Tweaker -&gt; Advanced CPU Setings 下</li>
<li>Execute Disable Bit 没找到</li>
<li>EHCI&#x2F;XHCI Hand-off 有，在 Settings -&gt; IO Ports -&gt; USB Configuration 下</li>
<li>OS type: Windows 8.1&#x2F;10 UEFI Mode (some motherboards may require “Other OS” instead) 没有一样的，但是将 Boot 下的 Windows 10 Features 设置为 Other OS 了</li>
<li>DVMT Pre-Allocated(iGPU Memory): 64MB or higher 没找到，对于11900KF不带核显的 CPU 应该是没有这个设置的。</li>
<li>SATA Mode: AHCI 有，在 Settings -&gt; IO Ports -&gt; SATA And RST Configuration 下</li>
</ul>
<h3 id="3-2-开始安装"><a href="#3-2-开始安装" class="headerlink" title="3.2 开始安装"></a>3.2 开始安装</h3><p>终于来到了这激动人心的安装步骤。确保 U 盘插入主板后面的 USB3 插口上，我试过插在机箱面板的插口上会有些问题，开机按 F12 选择 U 盘启动。就会进入到 OpenCore 的选择页面，选择 Install macOS Ventura (external) ，进入后先选择磁盘工具格式化硬盘，选择 APFS 格式和 GUID 分区图方案。完成之后，退出磁盘工具，选择安装 macOS Ventura 接下来的操作就是按照提示一步步操作了，中间会重启多次，直到进入选择语言界面，那么恭喜你，你做到了！</p>
<h1 id="实测"><a href="#实测" class="headerlink" title="实测"></a>实测</h1><p>安装完后看看关于本机，和 Geekbench 的信息</p>
<p><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/4af03ee077ece3249a40d34b6003ff43c1809189/20231019/15.png" alt="image.png"></p>
<p>先上一下 Geekbench 5 的跑分。</p>
<p><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/4af03ee077ece3249a40d34b6003ff43c1809189/20231019/16.png" alt="image.png"></p>
<p>可能很多人并不知道，这个跑分的水平在哪里。所以我找了几款 Mac 机型的跑分作为对比。</p>
<ol>
<li><p>同为 MacPro7,1 型号的白苹果，在今年 6 月 5 号刚停产。搭配的是 Intel Xeon 处理器。选用28核的这款作为对比。可以看到 11900KF 的单核性能远超这款配置。多核性能由于 11900KF 只有 8 个核心，的确比不上 28 核心的 Xeon，但也有一个不错的分数。但是考虑到这款配置的 MacPro 的售价 RMB 103,379 。这点多核心性能的差距简直不值一提。</p>
<p> <img src="https://raw.githubusercontent.com/masterKing/markDownPictures/4af03ee077ece3249a40d34b6003ff43c1809189/20231019/17.png" alt="image.png"></p>
<p> 如果选用同样是 8 个核心的 Xeon 处理器那款 MacPro7,1 则无论是单核性能还是多核性能都会被 11900KF 吊打。恐怖的是 8 核心的这款 MacPro 7,1 售价也高达 RMB 51,999。对比我自己配置的这台 5000 块都不到的 11900KF 真的是太香了。</p>
</li>
<li><p>最新款的 MacPro14,8 搭载的是 Apple 自研的 M2 Ultra 芯片。M2 芯片分为 M2，M2 Pro，M2 Max，M2 Ultra，性能依次上升。11900 KF 的性能介于 M2 和 M2 Pro 之间。再考虑到 M2 芯片的最便宜的机型 MacBookAir 最低也要 1w 以上。自己配的 11900KF 还是还是很香的，只是没有上面那么香😄罢了。M2 芯片作为 2022 年的产品的确还是要比 2021 年上市的 11900KF 性能强劲，而且功耗更低。当然，如果一定要用 Intel 来对比 M 芯片，可能依然是 13900KS 更加强劲。但用 13900KS 性价比就没有 11900KF 那么高了。</p>
<p> <img src="https://raw.githubusercontent.com/masterKing/markDownPictures/4af03ee077ece3249a40d34b6003ff43c1809189/20231019/18.png" alt="image.png"></p>
</li>
</ol>
<p>说完了跑分上面的测试，说说自己实际的体验吧。用 ghidra 分析同一份 MachO 文件的耗时，老电脑依旧是好几个小时以至于我都没有测完就放弃了，而新电脑也用了快 1 个小时。这可能是由于 ghidra 为了通用性跨多个平台都能使用，所以并没有完全利用每个平台的完整性能，导致都比较慢吧。</p>
<p>用 hopper 分析同一份 MachO 文件的耗时，hopper 在分析完之后会给出后台分析的耗时，新电脑只有 7 分钟左右，老电脑分析了接近 30 分钟，提升还是很明显的。免费的 hopper 每次只有 30 分钟的体验时间，以前每次分析完，就到时间了，多难受。。。</p>
<p>显卡方面的测试，由于我目前并没有剪辑，制图方面的需求，所以就没有测试了。。。</p>
<p>编译了一个以前非常耗时的 Xcode 项目对比，也快了许多。总的来说，性能提升非常的明显。自己组装台式电脑安装黑苹果真的是太香了，趁着现在黑苹果所剩不多的几年，有需要的人可以赶紧上车了。</p>
]]></content>
      <categories>
        <category>黑苹果</category>
      </categories>
      <tags>
        <tag>黑苹果</tag>
        <tag>Hackintosh</tag>
      </tags>
  </entry>
  <entry>
    <title>8天让iOS开发者上手Flutter之一：快速入门Flutter</title>
    <url>/2021/07/10/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8Flutter/</url>
    <content><![CDATA[<p>flutter 现在是越来越火了，现在作为一个 iOS 开发，如果你不会 flutter 都好像不算个正常人似的？而且现在的 flutter 情况，有点像 2012 年那会儿刚刚兴起的 iOS，Android 开发一样，会点皮毛 UI 就可以提升不少身价…这些年过来，有无数的前端跨平台框架兴起。却只有 flutter 一家独秀，说明它还是有两把刷子的。今天这篇文章内容是基于 Mac 和 Android Studio 基础来开发 flutter 的，如果你还没有配置好开发环境，可以在网上搜索，或者直接到官网安装。这篇文章主要用来记录我学习 flutter 的过程，如果你也对 flutter 感兴趣可以跟着一起练习。</p>
<p>配置好 Flutter 环境之后，开始创建我们的第一个 Flutter 工程</p>
<h1 id="创建第一个-Flutter-工程"><a href="#创建第一个-Flutter-工程" class="headerlink" title="创建第一个 Flutter 工程"></a>创建第一个 Flutter 工程</h1><p>打开 iTerm2，cd 到 ~&#x2F;AndroidStudioProjects 目录，输入以下命令，没有 iTerms 的使用 Mac 系统自带的 Terminal 也行。<br></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">flutter create flutter_demo</span><br></pre></td></tr></table></figure>

<p>这里需要注意，AndroidStudio 项目名称不能使用大写字母，这里推荐使用小写字母加下划线给工程命名。</p>
<p><img src="c12dd5b7513e4a3a87c4249d6bff3e5a~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>打开对应的目录，可以看到新建了一个 <code>flutter_demo</code> 目录</p>
<p><img src="f65f809f540045a594d2e8c4207eb44d~tplv-k3u1fbpfcp-watermark.png" alt="image.png"><br></p>
<p>接下来，cd 到 <code>flutter_demo</code> 目录，在终端输入 <code>flutter run</code> 命令，它就会运行项目，如果你电脑连接了真机，就会自动运行到真机上，没有真机会去寻找模拟器并运行，模拟器也没有，就会打开一个 Chrome 网页运行项目 (flutter 项目目前可以运行在 iOS，Android，web 上)。我这里连上了 iPhone 真机，运行项目会报一个 BUILD FAILED 的错误:</p>
<p><img src="01063bff94594693889713336801ab99~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>原因是 flutter_demo 项目生成的 iOS 项目默认的 bundle identifier 咱们用不了，去 iOS 项目里面修改一下就好了</p>
<p><img src="7869a380e58e4bb4bee43d7632f9ad63~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>这里注意我们免费的开发者证书，在 iPhone 上最多安装 3 个开发中的 APP，多了就安装不了，删掉之前的 APP 就好了，再次运行 <code>flutter run</code> </p>
<p><img src="12983baee1574506aabf12d1383af6ed~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>可以看到这里给出了 flutter 运行的一些关键命令，Hot reload 热重载，这个特性对我们开发 UI 时还是比原生的体验好不少的，它不用我们重新运行项目就能看到 UI 的一些改变。Hot restart 热重启，意思不用退出 APP，就直接重新运行了。此时真机上就打开了我们的第一个 flutter 工程的 APP</p>
<div align="center">
<img src="0b9a168158354713a31d3103001fd8f8~tplv-k3u1fbpfcp-watermark.jpg">
</div>

<h1 id="HelloFlutter"><a href="#HelloFlutter" class="headerlink" title="HelloFlutter"></a>HelloFlutter</h1><p>上面是通过命令创建一个 flutter 项目，当然在实际开发过程我，我们一般不会这么操作。使用 Android Studio 来创建 flutter 项目。没有这个选项的同学，在 Android Studio 的插件里面选择 flutter 并安装就有了，如果提示还需要安装 Dart 就一块安装了，flutter 使用的是 Dart 语言。iOS 开发者没必要被这个新语言给吓到了，现代的语言基本都差不了太多，敲着敲着就熟悉了</p>
<p><img src="65f2784c45fc45728781cfd1d77a618c~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>点击后会出现以下界面，目前我们选择 Flutter App 就好了</p>
<p><img src="c2ad2dcb3a05426fae1347fab30f7054~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>下一个界面会让我们设置工程名称，工程位置，工程描述，工程组织，Android 语言，iOS 语言等等…我这里设置工程名称为 hello_flutter，其他的默认选择就好了…也可以根据你自己的需要选择</p>
<p><img src="6b9e58c9ee274fe695c3094500da4961~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>点击 Finish 之后就可以看到完整的工程目录了，flutter 工程的主入口，跟我们 iOS 项目一样有一个 main.m 文件，flutter 的是 main.dart 文件，可以看到这个文件里面已经有不少初始的代码了，今天是我们第一次接触 flutter 项目，就不要这里的代码，全部删掉，我们从第一行代码开始自己敲出来</p>
<p><img src="8caf387fbb084bf681dac3caa7863f7f~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p><img src="fad716135bad4cc986a89968f01bc083~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<ul>
<li>导入 material.dart 头文件(相当于 iOS 中 UIKit)</li>
<li>写一个 main() 函数作为主入口</li>
<li>调用 runAPP() 函数</li>
<li>Center 类是用来布局的类，表示一个位置，child 属性表示他有的子控件的意思。Text 类就是我们文本类，有点儿我们 iOS 的 UILabel 的意思，Text 类的第一个参数就是具体的文本，省略了参数名，第二个参数 <code>textDirection</code> 表示文本显示方向，我们习惯的从左至右就是 <code>TextDirection.ltr</code>，left to right。像一些阿拉伯语言，希伯来语的文字就是从右到左显示的，我这里试了一下 hello world 的方向并没有变化，可能还需要其他设置吧…<br></li>
</ul>
<p>运行之后 iPhone 显示如下：</p>
<div align="center">
<img src="1fcd588320c3486f9b78bf16e0ef090e~tplv-k3u1fbpfcp-watermark.jpg">
</div>

<h1 id="自定义-Widget"><a href="#自定义-Widget" class="headerlink" title="自定义 Widget"></a>自定义 Widget</h1><p>flutter 里面的 Widget 类叫作小部件，是 flutter 里面经常用到的，它分为有状态的 Stateful 和 Stateless 无状态的。其中无状态的比较简单，我们先自定义一个类 CustomWidget 继承自 StatelessWidget。我们自定义的 Widget 想要显示到屏幕上需要实现一个 build 的函数，系统会调用这个函数来渲染我们想要显示到屏幕上的内容</p>
<p><img src="2644086b52ce4c129b4166634f3aea71~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>这个时候，如何将我们的 hello flutter 显示到屏幕呢，可以看到 runApp 函数里面有一个 Center 类，我们 CustomWidget 类的 build 方法也是返回的一个 Center 类，所以可以直接将我们 CustomWidget 初始化给 runApp 作参数</p>
<p><img src="1b0fe8e697f143da87ae575c721bfce7~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>有些时候，我们发现 hot reload 无法更新界面，可以使用 hot restart，如果 hot restart 还是无法更新界面，那就需要重新运行一下就可以了。此时我们发现 main() 函数里面就只有一句调用 runApp() 代码，在 Dart 语言中，函数定义如果只有一句代码，那么可以省略成如下箭头形式</p>
<p><img src="6622e630312b4d46a4570b12b32f55e4~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<h1 id="设置文字样式-style"><a href="#设置文字样式-style" class="headerlink" title="设置文字样式 style"></a>设置文字样式 style</h1><p>按住 command 再用鼠标左键点击 Text 类，就会跳到一个 text.dart 文件，会看到一个 this.style 属性，再次按住 command 点击，会来到 style 的声明部分：</p>
<p><img src="c20f3fc043974b2b956dbd6b28eebd80~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>这里的 final 表示不可变，常量的意思，类似于 Swift 里面的 let。可以看到 style 是一个 TextStyle 类型，查看 TextStyle 类，会发现里面很多的属性，比如 color，backgroundColor，fontSize，fontWeight…这些都是很熟悉的属性,接下来我们设置一下 hello flutter 的一些文字样式</p>
<p><img src="4d1565a3e89643599da97f6eb93f3f19~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>使用 Android Studio 快捷键 command + \ 查看界面</p>
<div align="center">
<img src="681e54bc6ba244e383e6c42c94dfdb10~tplv-k3u1fbpfcp-watermark.jpg">
</div>

<h1 id="Material-App"><a href="#Material-App" class="headerlink" title="Material App"></a>Material App</h1><p>在 flutter 提供的头文件 material.dart 中，提供了一个快速构建 APP 的类型 MaterialApp，我们可以使用它来快速构建一个 APP 的基础框架。<br></p>
<p>我们先新建一个App类来写我们的代码</p>
<p><img src="921de45df974425b96a8552edd7167ec~tplv-k3u1fbpfcp-watermark.png" alt="image.png"><br></p>
<p>然后我们在 App 的 build 方法中，返回一个 MaterialApp 类，如果 MaterialApp 不传入任何参数的话，运行后会发现APP整个屏幕变成红色，并且显示了一行文字，意思是出错了之类的，说明我们的 MaterialApp 应该是需要传入一个必要的参数的。</p>
<p><img src="abd8214222cc4924b43e1749ddceceae~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>没错就像我们 iOS 的 APP 同样需要一个 rootViewController 一样，MaterialApp 函数需要一个 home 参数，home 参数可以传一个 Widget 类，如果传入我们刚刚写的 CustomWidget 类，运行后发现有了一点不一样的地方</p>
<div align="center">
<img src="cbd25bca31084862b6aa3ce68862a221~tplv-k3u1fbpfcp-watermark.jpg">
</div>

<p>右上角有一个 debug 的图标，hello flutter 下面也出现了两条横线。</p>
<p>flutter 还提供了一个 Scaffold 的类，这个类翻译过来叫作脚手架，有点像是我们 iOS 中的一些基础控制器(比如 UITabBarController，UINavigationController)的封装。我们来使用一下这个类，这个 Scaffold 类有一个 appBar 的属性，这个属性就跟我们的 UINavigationController 的 UINavigationBar 一样，appBar 是一个 AppBar 类型，它的 title 属性可以传入一个 Widget，我们传入一个 Text 类试试看。Scaffold 类除了 appBar 属性，还有一个 body 属性表示的内容，把这个 body 设置为我们刚刚的 CustomWidget，看看是什么效果，代码如下：</p>
<p><img src="2ba07c4727cd42bcbeb8768167858493~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>APP上显示效果：</p>
<div align="center">
<img src="b0436c60496843b0bb0d3a20d7f0b96d~tplv-k3u1fbpfcp-watermark.jpg">
</div>

<p>这个时候，是不是发现像那么回事了</p>
<p>MaterialApp 还有一个 theme 的属性，这个属性用了配置 app 的主题，设置一下主题颜色代码如下：</p>
<p><img src="5f097b85ecd74b42ac0374d7276c94bb~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>APP上显示效果：</p>
<div align="center">
<img src="a72cec5174ba4c989c6fea7452e13aa6~tplv-k3u1fbpfcp-watermark.jpg">
</div>

<h1 id="初探-ListView"><a href="#初探-ListView" class="headerlink" title="初探 ListView"></a>初探 ListView</h1><p>在探索 ListView 之前，我们先把模型实现一下，我们这里展示的一组关于汽车的图片和名字，就定义一个 Car 类，我们新建一个 car 文件用来存放我们的模型代码，代码如下：</p>
<p><img src="6f71fd16e1b14a1fb632819077a9d0d6~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>再定义一个数组，用来存放一组汽车模型，我这里放了一组网络图片，你可以直接使用，也可以自己在网上找几张图片，填入模型数组中</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="built_in">List</span>&lt;Car&gt; cars = [</span><br><span class="line">  Car(</span><br><span class="line">    name: <span class="string">&#x27;保时捷918 Spyder&#x27;</span>,</span><br><span class="line">    imageUrl:</span><br><span class="line">    <span class="string">&#x27;https://upload-images.jianshu.io/upload_images/2990730-7d8be6ebc4c7c95b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#x27;</span>,</span><br><span class="line">  ),</span><br><span class="line">  Car(</span><br><span class="line">    name: <span class="string">&#x27;兰博基尼Aventador&#x27;</span>,</span><br><span class="line">    imageUrl:</span><br><span class="line">    <span class="string">&#x27;https://upload-images.jianshu.io/upload_images/2990730-e3bfd824f30afaac?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#x27;</span>,</span><br><span class="line">  ),</span><br><span class="line">  Car(</span><br><span class="line">    name: <span class="string">&#x27;法拉利Enzo&#x27;</span>,</span><br><span class="line">    imageUrl:</span><br><span class="line">    <span class="string">&#x27;https://upload-images.jianshu.io/upload_images/2990730-a1d64cf5da2d9d99?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#x27;</span>,</span><br><span class="line">  ),</span><br><span class="line">  Car(</span><br><span class="line">    name: <span class="string">&#x27;Zenvo ST1&#x27;</span>,</span><br><span class="line">    imageUrl:</span><br><span class="line">    <span class="string">&#x27;https://upload-images.jianshu.io/upload_images/2990730-bf883b46690f93ce?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#x27;</span>,</span><br><span class="line">  ),</span><br><span class="line">  Car(</span><br><span class="line">    name: <span class="string">&#x27;迈凯伦F1&#x27;</span>,</span><br><span class="line">    imageUrl:</span><br><span class="line">    <span class="string">&#x27;https://upload-images.jianshu.io/upload_images/2990730-5a7b5550a19b8342?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#x27;</span>,</span><br><span class="line">  ),</span><br><span class="line">  Car(</span><br><span class="line">    name: <span class="string">&#x27;萨林S7&#x27;</span>,</span><br><span class="line">    imageUrl:</span><br><span class="line">    <span class="string">&#x27;https://upload-images.jianshu.io/upload_images/2990730-2e128d18144ad5b8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#x27;</span>,</span><br><span class="line">  ),</span><br><span class="line">  Car(</span><br><span class="line">    name: <span class="string">&#x27;科尼赛克CCR&#x27;</span>,</span><br><span class="line">    imageUrl:</span><br><span class="line">    <span class="string">&#x27;https://upload-images.jianshu.io/upload_images/2990730-01ced8f6f95219ec?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#x27;</span>,</span><br><span class="line">  ),</span><br><span class="line">  Car(</span><br><span class="line">    name: <span class="string">&#x27;布加迪Chiron&#x27;</span>,</span><br><span class="line">    imageUrl:</span><br><span class="line">    <span class="string">&#x27;https://upload-images.jianshu.io/upload_images/2990730-7fc8359eb61adac0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#x27;</span>,</span><br><span class="line">  ),</span><br><span class="line">  Car(</span><br><span class="line">    name: <span class="string">&#x27;轩尼诗Venom GT&#x27;</span>,</span><br><span class="line">    imageUrl:</span><br><span class="line">    <span class="string">&#x27;https://upload-images.jianshu.io/upload_images/2990730-d332bf510d61bbc2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#x27;</span>,</span><br><span class="line">  ),</span><br><span class="line">  Car(</span><br><span class="line">    name: <span class="string">&#x27;西贝尔Tuatara&#x27;</span>,</span><br><span class="line">    imageUrl:</span><br><span class="line">    <span class="string">&#x27;https://upload-images.jianshu.io/upload_images/2990730-3dd9a70b25ae6bc9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#x27;</span>,</span><br><span class="line">  )</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>然后回到 main.dart 文件新建一个 Home 类，用来存放我们 ListView 相关代码,和 Xcode 一样 Android Studio 同样有代码块功能，直接输入 stl 就会出现提示，回车就会生成 StatelessWidget 类相关代码。我们将 Scaffold 相关的代码挪到 Home 中来。</p>
<p><img src="76d90981bd244df4b58afd63c041a279~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>接下来就是正式开始使用 ListView 了，ListView 跟其他一般的类不太一样，它的初始化需要调用 build 方法，并且传入两个参数，一个是 itemCount，一个是 itemBuilder，有点类似我们 UITableView 的 cellForRow 方法，只不过我们 UITableView 使用的是代理的设计，而这里的 ListView 使用的代码块回调的设计。</p>
<p>这里说一个 Android Studio 的比 Xcode 好用的地方，如图的 itemCount 使用了 cars.length 但是提示 cars 报错，是因为没有导入 car.dart 文件，给了个小红灯泡。这个时候，我们光标移动到 Car 类上，然后使用 option + 回车 会弹出一个菜单，再按一次回车就可以导入我们的 car.dart 文件了</p>
<p><img src="e624caad2d2d40a9a9699f96f04b43b0~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>itemBuilder 属性就是一个代码块，用来配置每个 item 的样式，我们可以先统一返回一个 Text 文本看看效果。</p>
<p><img src="b8a2cb6254db46db93612495dcfbde64~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>显示效果就是类似于 tableView 一样的一行行的文本</p>
<div align="center">
<img src="775d0ccc95184864bf9e70703aa7f3c4~tplv-k3u1fbpfcp-watermark.jpg">
</div>

<p>接下来介绍一个类似于 UIView 的容器类 Container，它跟 UIView 类似，可以设置一些颜色，间距，子控件之类的，我们来试一下，将 Text 改为 Container，child 属性就是子控件的意思，再给 child 设置为 Text，文本就是 cars 里面的 name，代码如下：</p>
<p><img src="98718e624fc1481fad5769b121af4fb5~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>再看一下显示效果</p>
<div align="center">
<img src="ce681f02eddb45d79b66ccdfa7e9c97c~tplv-k3u1fbpfcp-watermark.jpg">
</div>

<p>那么如果我们现在想要显示图片加文字的话应该怎么做呢？这里再介绍一个 Column 类,和前面介绍 Center 类类似，同样是属于布局的类，Column 表示上下的布局，因为我们想把图片和文字上下摆放，所以需要用到 Column 这个类。然后关于图片的显示，这里我们先不讲怎么去网络请求，而是直接使用 Image 类提供的一个方法去加载网络图片，代码如图：</p>
<p><img src="044d760fbdcf429795ed49a93628557f~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>显示效果如图：</p>
<div align="center">
<img src="abbc32c8ac5949178defa602be8aad6d~tplv-k3u1fbpfcp-watermark.jpg">
</div>

<p>这个时候，你应该也猜到了，如果挪动 children 里面 Text 和 Image 和顺序，会发现图片和文字的顺序就交换了，是不是很容易理解。如果想要调整图片和文字之间的间距怎么调呢，使用 SizedBox 类，传一个 height 就可以调整间距了，也可以继续使用 Container，代码如下：</p>
<p><img src="552a4140323044e8a58255513de3f513~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>如果觉得 itemBuilder 的代码太长，也可以将它的代码封装到一个方法里面，例如我这里使用 iOS 中的 _cellForRow 来命名这个方法。使用下划线的意义的是表示这是一个私有方法。</p>
<p><img src="9a121339036140b0bb7ca047ceebfe76~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>APP 右上角会发现有一个 debug 图标，这个图标的显示在 MaterialApp 类里面有一个属性可以控制显示隐藏。</p>
<p><code>debugShowCheckedModeBanner: false</code></p>
<h1 id="常用-Widget-介绍"><a href="#常用-Widget-介绍" class="headerlink" title="常用 Widget 介绍"></a>常用 Widget 介绍</h1><p>在介绍常用 Widget 之前，我们想把刚刚写的 ListView 相关代码，封装到一个文件内，这样方便以后我们回头学习。listView_demo 代码如下：</p>
<p><img src="446b4ffe8afc45e99221bf5cd3afeee1~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>这个时候，main.dart 文件内的 Home 类的 build 方法里，返回我们的 ListViewDemo 初始化方法就行了。</p>
<p>然后再新建一个新的 base_widget 文件，用来存放我们将要介绍的基础 Widget 代码。</p>
<p><img src="8f77023a8d4244d783be32abf79463cd~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>可以在 main.dart 文件中直接使用我的 BaseWidgetDemo 初始化方法，这样我们就不需要再去 main.dart 文件修改代码了。每介绍一个新 Widget 直接修改 BaseWidgetDemo 的 build 方法返回值为我们的自定义类 xxxDemo() 就好了</p>
<p><img src="76bc9786e7e84c9980e1ebee1a9b551b~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>第一个介绍是 Text</p>
<h2 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h2><p><img src="41880af972fc45689907bd150a538fa0~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>Text 我们一开始讲过了，这里就再讲一点关于字符串相关的，如果需要拼接字符串可以使用 $ 符号，如果字符串中有特殊符号，那就使用 ${}。其他 Text 常用的属性，跟我们 iOS 中都差不太多，需要注意的是 Text 的样式，是在 style 里面设置的。下面看一下 APP 显示的效果</p>
<div align="center">
<img src="d993b732bdd5495a88814dc8d3374742~tplv-k3u1fbpfcp-watermark.jpg">
</div>

<h2 id="RichText"><a href="#RichText" class="headerlink" title="RichText"></a>RichText</h2><p>RichText 就是富文本，它的 text 属性可以传一个 TextSpan 的类，这个 TextSpan 类可以设置 text 文本，设置 style 样式，还可以设置 children 子控件，这样就可以无限加花样拼接各种字符串在一起，代码如下</p>
<p><img src="b1945fbc5bbb43cba0faa548f46bd6ce~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>APP上显示的效果：</p>
<div align="center">
<img src="63e6b01de12b44449ce52f68f56b069d~tplv-k3u1fbpfcp-watermark.jpg">
</div>

<h2 id="Container，Row"><a href="#Container，Row" class="headerlink" title="Container，Row"></a>Container，Row</h2><p>Container 是个容器，Row 是个用于布局的类，跟 Column，Center 类似，根据代码查看一下 APP 的显示，就能大概明白意思了，代码如下：</p>
<p><img src="29e91abfa353405685dee33de2c27584~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>APP显示如下：</p>
<div align="center">
<img src="34a8ba5c9b5c446ab0dfc9ad49864494~tplv-k3u1fbpfcp-watermark.jpg">
</div>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>今天介绍了 Flutter 里面的许多的基础 Widget，有用于布局的 Center，Row，Column…有用于显示文本的 Text，RichText，TextSpan…有列表展示 ListView，有基础架构 Scaffold，MaterialApp 类，虽然东西有点多，但基本还没有什么难以理解的内容</p>
]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>8天让iOS开发者上手Flutter之七</title>
    <url>/2021/08/19/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%83/</url>
    <content><![CDATA[<p>上一篇文章我们已经完成首页聊天页面的导航条和列表展示，今天的任务是完成搜索 cell 的展示和点击之后的搜索页面的功能。</p>
<h1 id="自定义-SearchCell"><a href="#自定义-SearchCell" class="headerlink" title="自定义 SearchCell"></a>自定义 SearchCell</h1><h2 id="新建-search-cell-dart-文件"><a href="#新建-search-cell-dart-文件" class="headerlink" title="新建 search_cell.dart 文件"></a>新建 search_cell.dart 文件</h2><p><img src="1dbd72608e914624a9d4585ad1097307~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<h2 id="实现-SearchCell-代码"><a href="#实现-SearchCell-代码" class="headerlink" title="实现 SearchCell 代码"></a>实现 SearchCell 代码</h2><p>SearchCell 的话，因为仅仅只是展示，点击之后就进入搜索页了，应该来说是不需要状态的，所以用一个 StatelessWidget 就够了。然后布局的方式使用一个 Container 包含一个 Row，Row 里面包一个图片和文本就可以了。布局的方式其实多种多样，能实现就好了。完整代码如下：</p>
<p><img src="d0128b2c771c49c59ef63ecd63e85895~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>一个有意思的地方是，flutter 里面的 Image 居然可以设置颜色，而且颜色是设置给图片的。比如我的放大镜图片原本是黑色的，设置红色之后，居然真的变红色了！！！</p>
<div align="center">
<img src="7c322f9a1989444792c8be1a83af7e8e~tplv-k3u1fbpfcp-watermark.png">
</div>

<h2 id="使用-SearchCell"><a href="#使用-SearchCell" class="headerlink" title="使用 SearchCell"></a>使用 SearchCell</h2><p>SearchCell 的展示就算写完了，然后在 ChatPage.dart 中使用，我们把 ListView 的 itemBuilder 方法抽取出来，然后因为我们多加了一个 SearchCell，所以 itemCount 需要加 1，然后取 _chatList 数据的时候也要处理一下下标。</p>
<p><img src="17291ce793da406ba1a0877a2350c65e~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<h1 id="自定义-SearchPage"><a href="#自定义-SearchPage" class="headerlink" title="自定义 SearchPage"></a>自定义 SearchPage</h1><h2 id="新建-search-page-dart-文件"><a href="#新建-search-page-dart-文件" class="headerlink" title="新建 search_page.dart 文件"></a>新建 search_page.dart 文件</h2><p><img src="0699384aaddf495185d41f9dfbfb4d63~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<h2 id="简单实现-SearchPage"><a href="#简单实现-SearchPage" class="headerlink" title="简单实现 SearchPage"></a>简单实现 SearchPage</h2><p>SearchPage 作为一个页面，使用 StatelessWidget 肯定是无法胜任的，所以使用一个 StatefulWidget。而由于 AppBar 的样式和我们需要显示的效果图还是有差别的，所以这里我们不使用 Scaffold 提供的 AppBar 了。我们自定义一个 SearchBar，配合一个 ListView 来搭建基本的布局。这里面基本没有新鲜的东西，就简单贴一下代码：</p>
<p><img src="2a65878c91ef4795a80cde4b9100e7ac~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>SearchBar 由于是在 SearchPage 中使用的，所以就直接定义在 SearchPage 中了，代码也是先简单定义如下：</p>
<p><img src="e6ae11c406504b5f8f1e8386d60fc9ad~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<h2 id="点击跳转到-SearchPage"><a href="#点击跳转到-SearchPage" class="headerlink" title="点击跳转到 SearchPage"></a>点击跳转到 SearchPage</h2><p><img src="f9239dbba4a8422a88b545ade852133e~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>在搜索 cell 里面实现点击方法，然后跳转到 SearchPage，显示效果如图：</p>
<div align="center">
<img src="e5054ecb6ba147d7a3adc6f76e71bc47~tplv-k3u1fbpfcp-watermark.png">
</div>

<h1 id="实现-SearchBar"><a href="#实现-SearchBar" class="headerlink" title="实现 SearchBar"></a>实现 SearchBar</h1><h2 id="SearchBar-的布局"><a href="#SearchBar-的布局" class="headerlink" title="SearchBar 的布局"></a>SearchBar 的布局</h2><p>SearchBar 的布局，最外层分为上下两个部分，上面的部分是系统状态栏的高度。下面的部分就是显示搜索条的高度。而搜索条的布局，使用 Row 分隔为左右两个部分，左侧包含放大镜，文本输入框和删除图片。右侧就是一个返回上级页面的取消。这里主要提一下 flutter 中的文本框，跟 iOS 中 UITextField 真的很不一样，UITextField 中左侧的图标，右侧的删除，都是封装在内部的。而在 flutter 中，文本框 TextField 真的就只有文本框，没有其他的东西，都需要自己添加。完整代码如下：</p>
<p><img src="0dbc3f3f2239405ca84199dc0fda9801~tplv-k3u1fbpfcp-watermark.png" alt="Snip20210818_60.png"></p>
<h2 id="SearchBar-事件处理"><a href="#SearchBar-事件处理" class="headerlink" title="SearchBar 事件处理"></a>SearchBar 事件处理</h2><h3 id="取消的处理"><a href="#取消的处理" class="headerlink" title="取消的处理"></a>取消的处理</h3><p>点击取消需要 pop 到上一个界面，给取消加一个 <code>GestureDetector</code> 实现 <code>onTap</code> 就好了。代码如下：</p>
<p><img src="386cd9fc654946959405e1090597a1ee~tplv-k3u1fbpfcp-watermark.png" alt="Snip20210818_61.png"></p>
<h3 id="清除按钮功能实现"><a href="#清除按钮功能实现" class="headerlink" title="清除按钮功能实现"></a>清除按钮功能实现</h3><p>未输入文本的时候，不显示清除按钮。有输入文本的时候，显示清除按钮。点击清除按钮，清空文本内容并隐藏清除按钮。</p>
<p>使用一个bool值 <code>_showClear</code> 控制清除按钮的显示隐藏。代码如下：</p>
<p><img src="9a5423cd5b0146b19169fbb6bbf12236~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>在文本变化的时候，修改 <code>_showClear</code> 值并刷新状态。文本的变化在TextField的 <code>onChanged</code> 属性就可以监听到。代码如下：</p>
<p><img src="053efa2bbde9460f976cfe5e7ba63d83~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>最后就是清除按钮的点击功能，由于需要清空 TextField 的文本内容，需要使用到 <code>TextEditingController</code>,给 TextField 的 <code>controller</code> 属性赋值，然后通过 <code>TextEditingController</code> 对象清除文本内容。文本清除之后并不会自动调用系统的 <code>onChanged</code> 方法，自己手动调用一下就好了。代码如下：</p>
<p><img src="b08d5ad674544fd3b52cb4cd86366783~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<h3 id="SearchBar-回调文本框的内容"><a href="#SearchBar-回调文本框的内容" class="headerlink" title="SearchBar 回调文本框的内容"></a>SearchBar 回调文本框的内容</h3><p>文本框的内容变化的时候，需要回调给 SearchBar 外部，这样我们才能在 SearchPage 页面进行搜索内容。使用一个回调作为参数就可以实现了。代码如下：</p>
<p><img src="762fd4c2b23444caa7f44d23dc3641d9~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p><code>onChanged</code> 是一个闭包属性，在初始化 SearchBar 的时候传入，在 TextField 的文本变化的时候调用闭包，并将文本作为参数回传给 SearchBar 外部。因为将 <code>onChanged</code> 作为了必传参数，所以编译器自然会在用到了 SearchBar 的地方报错。很容易找到报错的地方，加个参数就好了。</p>
<p><img src="6481817bd4544a138bbeaf10b3c80c54~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>SearchBar 相关的代码就算差不多完成了，其实可以将 SearchBar 单独作为一个文件独立出来。接下来就是处理 SearchPage 了</p>
<h1 id="实现-SearchPage"><a href="#实现-SearchPage" class="headerlink" title="实现 SearchPage"></a>实现 SearchPage</h1><p>搜索页面的搜索功能，往细了说，可以搜索很多内容，我们这里只是简单的搜索名字，只要名字包含输入的内容，就将搜索结果展示出来。由于这里对中文名进行搜索的时候，能匹配到的数据比较少，所以这里已经将网络请求返回的名字由中文改为英文名字了。前面展示中文名字的截图就不做修改了。</p>
<h2 id="SearchPage-的搜索功能"><a href="#SearchPage-的搜索功能" class="headerlink" title="SearchPage 的搜索功能"></a>SearchPage 的搜索功能</h2><h3 id="添加-datas-数据源"><a href="#添加-datas-数据源" class="headerlink" title="添加 datas 数据源"></a>添加 <code>datas</code> 数据源</h3><p>要实现 SearchPage 的搜索功能，那么它首先必须要有数据源，很明显它的数据源是从首页来的。先定义一个 <code>datas</code>,作为必传参数，然后通过外部层层传递过来。</p>
<p><img src="700b1121913846efb7e15edd66ee4613~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p><code>datas</code> 定义好了以后，报红色错误的地方，就是需要传参数的地方，很方便，都不用我们自己去翻哪里需要加参数了。发现 SearchCell 里面需要传入数据源，同样的方式，在 SearchCell 里面定义 <code>datas</code>,然后在报错的地方处理。</p>
<p><img src="15a0335618d648deb35dfa08cff589b9~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>就这样子顺藤摸瓜，直到来到 chat_page 将数据源传入就完成了</p>
<p><img src="9dd3a5666ded4f8393fed63621b903d1~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<h3 id="SearchPage-自己的数据源"><a href="#SearchPage-自己的数据源" class="headerlink" title="SearchPage 自己的数据源"></a>SearchPage 自己的数据源</h3><p>SearchPage 需要展示搜索之后的结果，所以自己定义一个数组用来存放搜索的结果。并且暂时先使用 Text 做一个最简单的展示。代码如下：</p>
<p><img src="8e81c3d13e6547c4bc7bb8a5d021bac5~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<h3 id="实现搜索功能并展示数据"><a href="#实现搜索功能并展示数据" class="headerlink" title="实现搜索功能并展示数据"></a>实现搜索功能并展示数据</h3><p>搜索的功能实现很简单，就是判断数据源里面的名字是否包含输入的文本，如果包含就全部添加并展示。<br>代码如下：</p>
<p><img src="9bd07dfcbf5247609d3b28d3780fec6c~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>APP 上如图，我输入 son，显示结果：</p>
<div align="center">
<img src="3332ccab3c12452fb12016e1508f6d5a~tplv-k3u1fbpfcp-watermark.png">
</div>

<h2 id="SearchPage-的搜索结果列表展示"><a href="#SearchPage-的搜索结果列表展示" class="headerlink" title="SearchPage 的搜索结果列表展示"></a>SearchPage 的搜索结果列表展示</h2><p>SearchPage 的搜索结果列表展示的数据样式，应该和首页是类似的。所以可以直接使用首页的布局。代码如下：</p>
<p><img src="3118496d7dd94eae9cb516dd92e86ef0~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<h2 id="SearchPage-高亮显示搜到的结果"><a href="#SearchPage-高亮显示搜到的结果" class="headerlink" title="SearchPage 高亮显示搜到的结果"></a>SearchPage 高亮显示搜到的结果</h2><p>这里的思路是，高亮显示搜到的结果，那么普通的文本肯定是不行了，必须是富文本。如何找到搜索的关键字在文本中的位置呢，这个不用我们考虑了。flutter 中对字符串有一个分隔方法 <code>split</code>,这个方法跟 iOS 中的字符串的 <code>componentsSeparatedByString:</code> 方法类似，根据传入的参数来分隔字符串。这里贴一下 iOS 的代码：</p>
<p><img src="c991926b90ac4a6490d95ad1bc0889e2~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>（还是Xcode看着顺眼啊）我们将字符串 <code>abcaa</code> 以字符 <code>a</code> 分组，再将分组的结果拼接回原来的字符串。为什么要这么操作？因为重新拼接新字符串的时候，我们就可以处理富文本字符串了。现在回到 flutter 中来，flutter 中拼接的富文本的方式太方便了，RichText 花样拼接 TextSpan 这个我们在前面也讲过了。</p>
<p><img src="7bd6ae46acf344e48435c1dfa80dc50f~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p><code>_searchKey</code> 就是我们输入的文本，在 SearchPage 中声明属性，在 SearchBar 的回调中赋值就好了。</p>
<p><img src="be6eb80c9ad24db5897308c568863416~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p><img src="6723d425c75249d488bc3b8d31f9e345~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>现在测试一下，输入 son，APP 显示如图：</p>
<div align="center">
<img src="20dad78f11364579aae756585e776407~tplv-k3u1fbpfcp-watermark.png">
</div>

<h2 id="滚动列表叫回键盘"><a href="#滚动列表叫回键盘" class="headerlink" title="滚动列表叫回键盘"></a>滚动列表叫回键盘</h2><p>ListView 的滚动，我们在前面已经说过一次，需要将 ListView 包在 <code>NotificationListener</code> 里面。然后叫回键盘的代码 <code>FocusScope.of(context).requestFocus(FocusNode());</code> 这个记住就好了，代码如下：</p>
<p><img src="d33048a50ec0451983defba0221a6547~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到这里我们的 flutter 仿微信 Demo 功能就差不多完了，还剩最后一篇就是介绍 flutter 和原生混合开发的一些东西。这个也是实际项目中应该经常会遇到的情况。其实写到这里会发现很多东西和原生都是相通的或者类似的。除了新的语言 Dart 不是很熟悉之外，其他很多地方比如很多属性的名字，颜色，闭包，都能够看到原生的影子。flutter 创造者们也不会闭门造车，都会去借鉴原生里面的东西。</p>
]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>8天让iOS开发者上手Flutter之三</title>
    <url>/2021/07/22/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%B8%89/</url>
    <content><![CDATA[<h1 id="搭建项目主框架"><a href="#搭建项目主框架" class="headerlink" title="搭建项目主框架"></a>搭建项目主框架</h1><h2 id="新建微信聊天，通讯录，发现，我的四个文件"><a href="#新建微信聊天，通讯录，发现，我的四个文件" class="headerlink" title="新建微信聊天，通讯录，发现，我的四个文件"></a>新建微信聊天，通讯录，发现，我的四个文件</h2><p>上一篇文章最后我们已经将 APP 的 TabBar 和四个对应的子视图搭建好了，但是每一个子视图里面肯定会有大量的代码，全部放到 rootPage 文件里面肯定是不合理的。所以我们为每个子视图创建单独的文件，并将代码分散到每个文件中。</p>
<p><img src="c5a720ed438344788169ab80fb409938~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>比如聊天页面，返回自己的 Scaffold：</p>
<p><img src="618e714770d24d4facaee7b437ac7fc8~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>现在我们点击切换一下 tabBar 的 item，发现会有一些高亮的颜色，以及一个水波纹效果，这些都是 MaterialApp 类的 theme 提供的。如果想去掉这些效果，要来到 main.dart 文件，设置以下两个属性：</p>
<p><img src="b1260254db7f4ab686c8c79d65a0382b~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>仔细查看点击 item 的时候，文字被放大了。这个是 bottomNavigationBar 的属性 <code>selectedFontSize</code> 决定的，将它设置为 12.0 之后，就不会变大了，在 rootPage.dart 文件里面：</p>
<p><img src="9717b7c335fa4065ab4e4fc9e20bfd48~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<h1 id="本地资源文件"><a href="#本地资源文件" class="headerlink" title="本地资源文件"></a>本地资源文件</h1><h2 id="配置-Android-的启动图和应用图标"><a href="#配置-Android-的启动图和应用图标" class="headerlink" title="配置 Android 的启动图和应用图标"></a>配置 Android 的启动图和应用图标</h2><p>Android 和 iOS 的资源文件，比如 APP 的图标，启动图，需要到相应的项目文件里面去配置。我们大家都是 iOS 开发者了，这里就只说一下 Android 的图标和启动图如何配置。有需要图片资源的同学可以前往 <a href="https://github.com/masterKing/wechatDemo">下载</a></p>
<p><img src="77f7870a53b74d518e85e699e8907c46~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>在安卓模拟器上运行起来之后，会发现安卓的标题不是在中间</p>
<p><img src="89e269268c514376849e3342fcdee59d~tplv-k3u1fbpfcp-watermark.png" alt="Screenshot_1626706998.png"></p>
<p>这里可以通过 AppBar 的一个属性，来调整让它变成中间显示</p>
<p><img src="2d6097f5de8b4cbd841253298032542a~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<h2 id="配置公共的资源"><a href="#配置公共的资源" class="headerlink" title="配置公共的资源"></a>配置公共的资源</h2><p>如果是两端都需要的资源，比如我们 APP 的微信，通讯录，发现和我的图标。需要在当前 flutter 项目中配置了。</p>
<p><img src="5ff5a0d3eacd4063a2b0cca656e65d89~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>pubspec.yaml 文件是我们 flutter 项目的配置文件。文件内 assets 和下面的几行表示需要的图片路径，可以在 flutter 项目的根目录下创建一个 images 的目录，里面存放所有当前 flutter 需要用的图片。然后还需要手动导入一张一张图片…这点就比较恶心人了…更恶心人的是，这个 yaml 文件的格式，包括位置都不能错，比如刚刚放开注释的时候，如果你使用的是 command + &#x2F; 快捷键，那么你就得好好挪动下位置了，位置不对编译不通过。</p>
<p><img src="5a076f973f1641b7a93f4a03fbf8d67c~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<h1 id="实现发现页"><a href="#实现发现页" class="headerlink" title="实现发现页"></a>实现发现页</h1><div align="center">
<img src="6c5ef89f17244d2c8d2403d8bf74e9c5~tplv-k3u1fbpfcp-watermark.png">
</div>

<h2 id="设置APP启动默认展示发现页面"><a href="#设置APP启动默认展示发现页面" class="headerlink" title="设置APP启动默认展示发现页面"></a>设置APP启动默认展示发现页面</h2><p>这个方便我们开发调试这个发现页面，我们开发原生 APP 的时候也经常会这么干。直接将 rootPage.dart 里的 _currentIndex 设置为 2 就 OK 了，这个不用多说</p>
<p><img src="60a72f30b2d148278ab955c188675989~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<h2 id="配置导航条"><a href="#配置导航条" class="headerlink" title="配置导航条"></a>配置导航条</h2><p>微信的导航条颜色是灰色的。然后在安卓上这个导航条标题默认在左侧，这里也需要设置一下在中间。然后标题的颜色也不是白色，改为黑色。然后导航条和下面的 body 有一条黑线，可以通过设置 <code>elevation</code> 的值来控制。</p>
<p><img src="7baba8c474044957b85468f0542ea7fd~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<div align="center">
<img src="84d5ab21e4944283bdcd5087c173c1b1~tplv-k3u1fbpfcp-watermark.png">
</div>

<h2 id="自定义发现-cell"><a href="#自定义发现-cell" class="headerlink" title="自定义发现 cell"></a>自定义发现 cell</h2><p>新建一个 pages 文件，将所有页面文件都放到里面。然后在新建一个 discover_cell 准备实现自定义的 cell。按道理来说一个 cell 应该是需要更新UI的所以应该是有状态的，但是现在我们是练手过程，可以先用一个无状态的 cell。 </p>
<p><img src="e86442ff86fa425dacb5e072a958928a~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>接下来就是实现这个自定义 cell（discover_cell）的代码了；首先观察微信的发现页的 cell，左侧有一个图标，和一个标题，这两个是必须要有的，不然无法构成一个完整的 cell，然后是右侧有些 cell 会有子图标和子标题，还有一个右箭头，这个是每个 cell 都存在的。根据以上这些信息，我们就可以定义出 discover_cell 应该要有的一些属性了。如下：<br></p>
<ul>
<li><code>title</code> 左侧的标题，必传参数<br></li>
<li><code>imageName</code> 左侧的图标，必传参数<br></li>
<li><code>subTitle</code> 右侧的标题，非必传参数，也叫可选参数<br></li>
<li><code>subImageName</code> 右侧的图标，可选参数<br></li>
</ul>
<p><img src="343b247159da4bf79641790d5aaf811c~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>如图所示，声明了这四个属性之后，给出了红色的报错，可以将光标移到报错的红色字母任意处，按住 option + 回车 就可以弹出右侧的选择菜单，第一个选项应该是新版本加的，俺也不是很清楚如何使用，网上资料很少，推荐去查询官方文档了。我这里就懒的去查了，因为我们要选择的是第二个选线 <code>Create constructor for final fields</code> 创建构造方法。细心的同学会发现 <code>subTitle</code>,<code>subImageName</code> 的类型是 <code>String?</code> 这个类型后面跟了个问号，就是代表可选参数的意思，这里跟 iOS 的 Swift 倒是十分相似。</p>
<p>选择创建构造方法之后，系统会自动生成一行代码，但是这一行代码很长而且它不换行，非常难看。这里有个小技巧，在生成的代码最后一个属性后面加上一个,号然后再按 option + command + L 重新格式化代码，就会自动换行了。</p>
<p><img src="6dea5bcdc29e496f8e4eb2bdbbe2b486~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>换行之后发现，两个必传参数报错，还是老办法，光标移动到报错的地方，按住 option + 回车 就会给出提示，意思我们要给必传参数加上 <code>required</code> 关键字。这样属性的定义就算完成了。</p>
<p><img src="8bf3d583b85e4553a2d146bd9d887562~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>属性定义完了之后就是实现 build 方法搭建界面了。布局界面的方式有很多，可以使用 Row 来布局，也可以使用 Stack 加 Positioned 布局，不管什么方式能实现界面效果都可以。我这使用 Row 布局。代码如下：</p>
<p><img src="7792f9602b8c415da1cc7a104894d2bc~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>最外层使用一个 Container 包装一个 Row，然后 Row 里面再包含两个 Container 包着的 Row 分别代表左右两边子视图。这样看上去应该还算蛮清晰明了的。左侧部分的图标和标题是必传参数，没啥好说的。</p>
<p>右侧由于子标题和子图标都不一定存在，所以需要做一些处理，Text 控件如果没有子标题可以显示空字符串‘’，这个比较好解决。而子图标不能说给一张空图片，所以需要根据 subImageName 是否为空来显示不同的控件，如果有就显示 Image，如果没有就显示一个 Container 占位。最右侧的箭头图标是每个 cell 都存在的就没啥好说的了。自定义 discover_cell 的代码就算完成了，下一步完善我们的发现页面</p>
<h2 id="完善发现页面"><a href="#完善发现页面" class="headerlink" title="完善发现页面"></a>完善发现页面</h2><p>cell 写好之后，完善发现页面就简单多了。这里使用最简单的方式来实现，就是直接拼接每个子 cell 的方式。</p>
<p><img src="bb9c501966b64ea89b16224243716420~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>flutter 里面的 ListView 并不像 iOS 中的 UITableView 那样分组和行。ListView 只有行，自行合并几个行组成一组，组与组之间使用一个 SizedBox 隔开，行与行之间使用 Row(因为分割线左侧是白色的，右侧是灰色的，所以需要组合两个 Container)隔开。</p>
<p>其中购物哪一行 cell 右侧的子标题和子图标没有设置字体大小和图标大小，所以显示可能会有点问题，回到 cell 里面设置一下就好了。</p>
<p><img src="e792b6ca4c2a476eae4ebed34f16b6d4~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<h1 id="实现点击cell切换到新页面"><a href="#实现点击cell切换到新页面" class="headerlink" title="实现点击cell切换到新页面"></a>实现点击cell切换到新页面</h1><h2 id="让cell能够响应点击事件GestureDetector"><a href="#让cell能够响应点击事件GestureDetector" class="headerlink" title="让cell能够响应点击事件GestureDetector"></a>让cell能够响应点击事件<code>GestureDetector</code></h2><p>flutter 提供了一个 <code>GestureDetector</code> 类用来检测手势，它有一个 child 属性，可以放我们的UI代码。它还能响应各种手势，在不同的属性里面处理，比如我们点击 cell 就是 onTap 属性。除了 onTap 之外，还有 onTapDown,onTapCancel。其中 onTapCancel 是触摸之后离开了，onTapDown 是按下就会被调用，onTap 按下去并松开之后调用。实现如下代码之后，自己试试就能明白其中差别了。</p>
<p><img src="b507b1093e6a4361a9e8f14e840b3b1f~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<h2 id="实现页面之间跳转"><a href="#实现页面之间跳转" class="headerlink" title="实现页面之间跳转"></a>实现页面之间跳转</h2><p>点击发现 cell 之后，需要跳转它对应的详情页面，就需要一个详情页。可以新建一个 discover_child_page.dart 文件，再去补充里面的页面代码。也可以从现有的一些空白文件中复制一份，比如 mine_page.dart 文件，它里面就只有基本的我的页面代码,只需少量修改代码就可以使用。不论使用哪种方式，新建 discover_child_page.dart 完成后，页面代码如下：</p>
<p><img src="5bcbe870debf4fc39d84a72d6c47f429~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>这个详情页的一些属性，应该是需要从外面传入的，比如 title。于是定义一个 title属性。</p>
<p><img src="433df2447dad40ff9866d7847f57e1e0~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>然后在当前页面展示我们的 title，之前都是在 StatelessWidget 里面使用我们的属性，那在 StatefulWidget 里面我们怎么使用属性呢？属性前面加上 widget.</p>
<p><img src="39f5610e04f049959d75933a5ed05ea2~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>到这里发现详情页就算差不多完成了。</p>
<p>回到 cell 里面的点击方法，实现点击跳转。这里和 iOS 有点类似的地方就是同样是使用一个导航控制器类。flutter 也是使用一个名字叫导航的类 <code>Navigator</code>。调用以下方法。</p>
<figure class="highlight plaintext"><figcaption><span>dart</span></figcaption><table><tr><td class="code"><pre><span class="line">Navigator.of(context).push(）</span><br></pre></td></tr></table></figure>

<p>push() 的参数需要一个 Route 类型，这里使用 <code>MaterialPageRoute</code> 类，<code>MaterialPageRoute</code> 的构造方法返回一个 Widget，这个返回的 Widget 就是我们需要跳转到的页面。代码如下：</p>
<p><img src="4986f78b3e6a42919b2ef7b3cd75e947~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>前面讲过的，在 flutter 中，如果函数体的代码只有一句的话，可以使用 &#x3D;&gt; 的形式，于是上面可以简写成这样：</p>
<p><img src="1ad80766d4c4410db13e6dbc1be75f97~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<h1 id="实现有状态的-discover-cell"><a href="#实现有状态的-discover-cell" class="headerlink" title="实现有状态的 discover_cell"></a>实现有状态的 discover_cell</h1><h2 id="修改-discover-cell-为-StatefulWidget"><a href="#修改-discover-cell-为-StatefulWidget" class="headerlink" title="修改 discover_cell 为 StatefulWidget"></a>修改 discover_cell 为 StatefulWidget</h2><p>原生的微信 APP 在点击 cell 的时候，会有一个灰色的背景，在松开的时候会变回最初的颜色。现在来实现这个效果。所以我们的 discover_cell 需要从 StatelessWidget 改为 StatefulWidget。先将 build 方法缩起来，快捷键 command 加 - 号，0 右边那个减号。</p>
<p><img src="9f0eaa6f32594407a3b329b56d8bd12b~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>然后先将 bulid 方法覆盖，再将属性和构造方法覆盖。最后删除原有的 StatelessWidget 类。这时候 build 方法里面会爆一个错误，原因是<code>_DiscoverCellState</code> 类里面拿不到 <code>DiscoverCell</code> 的属性，所以我们在属性前面加上 <code>widget.</code> 就好了。</p>
<h2 id="实现点击变灰需求"><a href="#实现点击变灰需求" class="headerlink" title="实现点击变灰需求"></a>实现点击变灰需求</h2><p>我们前面说过了 onTap 方法，onTapDown 方法，onTapCancel 方法的调用时机。实现这个需求就在这三个方法里面更新状态就好了。代码如下：</p>
<p><img src="989f099de0f342a99860d199f4c16330~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>8天让iOS开发者上手Flutter之二</title>
    <url>/2021/07/19/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%BA%8C/</url>
    <content><![CDATA[<h1 id="Flutter布局"><a href="#Flutter布局" class="headerlink" title="Flutter布局"></a>Flutter布局</h1><h2 id="Alignment"><a href="#Alignment" class="headerlink" title="Alignment"></a>Alignment</h2><p>Container 类里有一个 alignment 属性，翻译过来应该叫对齐方式，这个属性用来控制 Container 的子控件相对于它自身的一个位置。在我们 iOS 开发中，我们知道坐标系的原点是在左上角。</p>
<p>而在 flutter 中，坐标系的原点在父控件的正中心，可以使用这个 alignment 属性来控制子控件在父控件中的位置，它有两个参数分别是 double 类型的 x,y。取值是 -1 到 1，</p>
<ul>
<li>当 (0, 0) 的时候表示子控件在父控件的正中心，当 (1, 0) 的时候，表示子控件位于 x 方向上的最右侧，y 方向上居中；</li>
<li>当 (-1, -1) 的时候，表示子控件位于父控件的左上角位置。有点类似于 CALayer 的 anchorPoint 属性。</li>
</ul>
<p>如图代码如下：</p>
<p><img src="658c0a6e27534e0eaa7531960f6f83a1~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<div align="center">
<img src="3af95f906929441e9e113e235402ca11~tplv-k3u1fbpfcp-watermark.png">
</div>

<h2 id="Row"><a href="#Row" class="headerlink" title="Row"></a>Row</h2><p>Row 表示水平布局，它有一个 children 属性，用来存放它的子控件。代码如下：</p>
<p><img src="09c67fe367fc4a86889cbc07b8f12d85~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<div align="center">
<img src="c8dac668c50045eeb4b89237aa430f0c~tplv-k3u1fbpfcp-watermark.png">
</div>

<p>其中 Icon 类是 flutter 提供的一个快速创建一些常用图标的类。如果想给每个 Icon 都加一个背景色，直接设置 Icon 的 color 是不行的，这样修改的是图标的颜色而不是背景色，给 Icon 包一层 Container 容器，然后再设置 Container 颜色这样就可以实现了。</p>
<p>最开始我们尝试了 alignment 属性的作用，当它是 (0，0) 的时候，Text 的位置默认是在屏幕中央的。为什么这里换成我们的 Row 之后，Row 的子控件位置不在屏幕中央呢？</p>
<h3 id="mainAxisAlignment"><a href="#mainAxisAlignment" class="headerlink" title="mainAxisAlignment"></a>mainAxisAlignment</h3><p>Row 和 Column 都有一个 mainAxisAlignment 属性，叫作主轴对齐方式，默认是 MainAxisAlignment.start 意思沿着主轴方向开始，Row 布局下就是从左至右，Column 布局下就是从上至下。<br></p>
<ul>
<li><code>MainAxisAlignment.spaceAround</code>:将剩下的空间平均分配<br></li>
<li><code>MainAxisAlignment.spaceBetween</code>:将剩下的空间分配到子控件之间<br></li>
<li><code>MainAxisAlignment.spaceEvenly</code>:等间距分配子控件</li>
</ul>
<h3 id="crossAxisAlignment"><a href="#crossAxisAlignment" class="headerlink" title="crossAxisAlignment"></a>crossAxisAlignment</h3><p>交叉轴对齐方式。start，end，center 这几种方式试一下很好理解，stretch 会将子控件拉伸。而 baseline 用的比较少,单独使用它会报错，需要和 Text 文本结合，还需要配合 <code>textBaseline</code> 属性一起使用。如下图所示，如果不设置 <code>CrossAxisAlignment.baseline</code> 和 <code>TextBaseline.alphabetic</code> 就会根据控件高度水平对齐，而如果设置了就会根据控件内文本的基线对齐。<br></p>
<p><img src="52e87b0a49674f1e85560f4c3a54df0f~tplv-k3u1fbpfcp-watermark.png" alt="Snip20210713_177.png"></p>
<p><img src="dddb21324b744ad1a71de8a98862f0f5~tplv-k3u1fbpfcp-watermark.png" alt="Snip20210713_178.png"></p>
<h2 id="Column"><a href="#Column" class="headerlink" title="Column"></a>Column</h2><p>这个和 Row 是对应的，Row 是水平布局，这个 Column 是垂直布局</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LayoutDemo</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> LayoutDemo(&#123;Key? key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      color: Colors.green,</span><br><span class="line">      alignment: Alignment(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">      child: Column(</span><br><span class="line">        children: [</span><br><span class="line">          Container(</span><br><span class="line">            child: Icon(Icons.add, size: <span class="number">180</span>,),</span><br><span class="line">            color: Colors.red,</span><br><span class="line">          ),</span><br><span class="line">          Container(</span><br><span class="line">            child: Icon(Icons.ac_unit, size: <span class="number">120</span>,),</span><br><span class="line">            color: Colors.yellow,</span><br><span class="line">          ),</span><br><span class="line">          Container(</span><br><span class="line">            child: Icon(Icons.access_alarm, size: <span class="number">60</span>,),</span><br><span class="line">            color: Colors.blue,</span><br><span class="line">          ),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显示效果如图：</p>
<div align="center">
<img src="f43e891ecf234671ad18336db379a204~tplv-k3u1fbpfcp-watermark.png">
</div>


<h3 id="mainAxisAlignment-1"><a href="#mainAxisAlignment-1" class="headerlink" title="mainAxisAlignment"></a>mainAxisAlignment</h3><p>这个跟 Row 类似</p>
<h3 id="crossAxisAlignment-1"><a href="#crossAxisAlignment-1" class="headerlink" title="crossAxisAlignment"></a>crossAxisAlignment</h3><p>这个跟 Row 类似</p>
<h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><p>这个是用在 Z 轴上的布局的，row 是 X 轴，column 是 Y 轴。children 数组第一个放在最底部，最后一个放在上面，离用户最近的地方。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LayoutDemo</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> LayoutDemo(&#123;Key? key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      color: Colors.green,</span><br><span class="line">      alignment: Alignment(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">      child: Stack(</span><br><span class="line">        children: [</span><br><span class="line">          Container(</span><br><span class="line">            child: Icon(Icons.add, size: <span class="number">180</span>,),</span><br><span class="line">            color: Colors.red,</span><br><span class="line">          ),</span><br><span class="line">          Container(</span><br><span class="line">            child: Icon(Icons.ac_unit, size: <span class="number">120</span>,),</span><br><span class="line">            color: Colors.yellow,</span><br><span class="line">          ),</span><br><span class="line">          Container(</span><br><span class="line">            child: Icon(Icons.access_alarm, size: <span class="number">60</span>,),</span><br><span class="line">            color: Colors.blue,</span><br><span class="line">          ),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>APP显示效果：</p>
<div align="center">
<img src="29eabf4666e94592b92fe8f7599821df~tplv-k3u1fbpfcp-watermark.png">
</div> 

<h3 id="alignment"><a href="#alignment" class="headerlink" title="alignment"></a>alignment</h3><p>Stack 里有一个 alignment 属性，它用来控制所有子控件相对于最大那个子控件的位置</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackDemo</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> StackDemo(&#123;Key? key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Stack(</span><br><span class="line">      alignment: Alignment.bottomRight,</span><br><span class="line">      children: [</span><br><span class="line">        Container(</span><br><span class="line">          child: Icon(Icons.add, size: <span class="number">180</span>,),</span><br><span class="line">          color: Colors.red,</span><br><span class="line">        ),</span><br><span class="line">        Container(</span><br><span class="line">          child: Icon(Icons.ac_unit, size: <span class="number">120</span>,),</span><br><span class="line">          color: Colors.yellow,</span><br><span class="line">        ),</span><br><span class="line">        Container(</span><br><span class="line">          child: Icon(Icons.access_alarm, size: <span class="number">60</span>,),</span><br><span class="line">          color: Colors.blue,</span><br><span class="line">        ),</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div align="center">
<img src="3ec51da73a554b3c877297e6927d434a~tplv-k3u1fbpfcp-watermark.png">
</div> 

<h3 id="Positioned"><a href="#Positioned" class="headerlink" title="Positioned"></a>Positioned</h3><p>Stack 里配合 Positioned 类使用的话，跟我们 iOS 的约束有点类似了，可以设置上，左间距之类的</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackDemo</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> StackDemo(&#123;Key? key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Stack(</span><br><span class="line">      children: [</span><br><span class="line">        Positioned(</span><br><span class="line">          child: Container(</span><br><span class="line">            child: Icon(</span><br><span class="line">              Icons.add,</span><br><span class="line">              size: <span class="number">180</span>,</span><br><span class="line">            ),</span><br><span class="line">            color: Colors.red,</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">        Positioned(</span><br><span class="line">          child: Container(</span><br><span class="line">            child: Icon(</span><br><span class="line">              Icons.ac_unit,</span><br><span class="line">              size: <span class="number">120</span>,</span><br><span class="line">            ),</span><br><span class="line">            color: Colors.yellow,</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">        Positioned(</span><br><span class="line">          top: <span class="number">20</span>,</span><br><span class="line">          left: <span class="number">20</span>,</span><br><span class="line">          right: <span class="number">20</span>,</span><br><span class="line">          child: Container(</span><br><span class="line">            child: Icon(</span><br><span class="line">              Icons.access_alarm,</span><br><span class="line">              size: <span class="number">60</span>,</span><br><span class="line">            ),</span><br><span class="line">            color: Colors.blue,</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div align="center">
<img src="756c171599864736be922041582a7a50~tplv-k3u1fbpfcp-watermark.png">
</div> 

<p>可以看到最小的蓝色视图的上左右均设置了 20 的间距，是不是熟悉的约束味道。。。</p>
<h2 id="Expanded"><a href="#Expanded" class="headerlink" title="Expanded"></a>Expanded</h2><p>Expanded 是一个类似 Container 的常用的布局容器，它用来填充布局，使用了填充布局在主轴方向上是不会有间隔的,所以 Expanded 用在 Row 里面的时候，子控件的宽度设置就没有意义了，而在 Column 里面使用的使用，子控件的高度设置就没有意义了。这里以 Column 为例：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LayoutDemo</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> LayoutDemo(&#123;Key? key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      color: Colors.green,</span><br><span class="line">      alignment: Alignment(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">      child: Column(</span><br><span class="line">        children: [</span><br><span class="line">          Expanded(</span><br><span class="line">              child: Container(</span><br><span class="line">                child: Icon(Icons.add, size: <span class="number">180</span>,),</span><br><span class="line">                color: Colors.red,</span><br><span class="line">              ),</span><br><span class="line">          ),</span><br><span class="line">          Expanded(</span><br><span class="line">              child: Container(</span><br><span class="line">                child: Icon(Icons.ac_unit, size: <span class="number">120</span>,),</span><br><span class="line">                color: Colors.yellow,</span><br><span class="line">              ),</span><br><span class="line">          ),</span><br><span class="line">          Expanded(</span><br><span class="line">              child: Container(</span><br><span class="line">                child: Icon(Icons.access_alarm, size: <span class="number">60</span>,),</span><br><span class="line">                color: Colors.blue,</span><br><span class="line">              ),</span><br><span class="line">          ),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div align="center">
<img src="c61d9a86201943d3a6e31d7f8afc67d4~tplv-k3u1fbpfcp-watermark.png">
</div> 

<h2 id="AspectRatio"><a href="#AspectRatio" class="headerlink" title="AspectRatio"></a>AspectRatio</h2><p>AspectRatio 是一个容器类，它有一个属性 aspectRatio 表示宽高比。如果指定了宽度，根据这个 aspectRatio 可以自动算出高度；如果指定了高度，根据 aspectRatio 可以自动算出宽度。如下面代码指定了父视图高度为 100，aspectRatio 宽高比为 2，子视图宽度就是 200，再把父视图撑起来也是 200。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LayoutDemo</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> LayoutDemo(&#123;Key? key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">        color: Colors.green,</span><br><span class="line">        alignment: Alignment(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">        child: Container(</span><br><span class="line">          color: Colors.blue,</span><br><span class="line">          height: <span class="number">100</span>,</span><br><span class="line">          child: AspectRatio(</span><br><span class="line">            aspectRatio: <span class="number">2</span>,</span><br><span class="line">            child: Icon(</span><br><span class="line">              Icons.add,</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        ));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div align="center">
<img src="b7c386921f1644af91bc5d24da5766c5~tplv-k3u1fbpfcp-watermark.png">
</div> 

<h1 id="Flutter状态管理"><a href="#Flutter状态管理" class="headerlink" title="Flutter状态管理"></a>Flutter状态管理</h1><p>之前介绍的这么多类都是无状态的，意思是显示之后没办法更新 UI 的，如果想要实时更新 UI 的话，就不能继承无状态的类了。我们先来看一个例子：明明 count 变化了，但是界面显示没有变化</p>
<p><img src="95069ac3145a4002ac097296d7fe4a5d~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>记得修改 APP 的 home 视图</p>
<p><img src="5a40edcaae6b4c5f87d41a0f3800d357~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>然后点击屏幕右下角的加号按钮，可以发现明明控制台打印了 count 的值已经发生了变化，但是界面显示依然是 0</p>
<p><img src="d729f11560cf44bf82dbbbd5562f7411~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>下面我们解决这个问题，将 StateManagerDemo 继承改为 StatefulWidget，实现 createState 方法返回一个自定义的 State 对象，自定义的 State 对象里面实现 build 方法。还需要注意在按钮的点击方法里调用一下 setState 方法。这样每次点击加号按钮就能实时更新 UI 了。改造完之后如下图所示：</p>
<p><img src="778099f068b949c7b89886ff80dc21bc~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<h1 id="项目搭建之底部TabBar"><a href="#项目搭建之底部TabBar" class="headerlink" title="项目搭建之底部TabBar"></a>项目搭建之底部TabBar</h1><p>到目前为止，我们对 flutter 的一些基础知识就算是介绍的差不多了。接下来我们开始做一个简单的仿微信 APP。我们应该都有经验，理论的知识学得再多，不动手开始敲代码，不在项目中运用，是很难真正掌握一门知识的。</p>
<p>新建一个 flutter 工程，命名 wechat_demo：</p>
<p><img src="800ac6c2c4414768bcdba85dd953f749~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>删掉多余的代码，可以全部重新自己写：</p>
<p><img src="063a4f181c9246b08eb8232606db9132~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>创建底部的 TabBar 和 item,默认的 type 是白色的，显示效果很难看所以改为 fixed，还可以设置 fixedColor：</p>
<p><img src="b48d2047edc94f0a834233853b73602d~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<div align="center">
<img src="32edbe92fef5448abadd95e52c6078f4~tplv-k3u1fbpfcp-watermark.png">
</div> 

<p>这样底部的 TabBar 就显示出来了，会发现点击没有效果，对比 iOS 会发现这块地方还是 iOS 提供的 UITabBarController 封装的更舒服，每个平台都各有优劣吧。</p>
<p>BottomNavigationBar 有一个属性 currentIndex 即代表了当前选中的下标。我们可以通过设置它的值来控制哪个按钮被选中。既然需要改变 UI 了，说明我们需要将 StatelessWidget 改为 StatefulWidget 了。还有一个参数 onTap 是用来回调点击事件的。实现点击事件，切换 currentIndex，重新 setState 就可以实现，点击切换了。我们将 bottomNavigationBar 相关代码放到一个新的文件 rootPage 中。代码如下：</p>
<p><img src="535f9cbc78574cbeb866215f6e590f18~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>记得修改 main.dart 文件中</p>
<p><img src="0174709795614365a4438640b1b14b31~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>这样就实现了 APP 的底部 TabBar 的展示，点击功能。点击每个 item 的时候，会发现 flutter 的 bottomNavigationBar 还自带了动画效果…</p>
<p>我们知道 Scaffold 还有一个 body 的属性，表示展示在屏幕上的内容。我们每个 item 对应的界面都需要一个 AppBar，那么也许意味着，body 属性还需要一个 Scaffold 来展示我们的每个 item 对应的内容。</p>
<p><img src="ee3b980bed8642e6a1480ea509eab7eb~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>可以看到微信首页就已经大概出来了，但是点击的时候只会显示这个微信页面，怎么实现切换不同的页面呢，肯定需要一个数组，来存放对应的每个页面了。</p>
<p><img src="f299d1dcc70f4a5d8205a9caf62afb72~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>然后 body 里，根据我们的 _currentIndex 返回对应的 body</p>
<p><img src="98747470b16143d3b733754def9e7219~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>这样点击每个 item 都会跳转到对应的界面了，APP 的主框架的搭建好了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>今天主要讲了 flutter 的三大布局类 Row，Column，Stack 以及他们的一些属性。然后是有状态的 Widget 和无状态的 Widget，最后搭建了一下我们要做的仿微信 APP 的底部 bottomNavigationBar 和切换页面功能</p>
]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>8天让iOS开发者上手Flutter之五</title>
    <url>/2021/08/01/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E4%BA%94/</url>
    <content><![CDATA[<p>上篇文章，我们已经完成了通讯录的列表。这篇文章介绍完成通讯录右侧的索引条的功能。</p>
<h1 id="显示索引条"><a href="#显示索引条" class="headerlink" title="显示索引条"></a>显示索引条</h1><p>之前我们已经做过了我的页面的布局，我的页面上有一个列表和一个拍照按钮，和我们今天要实现的索引条布局十分类似。我的页面的布局如下：</p>
<p><img src="81053ec975144322af3bc1ef5f9e08e4~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>通讯录界面的布局，和我的页面的布局都是使用一个 Stack 包含列表和其他子视图来实现。索引条是紧贴屏幕右侧，然后里面的子视图是由上至下的。所以自然的会想到使用一个 Positioned 包含 Column 来实现。Positioned 和 Stack 的组合我们之前讲过，这两个组合起来使用，就和我们 iOS 的约束布局类似，可以设置上左宽高等等。Column 就更不用多说，我们已经使用过很多次了。所以代码如下图所示：</p>
<p><img src="3b62754a2a31422a9416c79e94759829~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<div align="center">
<img src="be45a58d597a4a35b0d5ec97d96c445f~tplv-k3u1fbpfcp-watermark.png">
</div>

<p>然后优化一下索引条的位置，高度我们设置为屏幕高度的一半，那么上下的间距就不能设置为 0 了，设置距离上间距为屏幕的 1&#x2F;8 看起来比较合适。</p>
<p><img src="d72de44cc3ed45c4b43280c52b1a59ee~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<div align="center">
<img src="7351193b625b4e5195471735a66581fa~tplv-k3u1fbpfcp-watermark.png">
</div>

<h1 id="抽取-IndexBar"><a href="#抽取-IndexBar" class="headerlink" title="抽取 IndexBar"></a>抽取 IndexBar</h1><p>写到这里我们会发现，这个索引条还有很多的功能需要我们来实现，还是有点复杂的，如果代码都写在 friends_page.dart 里会有点冗余，我们完全可以将这个索引条作为一个独立的 Widget 来实现。新建 index_bar.dart 文件，代码如下：</p>
<p><img src="fe9068395cd1451fa340e6dace011a17~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<h1 id="实现-IndexBar-的点击切换状态"><a href="#实现-IndexBar-的点击切换状态" class="headerlink" title="实现 IndexBar 的点击切换状态"></a>实现 IndexBar 的点击切换状态</h1><p>当没有触摸到 IndexBar 的时候，默认是不展示背景色的，文字也是黑色的。当我们开始点击 IndexBar 的时候，显示出背景色，然后文字也变成了白色。</p>
<p>实现这个功能，主要是要对 <code>GestureDetector</code> 的两个方法有所了解。<code>onVerticalDragDown</code> 方法会在手指触摸 IndexBar 的时候就会被调用，<code>onVerticalDragEnd</code> 会在手指松开屏幕的时候调用。利用这两个方法就可以实现需求。代码如下：</p>
<p><img src="133c4a566110476b8405e347c313840d~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>因为要对文字的颜色进行修改，所以初始化 Text 的时候，就需要使用变量 _textColor;</p>
<p><img src="beaa4c3ca6ee489892a049625fe25a99~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<h1 id="获取当前选中的下标"><a href="#获取当前选中的下标" class="headerlink" title="获取当前选中的下标"></a>获取当前选中的下标</h1><p>同样是对 <code>GestureDetector</code> 的一个手势方法的使用，<code>onVerticalDragUpdate</code> 这个方法的调用时机，在手指移动的时候会不停的调用这个方法。这个方法有一个 <code>DragUpdateDetails</code> 参数，它包含了手指所在的坐标信息。不过是相对于整个屏幕的坐标，可以将它转化为相对于 IndexBar 的坐标，然后通过计算可以得到我们当前选中的是哪个下标。代码如下：</p>
<p><img src="c1faac2e10e9496396883d1cba5a80b8~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>方法中的 ~&#x2F; 是 flutter 特有的运算符，意思是除后取整。而 clamp() 是对边界情况的处理，意思调用该函数的结果在它的两个参数之间。</p>
<h1 id="回调选中的下标"><a href="#回调选中的下标" class="headerlink" title="回调选中的下标"></a>回调选中的下标</h1><p>这里的回调，和 OC 里面的 block，Swift 里面的闭包都是一个意思。flutter 里面带有下划线的变量是私有的，外部无法访问的。所以对外暴露的参数，不能写在 <code>_IndexBarState</code> 类里面，需要写在 IndexBar 类里面。声明一个闭包(或者叫 block)属性,作为必传参数在初始化的时候传入。</p>
<p><img src="55fdb39036574be89074b99011841ad8~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>这样，在 <code>friends_page.dart</code> 文件中初始化 <code>IndexBar</code> 的时候，就需要传入一个闭包。然后 <code>IndexBar</code> 内部在 <code>onVerticalDragUpdate</code> 的时候，调用这个闭包，就可以将当前选中的下标回调给外部了。</p>
<p><img src="922919210c40483a945f4d0944f05ce0~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p><img src="634b70d14d9c4b81b022321f39ed69cb~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>这个时候，会发现一个小问题，就是点击 IndexBar 的时候，回调没有执行，只有在点击并手指挪动的时候才会执行。所以需要在 <code>onVerticalDragDown</code> 方法里面也调用一次闭包。这时候如果直接将 <code>onVerticalDragUpdate</code> 方法里面的代码复制到 <code>onVerticalDragDown</code> 方法里面确实没有问题，但是会明显的看到重复的代码太多了。</p>
<p><img src="ae4eaba1a6884716969cfe2105ad5033~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>所以可以抽取一个方法，将重复的代码放到一块。</p>
<p><img src="f935783fe0b24caab0e4d75cde2f5f05~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>然后调用的时候就简单多了。</p>
<p><img src="e1f72d6a90154eb38166c935be8e34dd~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<h1 id="优化回调执行的频率"><a href="#优化回调执行的频率" class="headerlink" title="优化回调执行的频率"></a>优化回调执行的频率</h1><p>已经成功的实现了回调，但是从打印的结果来看，会发现同样一个下标会被回调许多次。这样我们滚动好友列表的时候会造成不必要的性能消耗。明明只需要滚动一次，结果却滚动了无数次到同一个位置。所以这里我们需要优化一下，一个很自然的想法就是记录一个 <code>_currentIndexLetter</code>，每次执行回调的时候，判断回调的首字母是否和 <code>_currentIndexLetter</code> 是否不同，如果是一样的就没有必要回调了，只有不同的时候，才执行回调。</p>
<p><img src="eb0ec5918762440885e3bc19d5023c29~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>代码如下：</p>
<p><img src="a6d2588d71ee4c8680b4bc2116ea8e61~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p><img src="493df27362e642b49c63fcad4be40d12~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>这样回调的频率就正常了。</p>
<h1 id="滚动好友列表-ListView"><a href="#滚动好友列表-ListView" class="headerlink" title="滚动好友列表 ListView"></a>滚动好友列表 ListView</h1><p>可滚动的 widget 都有一个 controller 属性，用于控制滚动条的行为。controller 属性是一个 <code>ScrollController</code> 对象。可以使用它来实现指定滚动到某个位置，实现回到顶部等功能。</p>
<p>滚动好友列表需要一个新的对象 <code>ScrollController</code> 实例，将它设置给 ListView 的 <code>controller</code> 属性，然后就可以通过使用 <code>ScrollController</code> 实例来操作 ListView 的滚动。</p>
<p><img src="d6867385dc2d4dda98559f16f69f40a2~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p><img src="87bb89f0fc6d41ac9bfdc63a78aaebce~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>这里暂时先将滚动的偏移设置为固定值 250，试试看效果。可以看到当我们点击 IndexBar 的时候，ListView 就会滚动到偏移为 250 的地方。接下来就是处理滚动的实际偏移值了。</p>
<p>滚动的实际偏移，是根据我们的数据源来计算的。因为我们的 cell 的高度是确定的，不显示组头的 cell 高度是 54，有组头的 cell 高度是 54 + 30 &#x3D; 84。使用首字母作为 key，计算出对应的偏移为 offset，然后使用 Map(类似 iOS 中字典)记录下来。由于第一个是不是字母，而是搜索符号，而它对应的偏移也是固定的 0。所以可以在初始化 Map 的时候就指定好。而其他的高度我们在 initState 方法中计算。代码如下：</p>
<p><img src="a1486026da394231ae187a6eb56f462f~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>有了这个 Map 之后，我们在 IndexBar 的回调方法中，就可以根据 IndexBar 回调给我们的首字母得到对应的偏移值了。代码如下：</p>
<p><img src="1a12df0544684482ad25772040aa4c27~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>到这里，我们的 IndexBar 基本上就实现了滚动 ListView 的功能。但是滚动几次之后就会发现一个小问题。。。滚动到底部的几个组头的时候，会出现 ListView 先将组头滚动到指定位置，然后又滚回底部的情况。原因很好理解，后面的组头内容不够显示一整个屏幕了。所以我们这里需要做下处理。这里主要是对 ListView 的滚动的监听，如果是在 iOS 中我们会想去获取滚动视图的 contentSize 然后减去 UITableView 的高度，就是 UITableView 的最大的滚动范围。而在 Flutter 中，这些都不需要我们计算了。</p>
<p>如果需要获取到 ListView 的一些滚动相关的信息，可以将它包裹在 <code>NotificationListener</code> 里面，它有一个 <code>onNotification</code> 属性，是一个闭包，可以回调给我们一些滚动的相关信息。包含在闭包参数 <code>ScrollNotification note</code> 里面。准确来讲滚动相关的信息包含在 <code>ScrollNotification</code> 的属性 <code>metrics</code> 里面。它包含当前滚动偏移值，能滚动的最大范围(这就是我们 iOS 中 contentSize 的高减去 UITableView 的高)等等信息。完整代码如下：</p>
<p><img src="150c3f3be83546c1b47a17038928298e~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>将 <code>_maxScrollExtent</code> 定义为一个属性就好了。需要注意的是并不能给初始值为 0，否则没有滚动 ListView 之前，使用 IndexBar 就无法滚动 ListView 了。</p>
<p><img src="f77a46cc161b4f6297011476a258d27a~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>至此，IndexBar 滚动 ListView 的功能就实现了。</p>
<h1 id="显示指示器"><a href="#显示指示器" class="headerlink" title="显示指示器"></a>显示指示器</h1><p>终于来到了最后一步，显示我们 IndexBar 的指示器。首先考虑的就是布局。最初的 IndexBar 只有右侧的下标一列。现在我们左侧需要一块容器用来显示我们的指示器，所以 IndexBar 的根视图应该考虑改为 Row。指示器背景的不规则图形可以使用一张图片展示，图片已经准备好了。中间的文字，使用 Text 就够了。先看下大概布局代码：</p>
<p><img src="a2c4ca445a8a4024a1b85f47e888bd1d~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<div align="center">
<img src="83d6f7a7ffeb4010bd9f134a42b4c358~tplv-k3u1fbpfcp-watermark.png">
</div>

<p>如果觉得位置不是很合适，可以修改一下各自的宽度。然后是对指示器的显示与隐藏做控制，指示器的显示与隐藏的控制，应该说跟背景色的显示隐藏是类似的。都是在手势的那两个方法里面实现控制。使用一个 bool 变量来控制指示器的显示与隐藏，在手势的触摸方法和离开方法里面操作这个 bool 变量，然后 setState() 就可以实现了指示器的显示与隐藏了。</p>
<p>然后是关于指示器的显示文本的。这个文本就是我们的 <code>_currentIndexLetter</code>，直接使用就好了。最后是关于如何控制整个 IndexBar 的上下位移的。通过对 Alignment 的使用，发现可以控制 IndexBar 的上下位移。通过不断的修改 Alignment 的 y 值会找到一个合适的 y 值指向第一个放大镜，那么 -y 就指向最后一个字母 Z。我这里试了几次发现 y&#x3D;-1.13 的时候，指示器刚刚好指向第一个放大镜的位置。那么现在的问题就是将 1.13 * 2 &#x3D; 2.26 分成<code>_index_words.length - 1</code>份，然后根据选择的下标，取得对应的Alignment 的 y 值。当我们选择第一个的时候下标为 0，y 值应该为 -1.13,当我们选择最后一个的时候下标为 <code>_index_words.length - 1</code>,y 值应该为 1.13。根据这些信息就可以找到计算 y 值的公式。最终的代码如下：<br></p>
<p>新增两个变量<code>_showIndicator</code>和<code>_indicatorAlignmentY</code>。</p>
<p><img src="353987e4193a4460984edca74d16588b~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>使用这两个变量还有<code>_currentIndexLetter</code></p>
<p><img src="6fd8c7c981f64b62b76c35b4592ac324~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>到这里，我们就终于实现了通讯录的 IndexBar 的封装。下一节会介绍一些网络请求了…</p>
<div align="center">
<img src="ca2cca992d764871abe3a7e8163c2d85~tplv-k3u1fbpfcp-watermark.png">
</div>


]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>8天让iOS开发者上手Flutter之六</title>
    <url>/2021/08/17/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%85%AD/</url>
    <content><![CDATA[<p>发现了一个宝藏网址，这里讲解的 <a href="https://book.flutterchina.club/">flutter实战</a> 比我写的靠谱多了。</p>
<h1 id="准备网络数据"><a href="#准备网络数据" class="headerlink" title="准备网络数据"></a>准备网络数据</h1><p>这一步不是很重要，提供一些假数据而已，不是重点嫌麻烦的可以跳过。</p>
<p>先介绍一个网址：<a href="http://rap2.taobao.org/account/login">http://rap2.taobao.org/account/login</a> 这个网址用来搭建我们需要的网络数据，注册账号非常简单，这里就不多说了。</p>
<p>注册完成之后，新建一个仓库，简简单单取个名字就够了：</p>
<p><img src="4a3c12fb3b244575ac6b794168d93675~tplv-k3u1fbpfcp-watermark.png" alt="Snip20210808_10.png"></p>
<p>之后点击进入仓库，可以看到下图：</p>
<p><img src="dfd2860cb5c64f4b947d45551aba9d93~tplv-k3u1fbpfcp-watermark.png" alt="Snip20210808_11.png"></p>
<p>会默认生成以一个示例接口，可以看一看示例接口的生成规则。看不懂也没关系，我们直接直接上手自己新建一个接口，如图所示：</p>
<p><img src="0af92d6af9b14eae865b69d5beb874c4~tplv-k3u1fbpfcp-watermark.png" alt="Snip20210808_12.png"></p>
<p>点击右上角的编辑按钮进入编辑模式，新建一个响应 chatlist，类型为 Array。然后生成 chatlist 的数据，imageUrl 表示每条聊天数据的用户头像。其中用户头像的初始值里面有一段 @natural(20,99)，这个是 Mock.js 代码。这里是相关介绍 <a href="http://mockjs.com/">http://mockjs.com/</a></p>
<p><img src="4b21769272134c4ea316f9289a9d945d~tplv-k3u1fbpfcp-watermark.png" alt="Snip20210808_14.png"></p>
<p>每条聊天数据，除了 imageUrl 还需要有用户名 name 和消息的内容 message。@cname 用来生成随机的中文名，@cparagraph 用来生成随机的中文段落来表示聊天内容。我们这里只是简单的构造一下这个聊天列表所需要的数据，真正的聊天列表的数据肯定是不会这么简单的。。。</p>
<p><img src="c1a42755454d455d9d2be30c80fd6e62~tplv-k3u1fbpfcp-watermark.png" alt="Snip20210808_15.png"></p>
<p>编辑的差不多的时候，记得点击保存,保存之后点击红圈中的图标就可以获取到数据</p>
<p><img src="3a1db20c16414845bc45ce901e244a66~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<h1 id="聊天页面导航条"><a href="#聊天页面导航条" class="headerlink" title="聊天页面导航条"></a>聊天页面导航条</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>默认展示页面改为 <code>_currentIndex</code> 改为 0,新建 chat 目录，将相关文件放在这里。</p>
<p><img src="0213b262930d4066b6f26e34993011cc~tplv-k3u1fbpfcp-watermark.png" alt="Snip20210808_17.png"></p>
<h2 id="添加加号按钮"><a href="#添加加号按钮" class="headerlink" title="添加加号按钮"></a>添加加号按钮</h2><p>加号按钮这个东西，我们之前已经添加过类似的了，appBar 的 actions 就是我们需要添加代码的地方。</p>
<p><img src="336b5de10dc2451bbb989516bd66049c~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>如果我们按照这个思路写下去的话，就需要自己再去实现一个弹出菜单的类。其实 flutter 提供了我们一些现成的类可以做到类似的效果。</p>
<h2 id="PopupMenuButton"><a href="#PopupMenuButton" class="headerlink" title="PopupMenuButton"></a><code>PopupMenuButton</code></h2><p><code>PopupMenuButton</code> 类用来弹出一个菜单，必传参数为 <code>itemBuilder</code>，用来实现它需要展示的内容。<code>PopupMenuItem</code> 就是用来展示内容的类。这里有一个细节说一下，<code>PopupMenuButton</code> 有一个 <code>onSelected</code> 属性，这个属性是个闭包，意思是选中某个 <code>PopupMenuItem</code> 的时候，会调用这个闭包。但是有一个前提就是每个 <code>PopupMenuItem</code> 的 <code>value</code> 必须不为 null 的时候，才会执行 <code>onSelected</code> 闭包，我在这里卡了半天，网上找了半天资料也没有明确讲到这里。其他就没什么好讲的了，都比较简单。</p>
<p><img src="4b9d82deec2e46e881aa084e25d9bb7d~tplv-k3u1fbpfcp-watermark.png" alt="Snip20210812_19.png"></p>
<p>其中 <code>_buildMenuItem</code> 的实现如下，注意 <code>value</code> 要赋值就好了，不为空就行，不然 <code>PopupMenuButton</code> 的 <code>onSelected</code> 不执行：</p>
<p><img src="9f6f5da2ff794264afbf256c95e307a6~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>还有一个小细节，如何设置 <code>PopupMenuButton</code> 的颜色，可以直接设置它的颜色</p>
<p><img src="0548c31d2ba248e9b8bdeb375031c487~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>还可以设置APP的主题的 <code>cardColor</code>，不过这个优先级没有直接设置 <code>PopupMenuButton</code> 颜色高。</p>
<p><img src="9c19742492944488ba13249b31db685b~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<h1 id="请求网络数据"><a href="#请求网络数据" class="headerlink" title="请求网络数据"></a>请求网络数据</h1><h2 id="https-pub-flutter-io-cn"><a href="#https-pub-flutter-io-cn" class="headerlink" title="https://pub.flutter-io.cn/"></a><a href="https://pub.flutter-io.cn/">https://pub.flutter-io.cn/</a></h2><p><img src="04224929590b47528f1a1ea05dbe8ab9~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>这个网站可以搜索 flutter 使用的包 packages。我们使用 http 这个包来请求我们的网络数据。这个包是 flutter 官方提供的。实际项目开发的时候可能并不会使用 http 这个包，大部分是使用 dio 来请求网络数据。这里只介绍官方的 http 包如何使用。</p>
<h2 id="导入http包"><a href="#导入http包" class="headerlink" title="导入http包"></a>导入http包</h2><p><img src="32044f0faafd4673bc0a0e5cc22ae858~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p><img src="1dfb3991238d4f77927c2728ef210d6e~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>粘贴完成之后需要更新一下，就是获取一下包对应的代码。可以通过上方的 <code>Pub get</code>,也可以在终端中输入 <code>flutter packages get</code> </p>
<p><img src="dfeb775cd3ae4e96ba22440e706d33d3~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>命令执行完之后，就可以使用这个包了。</p>
<h2 id="导入-http-头文件并取别名"><a href="#导入-http-头文件并取别名" class="headerlink" title="导入 http 头文件并取别名"></a>导入 http 头文件并取别名</h2><p><img src="9539435380ef4dd38aa8af4eaa119b38~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<h2 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h2><p><img src="df206f11e0b1474e8086c80ff222d5cf~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>请求的发送写在 <code>initState</code> 里面。<code>getData()</code> 后面跟了一个 async 表示的是异步执行。async 需要搭配 await 使用，await 后面跟着的是耗时的代码。所以上面的程序会先打印来了，然后再输出请求的状态码；</p>
<p><img src="a9e9b0f789c4471492caccb982daa03d~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>点击其他的页面，再次回到当前页面会发现 initState 方法重新走了一遍，这是因为我们还没有保存住状态，后面会讲到如何保持 Widget 的状态。</p>
<h2 id="处理返回的数据"><a href="#处理返回的数据" class="headerlink" title="处理返回的数据"></a>处理返回的数据</h2><p>首先介绍一下，在 flutter 中如何将请求返回的 JSON 数据转为 Map，在我们 iOS 开发中是转为字典，而 flutter 中没有字典这个类型，对应的类型是 Map。以及如果将 Map 转为 JSON。在 iOS 中我们知道会使用一个 <code>NSJSONSerialization</code> 的类用来处理JSON数据。同样的，在 flutter 中也会有一个专门的类 <code>JsonCodec</code> 来处理。</p>
<h3 id="JSON-和-Map-互相转"><a href="#JSON-和-Map-互相转" class="headerlink" title="JSON 和 Map 互相转"></a>JSON 和 Map 互相转</h3><p><img src="cd897b4dbfd54af1941972b4360d3159~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>其中的 json 就是 <code>JsonCodec</code> 的实例。需要导入 <code>&#39;dart:convert&#39;</code> 头文件。flutter 中还可以通过 <code>is</code> 来判断是不是某个类型。</p>
<h3 id="新建聊天模型"><a href="#新建聊天模型" class="headerlink" title="新建聊天模型"></a>新建聊天模型</h3><p><img src="3017a15c3cbe4d3ab67d82bafdb385f2~tplv-k3u1fbpfcp-watermark.png" alt="image.png"> </p>
<p>除了红框内的方法之外，其他没什么新鲜事物。红框内的方法应该说是一个工厂方法，是设计模式的一种，用来初始化对象的。除了默认的初始化方法，还可以使用这个工厂方法来实例化一个 Chat 对象。模型建立好了之后就可以处理响应的数据了</p>
<h3 id="处理响应的数据"><a href="#处理响应的数据" class="headerlink" title="处理响应的数据"></a>处理响应的数据</h3><p><img src="5bf33bb810d64e51873ad84fb15bf76d~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>这里用到了 Future，关于 Future 的讲解可以看官方文档 <a href="https://dart.cn/tutorials/language/futures">https://dart.cn/tutorials/language/futures</a></p>
<h1 id="使用-FutureBuilder-显示界面"><a href="#使用-FutureBuilder-显示界面" class="headerlink" title="使用 FutureBuilder 显示界面"></a>使用 FutureBuilder 显示界面</h1><p>很多时候我们会依赖一些异步数据来动态更新 UI，比如在打开一个页面时我们需要先从互联网上获取数据，在获取数据的过程中我们显示一个加载框，等获取到数据时我们再渲染页面；当然，通过 StatefulWidget 我们完全可以实现上述这些功能。</p>
<p>但由于在实际开发中依赖异步数据更新UI的这种场景非常常见，因此 Flutter 专门提供了 <code>FutureBuilder</code> 来快速实现这种功能。<code>FutureBuilder</code> 会依赖一个 <code>future</code>，它会根据所依赖的 <code>future</code> 的状态来动态构建自身。这个 <code>future</code> 我们刚刚已经准备好了。关于 <code>FutureBuilder</code> 的介绍 <a href="https://book.flutterchina.club/chapter7/futurebuilder_and_streambuilder.html#_7-5-1-futurebuilder">这篇文章</a> 讲解的很详细。<br>最后完整代码如下：</p>
<p><img src="320e21f3548744db88a59b289094e80b~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<h1 id="不使用-FutureBuilder-的方式"><a href="#不使用-FutureBuilder-的方式" class="headerlink" title="不使用 FutureBuilder 的方式"></a>不使用 FutureBuilder 的方式</h1><p>刚刚说了，我们可以使用 FutureBuilder 来快速实现展示异步网络数据，也可以自己实现，现在我们自己实现一下。使用一个私有变量 _chatList 记录请求下来的数据，再根据 _chatList 的值来展示不同的页面。代码如下：</p>
<p><img src="57600afd73aa4a3c8178bc07be97a375~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p><img src="22da31c383294f85ae5af4ad182b2ab1~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>因为 getData 的返回值是 Future 的原因，getData() 后面可以跟 <code>then</code> 方法，还可以跟错误捕获 <code>catchError</code>,完成时的回调 <code>whenComplete</code>，超时设置 <code>timeOut</code> 等等，这种写法挺有意思，一路点下去就完了…</p>
<h2 id="实现超时取消刷新功能"><a href="#实现超时取消刷新功能" class="headerlink" title="实现超时取消刷新功能"></a>实现超时取消刷新功能</h2><p><img src="b865f3d6e0434e74a1e1a3324da786f4~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>在每次请求的时候，重置 <code>_cancelConnect</code> 的值。</p>
<p><img src="07c8ba9d07b446f9a6684241fc5f31bc~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<h1 id="保持-Widget-的状态"><a href="#保持-Widget-的状态" class="headerlink" title="保持 Widget 的状态"></a>保持 Widget 的状态</h1><p>我们来回点击通讯录页面和聊天页面，会发现每次点击进入当前的页面，都会重新的载入，<code>initState()</code> 会被重新调用。将通讯录页面滑动到底部，再次点击进入会发现又默认回到了顶部。为什么会出现这样的问题。正是因为我们的Widget的状态没有保持，每次展示都重新创建了。</p>
<p>Dart 语言中有一个 Mixins 的概念：<a href="https://dart.cn/samples#mixins">官方的解释是这样</a>，可以给类 A Mixins 一个 B，那么 A 就拥有了 B 的属性和方法。有点像 OC 的类扩展的意思。保持 Widget 的状态就需要用到这个语言特性。一共有三个步骤：</p>
<ol>
<li>Mixins 类<code>AutomaticKeepAliveClientMixin</code></li>
<li>重写<code>wantKeepAlive</code>方法</li>
<li>调用父类Builder方法</li>
</ol>
<p><img src="d3d29b34ea3746b9a9cc7ec0ca19a9d9~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>同样把通讯录页面也实现上面的步骤。然后再次来回点击发现还是没有保持住状态？？？这里有一个最大的问题就是我们的根 Widget 都没有保持住状态，那还谈什么保持子 Widget 的状态呢。。。</p>
<h2 id="使用-PageView"><a href="#使用-PageView" class="headerlink" title="使用 PageView"></a>使用 PageView</h2><p>来到 rootPage.dart 文件，我们会看到 body 里面直接取了数组的某个元素作为根 Widget 展示。这样是无法保持住状态的，使用 PageView 才可以保持住状态。</p>
<p><img src="275398750bb34835b5fa1a593e30bbc4~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>使用 PageView，代码如下：</p>
<p><img src="adc5cc5e8c1046909d27097107c9f590~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>点击跳转到其他页面就可以直接通过 _pageController 来完成。使用了 PageView 之后会发现，不同的页面之间可以直接通过手势左右滑到就能切换了。这样的效果我们一般是不需要的，可以设置直接关闭。如果需要的话，在滑动的方法里面重新设置底部导航条的正确位置也是没有问题的。</p>
<h3 id="使用滑动切换，解决-bug"><a href="#使用滑动切换，解决-bug" class="headerlink" title="使用滑动切换，解决 bug"></a>使用滑动切换，解决 bug</h3><p><img src="44cb9bc186724397b471136abbcc44ea~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<h3 id="禁用滑动切换"><a href="#禁用滑动切换" class="headerlink" title="禁用滑动切换"></a>禁用滑动切换</h3><p><img src="e9d533514d734781bd6a13e6c43e738a~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>8天让iOS开发者上手Flutter之八</title>
    <url>/2021/08/29/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%85%AB/</url>
    <content><![CDATA[<h1 id="介绍四种-Flutter-Project"><a href="#介绍四种-Flutter-Project" class="headerlink" title="介绍四种 Flutter Project"></a>介绍四种 Flutter Project</h1><p>先介绍一下这四个的差别和使用的场景。</p>
<p><img src="4c14a47588414f198ca94d7fb4799997~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<h2 id="Flutter-App"><a href="#Flutter-App" class="headerlink" title="Flutter App"></a>Flutter App</h2><p>如果是想要使用 flutter 开发一个新的项目，那么就选择 Flutter App。就像我们之前的 <code>wechat_demo</code></p>
<h2 id="Flutter-Module"><a href="#Flutter-Module" class="headerlink" title="Flutter Module"></a>Flutter Module</h2><p>但是很多时候我们目前手上的原生 APP 可能会很庞大，不是随便就可以重新使用 flutter 重新再写一遍的。但是又想在现有的 APP 中体验一下 flutter，那么就选择 Flutter Module</p>
<h2 id="Flutter-Package"><a href="#Flutter-Package" class="headerlink" title="Flutter Package"></a>Flutter Package</h2><p>Flutter 支持使用其他开发者向 Flutter 和 Dart 生态系统贡献的共享 package(类似于 iOS 中的第三方库吧，AFNetworking，YYKit等等…)，这意味着你可以快速构建应用而不是一切从零开始。</p>
<p>Package 最低要求是包含一个 <code>pubspec.yaml</code> 文件。此外，一个 package 可以包含依赖关系 (在 <code>pubspec.yaml</code> 文件里声明)、 Dart 库、应用、资源、测试、图片和例子等。 pub.dev 上列出了很多 package，由 Google 工程师和 Flutter 和 Dart 社区的开发者开发和发布，你可以用在自己的应用里。</p>
<h2 id="Flutter-Plugin"><a href="#Flutter-Plugin" class="headerlink" title="Flutter Plugin"></a>Flutter Plugin</h2><p>插件 (plugin) 是 package 的一种，全称是 plugin package，我们简称为 plugin，中文叫插件。插件 (plugin package) 是一种特别的 package，特别指那些帮助你获得原生平台特性的 package。插件可以为 Android (使用 Kotlin 或 Java 语言)、 iOS (使用 Swift 或 Objective-C 语言)、Web、macOS、Windows、Linux 平台，或其任意组合的平台编写。比如：某个插件可以为 Flutter 应用提供使用原生平台的摄像头的功能。</p>
<h1 id="使用-Flutter-Module-进行混合开发"><a href="#使用-Flutter-Module-进行混合开发" class="headerlink" title="使用 Flutter Module 进行混合开发"></a>使用 Flutter Module 进行混合开发</h1><p>我们前七天开发的项目就是 Flutter App，今天主要介绍如何使用 Flutter Module 进行混合开发。混合开发官方推荐只使用单个 Flutter 页面，多个 Flutter 页面也能支持，但有可能会出现稳定性、性能问题以及 API 仍然可能变动的问题。请大家谨慎使用。<a href="https://flutter.cn/docs/development/add-to-app/multiple-flutters">官方介绍链接</a></p>
<h1 id="iOS-原生项目中导入-Flutter"><a href="#iOS-原生项目中导入-Flutter" class="headerlink" title="iOS 原生项目中导入 Flutter"></a>iOS 原生项目中导入 Flutter</h1><h2 id="准备一个原生-iOS-项目"><a href="#准备一个原生-iOS-项目" class="headerlink" title="准备一个原生 iOS 项目"></a>准备一个原生 iOS 项目</h2><p>进行混合开发就一定需要一个原生项目，根据你的需求，可以使用目前手上的 APP，也可以临时创建一个 Demo 来先练练手。我们这里就临时新建一个 iOS 原生 Demo。</p>
<p><img src="05dd3ccc43394ae4bbcd492293eee1b1~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>这个原生项目很简单，就这么两行代码。</p>
<h2 id="新建-Flutter-Module-项目"><a href="#新建-Flutter-Module-项目" class="headerlink" title="新建 Flutter Module 项目"></a>新建 Flutter Module 项目</h2><p>新建一个 Flutter Module 项目，项目名就叫 module。</p>
<p><img src="76de47c4dafc48f3bc1dfe7b8e9af0c0~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>最好将两个项目放在同级目录下，因为原生项目需要知道 Flutter Module 项目的位置。</p>
<p><img src="c3ccd6384a4a4c9ea5a35c9acf783ec3~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<h2 id="使用-cocoapods-建立关联"><a href="#使用-cocoapods-建立关联" class="headerlink" title="使用 cocoapods 建立关联"></a>使用 cocoapods 建立关联</h2><p>在原生项目 Demo 里建立 Podfile 文件,然后编辑 Podfile。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">flutter_application_path = <span class="string">&#x27;Podfile相对flutter module的路径&#x27;</span></span><br><span class="line">load File.join(flutter_application_path, <span class="string">&#x27;.ios&#x27;</span>, <span class="string">&#x27;Flutter&#x27;</span>, <span class="string">&#x27;podhelper.rb&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>在每个需要集成 flutter module 的 target 添加如下代码</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">target <span class="string">&#x27;你的APP&#x27;</span> <span class="keyword">do</span></span><br><span class="line">  install_all_flutter_pods(flutter_application_path)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>编辑完之后的 Podfile 如下。</p>
<p><img src="6f23d64afaad48af93ad329beaed0195~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>然后执行 <code>pod install</code> 命令</p>
<p><img src="091aa3f14c0a48849a1069034a995ae5~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>如上图所示就表示集成好了。就接下来就是如何在原生项目中展示 flutter 的内容了。</p>
<h2 id="展示单个-Flutter-页面"><a href="#展示单个-Flutter-页面" class="headerlink" title="展示单个 Flutter 页面"></a>展示单个 Flutter 页面</h2><p>展示单个 Flutter 页面的方式有两种，一种是使用 FlutterEngine 的方式，一种是不使用 FlutterEngine 的方式，其实不使用 FlutterEngine 的说法是不严谨的，只是我们没有使用代码创建 FlutterEngine 而已，Flutter 框架内部自己创建了 FlutterEngine，但是为了方便记忆，我们可以这么理解。但是这种不使用 FlutterEngine 的方式<a href="https://flutter.cn/docs/development/add-to-app/ios/add-flutter-screen#alternatively---create-a-flutterviewcontroller-with-an-implicit-flutterengine">官方并不推荐</a>。</p>
<p>因为按需创建 <code>FlutterEngine</code> 的话，在 <code>FlutterViewController</code> 被 present 出来之后，第一帧图像渲染完之前，将会引入明显的延迟。但是当 Flutter 页面很少被展示时，当对决定何时启动 Dart VM 没有好的启发时，当 Flutter 无需在页面（view controller）之间保持状态时，此方式可能会有用。</p>
<h3 id="不使用-FlutterEngine-展示单个-Flutter-页面-官方并不推荐"><a href="#不使用-FlutterEngine-展示单个-Flutter-页面-官方并不推荐" class="headerlink" title="不使用 FlutterEngine 展示单个 Flutter 页面(官方并不推荐)"></a>不使用 FlutterEngine 展示单个 Flutter 页面(官方并不推荐)</h3><p>来到 <code>ViewController.m</code> 文件中导入 <code>Flutter</code> 的头文件</p>
<p><img src="a07fce1803d941e9bce3a14c91c0a02c~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>直接创建 <code>FlutterViewController</code> 对象，并使用 present 和 push 两种方式展示</p>
<p><img src="9cc03a3c599f4a9b9364d3be40f47f68~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>APP显示如下图所示：<br></p>
<p>present方式显示如图：</p>
<div align="center">
<img src="4fc895fa4a0d40329a77e4f982bc97df~tplv-k3u1fbpfcp-watermark.png">
</div>

<p>push方式显示如图：</p>
<div align="center">
<img src="3ed33eafd5744d229a3fa6522dc9e47c~tplv-k3u1fbpfcp-watermark.png">
</div>

<h3 id="使用-FlutterEngine-展示单个-Flutter-页面"><a href="#使用-FlutterEngine-展示单个-Flutter-页面" class="headerlink" title="使用 FlutterEngine 展示单个 Flutter 页面"></a>使用 FlutterEngine 展示单个 Flutter 页面</h3><h4 id="创建-FlutterEngine"><a href="#创建-FlutterEngine" class="headerlink" title="创建 FlutterEngine"></a>创建 FlutterEngine</h4><p>创建 <code>FlutterEngine</code> 的合适位置取决于您的应用。作为示例，我们将在应用启动的 <code>AppDelegate</code> 中创建一个 <code>FlutterEngine</code>，并作为属性暴露给外界。</p>
<p>在 <code>AppDelegate.h</code> 中</p>
<p><img src="ded0c838a6f94e83a17f8a0f7e437d3c~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>在<code>AppDelegate.m</code>中</p>
<p><img src="d409152918c444dab8b008e6e1772723~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<h4 id="展示-FlutterViewController"><a href="#展示-FlutterViewController" class="headerlink" title="展示 FlutterViewController"></a>展示 FlutterViewController</h4><p><img src="8629028d1cf04881bb4e9902a5cd8a30~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>现在，你的 iOS 应用中集成了一个 Flutter 页面。</p>
<h2 id="展示多个-Flutter-页面"><a href="#展示多个-Flutter-页面" class="headerlink" title="展示多个 Flutter 页面"></a>展示多个 Flutter 页面</h2><p>使用上面的方式，最终展示的 Flutter 页面都是同一个页面。而在实际混合开发中，想要展示多个不同的 Flutter 页面的需求应该是普遍的。那么 Flutter 能做到吗？答案是可以的，官方的说法是自 Flutter 2.0.0 开始，可以同时添加多个 Flutter 实例。由于稳定性，性能问题以及 API 任然可能变动，请谨慎使用。<a href="https://flutter.cn/docs/development/add-to-app/multiple-flutters">链接</a></p>
<h3 id="使用-FlutterEngineGroup"><a href="#使用-FlutterEngineGroup" class="headerlink" title="使用 FlutterEngineGroup"></a>使用 FlutterEngineGroup</h3><p>展示多个 Flutter 页面需要使用到 <code>FlutterEngineGroup</code> 来创建 <code>FlutterEngine</code>,而不是上面直接使用 <code>FlutterEngine</code> 的方式。</p>
<p>在<code>AppDelegate.h</code>中</p>
<p><img src="a543a5a2a1854fa291bf8e2120c6fe90~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>在<code>AppDelegate.m</code>中</p>
<p><img src="27d732aecdc9406884024b447df68faa~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<h3 id="新建一个-flutter-页面"><a href="#新建一个-flutter-页面" class="headerlink" title="新建一个 flutter 页面"></a>新建一个 flutter 页面</h3><p>来到 Android Studio 中的 Flutter module 项目，新建一个 page_two.dart 文件，并做些简单的展示</p>
<p><img src="26b655d067424c298a28d5cff4d3ea1e~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p><code>PageTwo</code> 页面写好之后，还需要到 main.dart 文件中声明一个新的 dart 入口。这样才能在原生中找到这个 <code>PageTwo</code> 页面,代码如图：</p>
<p><img src="beae4201c18346d1a3c10e698d1dbd44~tplv-k3u1fbpfcp-watermark.png" alt="image.png"><br></p>
<p><code>page_two</code> 就是 <code>PageTwo</code> 的入口函数，在原生中待会就会用到。</p>
<h3 id="展示两个-Flutter-页面"><a href="#展示两个-Flutter-页面" class="headerlink" title="展示两个 Flutter 页面"></a>展示两个 Flutter 页面</h3><p>回到原生项目的 ViewController.m 文件中，实现如下代码：</p>
<p><img src="f0fba33c2802457588b86c41086ae6d5~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>在第0行，我们创建 <code>engine</code> 的时候，并没有传入 Entrypoint 参数，所以就会展示默认的入口函数 <code>main</code> 对应的页面。在第 1 行中，我们创建 <code>engine</code> 的时候，指定了入口函数为 <code>page_two</code>，那么就会展示 page_two() 所对应的页面。</p>
<p>present 展示的页面如图：</p>
<div align="center">
<img src="f04e4be2fa0f415e8931f017ad091e71~tplv-k3u1fbpfcp-watermark.png">
</div>

<p>push展示的页面如图：</p>
<div align="center">
<img src="a20cf2162ca24b3d816c8938d5d3d8c2~tplv-k3u1fbpfcp-watermark.png">
</div>

<h1 id="Flutter-与-iOS-端通信"><a href="#Flutter-与-iOS-端通信" class="headerlink" title="Flutter 与 iOS 端通信"></a>Flutter 与 iOS 端通信</h1><p>Flutter 和 iOS 端的通信主要是使用各种通道。有<code>MethodChannel</code>，<code>BasicMessageChannel</code>,<code>EventChannel</code>等等，这里主要介绍前面两种通道。通道通过名称来建立联系，所以通道的名称需要确保是唯一的。如果有同名的通道，通信会受到干扰</p>
<h2 id="MethodChannel-方法通道"><a href="#MethodChannel-方法通道" class="headerlink" title="MethodChannel 方法通道"></a>MethodChannel 方法通道</h2><p>方法通道主要用了传递方法名称和参数。在前面我们新建 PageTwo 的时候，就已经创建了一个 <code>MethodChannel</code> 了，名字为 <code>page_two_channel</code>。然后在文本‘返回上一页’的点击手势里面调用了一个方法 <code>invokeMethod()</code>。这个方法可以传递多个参数，第一个参数就是方法名称，后面是方法参数。我们这里没有参数，就只传入一个方法名 <code>pop</code>。那么 Flutter 端的工作就完成了，再回到我们的 iOS 原生端，ViewController.m 里面。实现如下代码：</p>
<p><img src="45acb3a2d3af47278d290b0a24534ac5~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>在 iOS 中给 <code>MethodChannel</code> 加了一个 <code>Flutter</code> 前缀。然后初始化 <code>FlutterMethodChannel</code> 的时候，传入的名字一定要和 flutter 端是一致的，不然是无法建立通讯的。然后调用 <code>setMethodCallHandler:</code> 方法传入一个 block 参数。block 参数会在 channel.invokeMethod() 的时候被调用。block 参数 <code>call</code> 就是对 invokeMethod 参数的一个封装。<code>call</code> 的 <code>method</code> 就是方法名，还有一个 <code>arguments</code> 就是方法参数。这样就可以根据方法名进行判断后作出处理了。现在是从 flutter 向 iOS 原生通信，实现了在 flutter 中点击方法实现了 pop 回到上个页面的。相反的，也可以从 iOS 端向 flutter 端通信。在 iOS 端，使用 <code>channel</code> 调用 <code>invokeMethod()</code> 就可以向 flutter 发送消息了，在 flutter 端同样设置 <code>channel</code> 的 <code>setMethodCallHandler</code> 就可以接收了。</p>
<p>flutter 端 <code>setMethodCallHandler</code> 代码如下：</p>
<p><img src="6eae59f6154f455d82eca2588c6be0fc~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>这里说一句，这些通道不能在无状态的 Widget 里使用，改为有状态的就可以了。</p>
<h2 id="BasicMessageChannel-基础消息通道"><a href="#BasicMessageChannel-基础消息通道" class="headerlink" title="BasicMessageChannel 基础消息通道"></a>BasicMessageChannel 基础消息通道</h2><p>除了上面提到的 <code>MethodChannel</code>，你还可以使用<a href="https://docs.flutter.io/flutter/services/BasicMessageChannel-class.html"><code>BasicMessageChannel</code></a>，它支持使用自定义消息编解码器进行基本的异步消息传递。 此外，您可以使用专门的 <a href="https://docs.flutter.io/flutter/services/BinaryCodec-class.html"><code>BinaryCodec</code></a>，<a href="https://docs.flutter.io/flutter/services/StringCodec-class.html"><code>StringCodec</code></a>和 <a href="https://docs.flutter.io/flutter/services/JSONMessageCodec-class.html"><code>JSONMessageCodec</code></a>类，或创建自己的编解码器。</p>
<p><code>BasicMessageChannel</code> 这个通道的使用方法跟上面的 <code>MethodChannel</code> 是一样的，不同点是在 flutter 中创建 <code>BasicMessageChannel</code> 这个通道需要传入一个编解码器，使用一个标准的编解码器 <code>StandardMessageCodec</code> 可以将基本的数据类型进行编解码。<code>BasicMessageChannel</code> 通道可以实现基础数据类型的通讯。iOS 和 flutter 的基础数据类型对应编解码关系：</p>
<p><img src="992500b07cb845a8afe0039b21cc9384~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本来还想写一个混合开发的实际案例的，但是鉴于本人目前的重点并不是 flutter，而且网上也有较多的介绍这种混合开发的实际案例，所以这里篇文章就写到这里了。这 8 篇文章的内容应该说只是一个 iOSer 入门 flutter 的教程，只是些皮毛东西，离掌握 flutter，Dart 还差的很远。而 flutter 的出现也并不是说会完全取代 Android 和 iOS 开发者，flutter 只能用来搭建一套各平台统一的 UI，而各个平台相关的功能，和硬件相关的需求，都依然需要各个平台的开发者去实现。</p>
]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>8天让iOS开发者上手Flutter之四</title>
    <url>/2021/07/25/8%E5%A4%A9%E8%AE%A9iOS%E5%BC%80%E5%8F%91%E8%80%85%E4%B8%8A%E6%89%8BFlutter%E4%B9%8B%E5%9B%9B/</url>
    <content><![CDATA[<p>上一篇文章我们已经完成了发现页面的搭建，下一步我们实现微信的我的页面</p>
<h1 id="我的页面"><a href="#我的页面" class="headerlink" title="我的页面"></a>我的页面</h1><p>在着手开发我的页面之前，先新建一个 discover 目录，将发现页面相关的文件统一挪动到这个目录下。这里会发现 Android Studio 一个比较特别的地方，新建一个目录后，挪动了的文件不需要重新导入头文件。AndroidStudio 会在需要的地方自动补全路径。这点感觉还是蛮智能的。</p>
<p><img src="528d39f8d678470ca40e1823f8b0af82~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<h2 id="设置APP启动默认展示我的页面"><a href="#设置APP启动默认展示我的页面" class="headerlink" title="设置APP启动默认展示我的页面"></a>设置APP启动默认展示我的页面</h2><p>这个设置在上一篇文章开发发现页面的时候也说过了，就是修改 rootPage.dart 文件里 _currentIndex 的值。</p>
<p><img src="49c0b0536b3a48c09cb0f9a3ec6ad539~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<h2 id="布局右上角的拍照按钮"><a href="#布局右上角的拍照按钮" class="headerlink" title="布局右上角的拍照按钮"></a>布局右上角的拍照按钮</h2><p>观察这个右上角的拍照按钮，会发现上下拖动列表的时候，这个拍照按钮的位置是不会发生变化的。意思是拍照按钮和列表是同级的关系，不是父子控件的关系。所以这里的布局我们可以使用 Stack 来实现，ListView 放在底下，这个拍照按钮放在上面。布局的方式多种多样，只要是能实现需求效果的都是可行的。这个 flutter 的 UI 布局有时候写着写着就会发现括号对不上，使用 command + option + L 也不管用，依然对不齐，这对于某些强迫症的人看起来是真的挺难受的，下图里都还是我一行一行调整了之后的。</p>
<p><img src="97c360d9da944ae58e159ca1c540cfe3~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<h2 id="实现-ListView-的普通-cell-部分"><a href="#实现-ListView-的普通-cell-部分" class="headerlink" title="实现 ListView 的普通 cell 部分"></a>实现 ListView 的普通 cell 部分</h2><p>我的页面的 ListView 的头部那个 cell 明显和它其他的 cell 不同，其他的 cell 跟我们上一篇文章里开发的 discover_cell 基本上是类似的，所以可以直接拿过来使用。做过 iOS 开发的都知道，tableView 等滚动视图作为控制器的根视图的时候，顶部都会有一个间距，在 flutter 里面也有这样的情况，如果需要干掉，就需要将我们的 ListView 包装在一个 <code>MediaQuery.removePadding()</code> 里面，然后设置它的属性 <code>removeTop: true</code>。这样就可以去掉顶部的间距了。完整代码如下：</p>
<p><img src="62a1932e2d984c959c5cded8cbc3052a~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>此时APP显示如图：</p>
<div align="center">
<img src="7de9c40bd8f44ecf8478bc0f6c96c1f2~tplv-k3u1fbpfcp-watermark.png">
</div>

<h2 id="实现-ListView-的头部-cell"><a href="#实现-ListView-的头部-cell" class="headerlink" title="实现 ListView 的头部 cell"></a>实现 ListView 的头部 cell</h2><p>可以看到我们的 _MinePageState 的 build方 法已经够长了，所以关于头部 cell 的代码我们可以封装为一个方法写在其他的地方。</p>
<p><img src="f8f135dee51247708051b102a0cdf2d9~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>关于头部 cell 这里除了布局稍微复杂了一些之外，就只有给图片加圆角是没有讲过的。要设置圆角图片的话，就不能使用 Image 类了。需要使用到 <code>BoxDecoration</code> 类，它可以设置圆角半径 <code>borderRadius</code> 和图片 <code>image</code>。完整代码如下：</p>
<p><img src="609e9067e74f4ca78908c3d3986a7589~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>APP 显示效果如图： </p>
<div align="center">
<img src="b05e536a5a344eb2af3049b88472054c~tplv-k3u1fbpfcp-watermark.png">
</div>

<p>我的页面就这样完成了。发现页面和我的页面这两个页面主要是对布局的灵活运用，都还是比较简单的。</p>
<h1 id="通讯录页面"><a href="#通讯录页面" class="headerlink" title="通讯录页面"></a>通讯录页面</h1><p>接下来实现通讯录界面，这节课先只实现到下图这样，边上的索引下节课再实现。</p>
<div align="center">
<img src="9e1c9e054a92483d9a0da553a3c5745e~tplv-k3u1fbpfcp-watermark.png">
</div>

<h2 id="设置-APP-启动默认展示通讯录页面"><a href="#设置-APP-启动默认展示通讯录页面" class="headerlink" title="设置 APP 启动默认展示通讯录页面"></a>设置 APP 启动默认展示通讯录页面</h2><p>这一步已经讲过 2 次了，就不再贴图了…</p>
<h2 id="设置通讯录页面导航栏"><a href="#设置通讯录页面导航栏" class="headerlink" title="设置通讯录页面导航栏"></a>设置通讯录页面导航栏</h2><p>导航栏的颜色，我们修改了好几次了。这个颜色可以放在一个 const.dart 的公用文件里。以后统一使用这个颜色，也方便以后统一修改。</p>
<p><img src="5b11ecbb41ec479ca4289993173347b8~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>然后是通讯录页面的导航条，除了标题之外，右侧还有一个添加好友的按钮，可以使用 AppBar 的 title 实现一个复杂的导航条，但其实没那个必要。AppBar 提供了一个 actions 属性，这个属性就是展示在导航条右侧的，直接使用这个 actions 就可以了。代码如下：</p>
<p><img src="b36b444a710a4e30b0a2bdc4eac87790~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<h2 id="实现通讯录列表-cell"><a href="#实现通讯录列表-cell" class="headerlink" title="实现通讯录列表 cell"></a>实现通讯录列表 cell</h2><p>通讯录列表 cell 可以使用一种 cell 来完成，也可以使用两种不同的 cell 来完成，如果使用一种 cell 的话，代码里面需要判断的逻辑就会有点多。所以我这里推荐使用两种 cell 来完成。第一种就是头部的 4 个 cell，这几个属于一类，我们使用类 <code>_FriendLocalCell</code> 来表示，而其余的都是属于好友 cell 属于一类，用类 <code>_FriendNetworkCell</code> 表示。关于这两种 cell 我们暂时先不新建文件存放，直接在 friends_page.dart 文件中写。</p>
<h3 id="实现-FriendLocalCell"><a href="#实现-FriendLocalCell" class="headerlink" title="实现 _FriendLocalCell"></a>实现 <code>_FriendLocalCell</code></h3><p>这一类 cell 主要是用来展示当前列表头部的几个 cell 的，这几个 cell 的图片都是从本地加载的。从效果图上可以看出，这个 cell 只需要 title，和 imageName 这两个必传参数就够了。然后是关于布局。最外层使用一个 Row 进行左右布局，左侧使用一个能显示圆角的图片。右侧再用一个 Column 进行上下布局，将文本和底部的分隔线上下排列。这里主要有一个地方没有讲到过，就是在 flutter 中获取屏幕的宽高，我们会抽成一个方法，放在 const.dart 文件中。如下图所示：</p>
<p><img src="a5731eb671cc4d43b4561f53bcf137ba~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p><code>_FriendLocalCell</code> 完整代码如下：</p>
<p><img src="5664732c2af244769cd8c120d9cb6390~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<h3 id="实现-FriendNetworkCell"><a href="#实现-FriendNetworkCell" class="headerlink" title="实现 _FriendNetworkCell"></a>实现 <code>_FriendNetworkCell</code></h3><p>关于 <code>_FriendNetworkCell</code>，可能乍一看之下，会觉得应该和上面的 cell 差不太多。但是实际上还是有那么些区别的。首先 flutter 的 ListView 的是没有组的概念的，所以关于组标题就需要我们自己来动手实现了，这里的做法就是，除了上面的 <code>_FriendLocalCell</code> 所有的子控件之外，每一个 cell 都带上一个组标题，然后根据组标题是否有值，来显示或不显示组标题。那么在布局方面，就需要对上面的 cell，再包装一个 Column，将组标题和头像名称部分包起来。所以当前 cell 所需要的属性，除了好友的名字 <code>name</code> 和头像 <code>imageUrl</code> 为必须之外，还需要一个 <code>groupTitle</code> 为可选参数。</p>
<p>完整的代码如下：</p>
<p><img src="8f3622e493514fed80132a2783a8e40e~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<h2 id="准备数据模型"><a href="#准备数据模型" class="headerlink" title="准备数据模型"></a>准备数据模型</h2><p>同样的，数据我们也分为两种，一种我们就叫作通讯录，使用 <code>AddressBook</code> 来表示。另一种叫好友用 <code>Friends</code> 表示。我们将好友列表用到的数据模型都放在新的文件 friends_data.dart 文件中。</p>
<h3 id="准备-AddressBook-模型数组"><a href="#准备-AddressBook-模型数组" class="headerlink" title="准备 AddressBook 模型数组"></a>准备 <code>AddressBook</code> 模型数组</h3><p>这个模型数组，可以直接根据我们在效果图上看到的东西，生成对应的模型，和数组就好了。完整代码如下：</p>
<p><img src="6769dce1c0a241238c9b687c316e685b~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<h3 id="准备-Friends-模型数组"><a href="#准备-Friends-模型数组" class="headerlink" title="准备 Friends 模型数组"></a>准备 <code>Friends</code> 模型数组</h3><p>这里的数据源已经准备好了，我们只需要根据数据源创建出对应的模型。这个数组是好友数组,有需要的可以自行前往<a href="https://github.com/masterKing/wechatDemo">下载</a>。</p>
<p><img src="4f37de210e874b6b87611bb8b24940c6~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<h2 id="实现部分通讯录页面"><a href="#实现部分通讯录页面" class="headerlink" title="实现部分通讯录页面"></a>实现部分通讯录页面</h2><p>现在我们的视图和数据都已经准备好了。接下来就是直接使用了，我们之前在发现页面使用 ListView 的方式，没有使用 builder，是直接使用的方式，就跟我们在 iOS 中的 cellForRow 方法中每次创建一个新的 cell 的方式一样，cell 没有重复利用。而今天我们使用 builder 的这种方式，就是 cell 被放入缓存池中被重复利用的方式。使用 <code>ListView.builder()</code> 的方式，需要传入两个参数，一个是 itemCount 元素的个数。一个是 itemBuilder，类似于 cellForRowAtIndexPath 方法，需要我们创建 cell 并返回。完整的代码如下：</p>
<p><img src="3849d87dabcb414fbabcb46e04ffc067~tplv-k3u1fbpfcp-watermark.png" alt="image.png"></p>
<p>这里再说一下对 datas 进行排序的地方。这个方法 <code>initState()</code> 有一个 @override 修饰，意思就会重写父类的方法，而且这个方法应该是调用的比 build 要早的。这样才能保证展示数据的时候，数据是已经经过排序过的。而这个排序的方法，其实跟 iOS 中的 <code>sortedArrayUsingComparator:</code> 排序也非常的像，传入一个代码块的方式。所以有开发经验的同学，会发现真的有些东西，各个平台都是通用的，学起来也会更快更容易上手。最后 APP 的显示如下图：</p>
<div align="center">
<img src="b9f94392e09f449f8bb8f73879d2a793~tplv-k3u1fbpfcp-watermark.png">
</div>


]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>Error Domain=NSURLErrorDomain Code=-999 已取消</title>
    <url>/2018/04/03/Error-Domain-NSURLErrorDomain-Code-999-%E5%B7%B2%E5%8F%96%E6%B6%88/</url>
    <content><![CDATA[<p>今天遇到这么一个问题,在使用SDWebimage设置UIImageView的图片的时候,发现这个图片<br><code>http://img4.imgtn.bdimg.com/it/u=132600321,3123081067&amp;fm=27&amp;gp=0.jpg</code>怎么也设置不成功,后来调试一看发现<img src="https://raw.githubusercontent.com/masterKing/markDownPictures/master/Snip20180403_4.png">说是什么已取消,我是一脸懵逼啊,谁TM取消了啊???百思不得其解之后网上搜了一下;<br>嘿,还有人写了个总结<img src="https://raw.githubusercontent.com/masterKing/markDownPictures/master/Snip20180403_5.png"></p>
<p>然而看了上面的总结后发现貌似都没有关系…所以说这个总结也并不全面…后来想想用浏览器打开这个图片试试看,发现浏览器上能正常打开;这下我估计是请求图片的请求头有问题了;于是我将浏览器的请求头和从APP发出的请求头都列出来了;如下<br><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/master/Snip20180403_1.png"></p>
<p><em>浏览器上的请求头</em></p>
<p><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/master/Snip20180403_2.png"></p>
<p><em>使用Charles抓取APP发出的请求头</em></p>
<p>其实一下子也看不出什么东西出来,那就先从都有的请求头开始试吧,再将APP发出的请求头的User-Agent设置之后发现能够设置成功了…那么问题就可以这么解释了,这个图片所在的服务器会对请求的User-Agent进行判断,具体判断规则是怎样的那我就不得而知了;如果不符合它的规则那么就会请求失败,在上图Charles抓包的响应里面可以看到一段403 Forbidden的html代码,而在APP中,就是报的<code>Error Domain=NSURLErrorDomain Code=-999 &quot;已取消&quot;</code>的错误<br><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/master/Snip20180403_6.png"></p>
<p>其实吧,这个问题根本不重要,因为实际我根本不可能使用这个URL;重要的是解决问题的思路,你得学会一套方法去解决问题,而不是学会解决这个问题…</p>
]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenSSH</title>
    <url>/2024/10/27/OpenSSH/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>平时在使用 Mac 的过程中，经常会使用终端输入命令来执行一些操作。在越狱开发的过程中，同样需要在 iOS 系统上输入一些命令来执行一些任务。那么如何才能在 iOS 系统上输入命令呢，在 iOS 上安装一个终端命令行工具，然后在 iPhone 那小小的屏幕上用触摸屏输入命令吗？虽然说理论上和实际上都是可行的，但是通过手指触摸屏幕来输入命令的方式效率比较低，也不是很方便。这里还是推荐在 Mac 上远程登录到 iOS 系统，这样就可以使用 Mac 的键盘输入命令到 iOS 上去执行，更加方便，快捷。</p>
<h1 id="SSL、openSSL、SSH、openSSH"><a href="#SSL、openSSL、SSH、openSSH" class="headerlink" title="SSL、openSSL、SSH、openSSH"></a>SSL、openSSL、SSH、openSSH</h1><p>SSL（Secure Sockets Layer）是一种用于在计算机网络上进行安全通信的协议。SSL 最初由 Netscape 开发，后来发展为 TLS（Transport Layer Security）。SSL&#x2F;TLS 用于在客户端和服务器之间建立安全的加密连接，以保护敏感数据的传输，例如在网页浏览器和服务器之间的数据传输。</p>
<p>OpenSSL 是一个强大的、商业级的、功能齐全的开源工具包，它提供了一组库和命令行工具，用于处理 SSL&#x2F;TLS 协议和加密算法，是 SSL 协议的一款开源实现工具。OpenSSL 可以用于创建和管理数字证书、实现安全传输和通信，以及进行加密和解密等操作。它不仅支持 SSL&#x2F;TLS 协议，还支持多种加密算法和密码学功能。</p>
<p>SSH（Secure Shell）是一种用于安全远程登录和数据传输的网络协议。它为计算机之间的通信提供了加密和身份验证，以确保通信的机密性和完整性。SSH 使用公钥密码体制进行身份验证，并使用加密算法来保护数据的传输。</p>
<p>OpenSSH 是一个开源的 SSH 实现，它提供了 SSH 客户端和服务器的功能，用于安全远程登录、命令执行和文件传输。它包括客户端 ssh 和服务器 sshd、文件传输实用程序 scp 和 sftp 以及密钥生成工具 (ssh-keygen)、运行时密钥存储 (ssh-agent) 和许多支持程序。它是 Linux 和其他类 Unix 系统中最常见的 SSH 实现，也支持其他操作系统。</p>
<p>SSL 最早出现于 1994 年，用于 Web 浏览器和服务器之间的安全通信。OpenSSL 和 SSH 都起源于 1995 年，OpenSSL 是一个加密工具包，而 SSH 是用于安全远程登录和数据传输的协议。OpenSSH 是 SSH 协议的开源实现，起源于 1999 年，为 SSH 提供了广泛使用的实现。</p>
<p>OpenSSH 通常依赖于 OpenSSL。OpenSSH 使用 OpenSSL 库来实现加密和安全功能，包括加密通信、密钥生成、数字证书处理等。OpenSSL 提供了各种加密算法和密码学功能，使 OpenSSH 能够建立安全的 SSH 连接，并保护通信数据的机密性和完整性。在大多数情况下，安装 OpenSSH 时，系统会自动安装或链接到已经安装的 OpenSSL 库。这样，OpenSSH 就能够使用 OpenSSL 的功能来实现加密和安全性，而不必重新实现这些复杂的加密算法和协议。</p>
<p>因此，可以说 OpenSSH 依赖于 OpenSSL，OpenSSL 提供了 OpenSSH 所需的加密和安全功能，使得 OpenSSH 成为一种安全、可靠的远程登录和数据传输工具。这些安全协议和工具对于保护通信和数据安全至关重要。</p>
<h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><blockquote>
<p>⚠️注意：这里作者使用的是 checkra1n 越狱的 iOS 12.5.7 iPhone5s。</p>
</blockquote>
<p>对以上名词概念有了基本的了解之后，我们可以进行实践操作。如果感觉还是迷迷糊糊也不要紧，实践起来就会感觉简单多了。主要是对 OpenSSH 这个开源库提供的常用命令的使用。Mac 系统自带了这个工具所以不需要进行配置，而 iOS 系统上默认是没有安装这个工具的，包括越狱之后的 iOS 也没有，所以需要先下载安装这个工具。</p>
<p>安装过程很简单，如下图所示，在 Cydia 上搜索 OpenSSH 下载并按照提示进行安装就好了。</p>
<img src="32a8afae2fae413d8fa5984d89693e0f~tplv-k3u1fbpfcp-watermark.png" alt="IMG_0001.PNG" width="50%">

<p>安装好之后，就可以在 Mac 上远程登录到越狱 iOS 了。iOS 系统默认提供了两个用户，一个是 root 用户，是 iOS 中最高权限的用户，我们在逆向开发过程中基本都是使用这个用户。还有一个是 mobile 用户，是普通权限用户，iOS 平时进行 APP 安装，卸载基本都是使用这个用户，但是我们在逆向开发中很少或者基本不会使用到这个用户，这里有个了解就够了。</p>
<p>Cydia 首页有 OpenSSH 访问教程，这个文档详细的记载了如何从 Mac 远程登录到 iOS 设备上，并且也提供了修改默认密码的方法。建议英文不错的同学直接阅读这篇文档，不想看的就看我后面的介绍也可以。文档位置如下图所示</p>
<img src="41ffb7e4fae849d7846018c90bbbc177~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="IMG_0002.PNG" width="50%">

<h3 id="通过默认账号密码登录到-iPhone"><a href="#通过默认账号密码登录到-iPhone" class="headerlink" title="通过默认账号密码登录到 iPhone"></a>通过默认账号密码登录到 iPhone</h3><p>ssh 提供了两种登录到服务器的方式，第一种是使用账号和密码。第二种是免密码登录。下面先介绍第一种</p>
<ol>
<li>越狱 iPhone 在 Cydia 上安装 OpenSSH</li>
<li>确认 iPhone 和 Mac 电脑在同一个局域网下，在 Mac 打开终端，输入以下命令 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh root@iPhone的IP地址</span><br></pre></td></tr></table></figure>
 第一次连接会出现 <code>Are you sure you want to continue connecting (yes/no/[fingerprint])?</code> 提示，输入 <code>yes</code> 确认进行连接</li>
<li>输入默认的初始密码 <code>alpine</code> ,这里终端为了安全并不会显示密码的明文</li>
<li>之后就会看到终端切换到了 <code>iPhone:~ root#</code> 用户，代表成功登录到远程 iPhone 手机的 root 用户上了。这个时候，你在 Mac 终端输入的指令都会被发送到 iPhone 上，如下图<br> <img src="6b806498309a4589a7e39b35238b1616~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"><br> 如果你觉得还不过瘾，可以输入 <code>reboot</code> 命令，体会一下远程操纵手机的快乐（重启之后，你可能需要重新越狱一下 iPhone 了😶）</li>
<li>输入 <code>exit</code> 退出登录</li>
</ol>
<p>刚刚我们登录的是 <code>root</code> 用户。在 iOS 中，除了 <code>root</code> 用户，还有一个 <code>mobile</code> 用户。其中 <code>root</code> 用户是 iOS 中最高权限的用户。<code>mobile</code> 是普通权限用户，其实平时越狱调试过程中，很少会使用这个 <code>mobile</code> 用户，这里只是介绍一下。</p>
<p>能够成功登录 iPhone 之后，建议修改一下用户的默认密码，既然做逆向开发了，当然对安全也要注意一点。在登录 root 用户之后，</p>
<ul>
<li>输入 <code>passwd</code> 可以修改 root 用户的密码</li>
<li>输入 <code>passwd mobile</code> 可以修改 mobile 用户的密码。</li>
</ul>
<h3 id="通过免密码方式登录到-iPhone"><a href="#通过免密码方式登录到-iPhone" class="headerlink" title="通过免密码方式登录到 iPhone"></a>通过免密码方式登录到 iPhone</h3><p>OpenSSH 除了默认的账号密码登录的方式，还提供了免密码登录的方式。需要进一步完成一些配置才可以实现。服务器（在当前情况下，iPhone是服务器，Mac是客户端）的 ~&#x2F;.ssh 目录下需要添加一个 authorized_keys 文件，里面记录可以免密登录的设备的公钥信息。</p>
<p>当有客户端（Mac）登录的时候，服务器会查看 ~&#x2F;.ssh&#x2F;authorized_keys 文件中是否记录了当前登录的客户端的公钥信息，如果有就直接登录成功，没有就要求输入密码。所以我们要做的就是将 Mac 设备的公钥信息追加到 iPhone 的 authorized_keys 文件内容的最后面。追加是为了不影响其他的设备。完成这个操作需要先确保我们的 Mac 设备上已经有 ssh 生成的公钥文件。</p>
<p>打开 Mac 终端，输入 <code>ls ~/.ssh</code> 查看是否已经存在 <code>id_rsa.pub</code> 公钥文件，<code>.pub</code>就是公钥文件的后缀</p>
<p><img src="7b97ca3f9eee41048514e786d0909eea~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"></p>
<p>如果没有看到公钥文件，需要使用 <code>ssh-keygen</code> 命令生成该文件。按回车键接受默认选项，或者根据需要输入新的文件名和密码。这将生成一个公钥文件（id_rsa.pub）和一个私钥文件（id_rsa）。</p>
<p>使用 SSH 复制公钥到远程服务器。使用以下命令将本地计算机（Mac）上的公钥复制到远程服务器（iPhone）。请将<code>user</code>替换为您的远程服务器用户名，以及<code>remote_server</code>替换为服务器的域名或IP地址。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ssh-copy-id user@remote_server</span><br></pre></td></tr></table></figure>

<p><img src="72e2862e24124ebc9b8bc1d6122e7ff4~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"></p>
<p>在远程服务器（iPhone）上设置正确的权限。确保远程服务器上的<code>~/.ssh</code>文件夹权限设置为 700，并将<code>~/.ssh/authorized_keys</code>文件的权限设置为 600。这样可以确保SSH可以正确识别公钥并允许免密码登录。如下图所示：</p>
<p><img src="60c0d90bbd12440b9b15dea392525c10~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"></p>
<p>.ssh 文件夹前面的 <code>drwx------</code> 是 Linux 和类 Unix 系统中表示文件或目录权限的一种格式。在这个格式中，每一组由10个字符组成，代表文件或目录的不同权限。让我们逐个解释这些字符的含义：</p>
<ol>
<li><p>第一个字符：文件类型</p>
<ul>
<li><code>d</code> 表示目录（directory）</li>
<li><code>-</code> 表示普通文件</li>
<li><code>l</code> 表示符号链接（symlink）</li>
<li><code>b</code> 表示块设备文件（block device）</li>
<li><code>c</code> 表示字符设备文件（character device）</li>
<li><code>s</code> 表示套接字（socket）</li>
<li><code>p</code> 表示命名管道（named pipe）</li>
</ul>
</li>
<li><p>接下来的三个字符：文件所有者的权限</p>
<ul>
<li><code>r</code> 表示读权限（read）</li>
<li><code>w</code> 表示写权限（write）</li>
<li><code>x</code> 表示执行权限（execute）</li>
</ul>
</li>
<li><p>接下来的三个字符：文件所有者所在组的权限</p>
<ul>
<li><code>r</code> 表示读权限（read）</li>
<li><code>w</code> 表示写权限（write）</li>
<li><code>x</code> 表示执行权限（execute）</li>
</ul>
</li>
<li><p>最后三个字符：其他用户的权限</p>
<ul>
<li><code>r</code> 表示读权限（read）</li>
<li><code>w</code> 表示写权限（write）</li>
<li><code>x</code> 表示执行权限（execute）</li>
</ul>
</li>
</ol>
<p>所以，<code>drwx------</code> 表示这是一个目录，并且具有以下权限：</p>
<ul>
<li>文件所有者具有读、写和执行权限。</li>
<li>文件所有者所在组没有任何权限。</li>
<li>其他用户没有任何权限。</li>
</ul>
<p>后面 9 个字符分为三组，每组从左至右如果有对应的权限就是<code>421</code>相加起来就是 7 后面都是0。所以 .ssh 文件夹的权限是正确的值 700，如果不是 700 的使用 <code>chmod 700 .ssh</code> 进行提权。authorized_keys 文件的权限是 <code>rw</code> 就是 <code>420</code> 相加起来就是 6 。后面都是 0，所以 authorized_keys 的权限也是正确的值 600。同样如果不是 600，使用 <code>chmod 600 authorized_keys</code> 命令修改权限。</p>
<p>配置完成后，您现在可以使用 SSH 免密码登录到远程服务器（iPhone）。在 Mac 上，使用以下命令连接到远程服务器：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ssh root@10.10.20.155</span><br></pre></td></tr></table></figure>

<p>这将直接连接到远程服务器，而无需输入密码。</p>
<p><img src="866ac19a922d485083538ac1d4fbff8c~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"></p>
<h3 id="通过-USB-有线的方式登录到-iPhone"><a href="#通过-USB-有线的方式登录到-iPhone" class="headerlink" title="通过 USB 有线的方式登录到 iPhone"></a>通过 USB 有线的方式登录到 iPhone</h3><p>配置为免密码登录之后，还可以进一步使用 USB 有线连接的方式登录到手机。如果你经常使用 WiFi 这种方式远程登录调试就会发现偶尔会碰到指令输入，响应卡顿，反应慢的情况，这样的体验显然让人感到不爽。所以，在大部分情况下，更推荐使用 USB 有线连接登录到 iPhone 上，这样使用的过程中，就像在本地输入命令操作一样流畅。</p>
<p><code>iproxy</code> 是一个用于端口转发的命令行工具。它通常用于在 iOS 设备和计算机之间建立端口映射，从而将 iOS 设备上运行的服务暴露到计算机上。这对于开发者来说非常有用，因为可以通过本地计算机访问 iOS 设备上运行的服务，而无需将服务部署到公共网络上。</p>
<p><code>iproxy</code> 是 <code>usbmuxd</code> 的一部分，后者是一个用于连接和管理 iOS 设备的 USB 通信的守护进程。<code>usbmuxd</code> 允许通过 USB 连接与 iOS 设备进行通信，并且<code>iproxy</code> 则负责在本地计算机和iOS设备之间建立端口转发。</p>
<p>通常，您可以在命令行中使用 <code>iproxy</code> 命令来建立端口转发，例如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">iproxy local_port device_port</span><br></pre></td></tr></table></figure>

<p>其中，<code>local_port</code> 是本地计算机上的端口号，<code>device_port</code> 是 iOS 设备上的端口号。执行此命令后，iOS 设备上的服务将通过 <code>device_port</code> 映射到本地计算机上的 <code>local_port</code>。</p>
<p>请注意，使用 <code>iproxy</code> 需要先安装 <code>libusbmuxd</code> 包。在 macOS 上，您可以使用 Homebrew 来安装 <code>libusbmuxd</code>：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">brew install libusbmuxd</span><br></pre></td></tr></table></figure>

<p>安装好之后，就可以使用 iproxy 命令了，使用 iproxy 将本机 10010 端口和 USB 设备的 22 端口进行映射的命令如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">iproxy 10010 22</span><br></pre></td></tr></table></figure>

<p><img src="68273210a76642c5b692f47eadb5eeaa~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"></p>
<p>这里本机的端口 10010 可以设置为你想要的其他端口，但是不能是系统保留的端口（系统保留的端口有哪些，可以看<a href="https://baike.baidu.com/item/%E7%AB%AF%E5%8F%A3/103505?fr=ge_ala">百度</a>的介绍）。端口转发设置完成之后，这个终端就不要关闭，也不要管它了，新建另一个终端窗口进行 ssh 登录。此时，需要给 ssh 加上指定端口参数，命令如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ssh -p 10010 root@localhost</span><br></pre></td></tr></table></figure>

<p>同样第一次使用这种方式建立连接会给出提示，输入 <code>yes</code> 确认</p>
<p><img src="15c962453c7749b7bdb59c531c18f10e~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"></p>
<p>之后，在 iPhone 设备上输入命令调试时，再也不会遇到卡顿，慢，延迟的现象啦。玩得开心~</p>
<h1 id="ssh-常见问题"><a href="#ssh-常见问题" class="headerlink" title="ssh 常见问题"></a>ssh 常见问题</h1><p>有时候我们会对 iOS 设备重新越狱，重新越狱后的设备信息发生了变化，继续使用 ssh 登录是无法成功的。会给出如下信息：</p>
<p><img src="Xnip2024-09-15_04-35-31.jpg" alt="image.png"></p>
<p>在这种情况下，我们知道并不是发生了中间人攻击，而是 IP 地址跟设备不匹配了。所以可以使用 <code>ssh-keygen -R IP地址</code> 移除指定 IP 的设备信息。</p>
<p><img src="Xnip2024-09-15_04-39-25.jpg" alt="image.jpg"></p>
<p>再次使用 ssh 进行远程连接，就回到第一次远程登录那样了。</p>
<p><img src="Xnip2024-09-15_04-41-23.jpg" alt="image.jpg"></p>
<h1 id="在-palera1n-越狱的-iOS16-7-10-iPhone8plus-上使用-OpenSSH-遇到的问题"><a href="#在-palera1n-越狱的-iOS16-7-10-iPhone8plus-上使用-OpenSSH-遇到的问题" class="headerlink" title="在 palera1n 越狱的 iOS16.7.10 iPhone8plus 上使用 OpenSSH 遇到的问题"></a>在 palera1n 越狱的 iOS16.7.10 iPhone8plus 上使用 OpenSSH 遇到的问题</h1><p>使用 palera1n 越狱的时候，在安装 Sileo 的时候会提示设置一个终端密码，意味着默认的密码不再是 alpine 了。安装好 Sileo 之后，默认的软件源中已经有 openssh 了，所以直接在搜索框中搜索就好了。如下图所示：</p>
<img src="IMG_0005.PNG" alt="IMG_0003.PNG" width="50%">

<p>原本以为安装好 openssh 之后，可以像 iOS 12.5.7 那样顺利的远程连接。实际发现无法使用 root 用户登录，即使密码输入的是正确的。如下图：</p>
<p><img src="Xnip2024-09-15_05-02-16.jpg"></p>
<p>在 iOS 16 系统上，使用 palera1n 或者 dopamine 越狱成功之后，使用 ssh 的时候，默认的 root 用户出于安全考虑是禁用的，需要执行一次 <code>sudo passwd root</code> 修改 root 用户密码之后才可以使用，即使你修改的密码是一样的。 所以解决的方法有两种</p>
<ol>
<li>先用 mobile 用户登录，再执行 <code>sudo passwd root</code> 修改 root 密码之后，再次使用 root 用户登录。</li>
<li>在 iPhone 上下载终端应用程序，然后输入 <code>sudo passwd root</code> 修改 root 密码，之后再使用 root 用户登录。</li>
</ol>
<p>这里第一种方法我就不演示了，肯定没问题的。第 2 种方法需要用到 iOS 端的 Terminal App。我试过一些其他的终端程序无法成功运行。但是 <a href="https://mtac.app/repo/">MTAC’s Repo</a> 的 MTerminal 是可以成功在 iOS 16.7.10 上正常运行的。</p>
<p>在 iPhone 上运行 MTerminal 进行修改 root 用户密码操作如下图：</p>
<img src="IMG_0006.PNG" alt="IMG_0003.PNG" width="80%">

<p>修改成功后，再次使用 root 用户进行 ssh 远程连接到 iPhone 就和之前一模一样了，可以愉快的玩耍了。</p>
<p><img src="Xnip2024-09-15_05-17-44.jpg"></p>
]]></content>
      <categories>
        <category>iOS 逆向与安全</category>
      </categories>
  </entry>
  <entry>
    <title>Mach-O</title>
    <url>/2021/06/28/Mach-O/</url>
    <content><![CDATA[<h1 id="通用二进制-Universal-binary-文件"><a href="#通用二进制-Universal-binary-文件" class="headerlink" title="通用二进制(Universal binary)文件"></a>通用二进制(Universal binary)文件</h1><p>macOS 系统一路走来，支持的 CPU 及硬件平台都有了很大的变化，从早期的 PowerPC 平台，到后来的 x86，再到现在主流的 arm、x86-64 平台。软件开发人员为了做到不同硬件平台的兼容性，如果需要为每一个平台编译一个可执行文件，这将是非常繁琐的。</p>
<p>为了解决软件在多个硬件平台上的兼容性问题，苹果开发了一个通用的二进制文件格式（Universal Binary）。又称为胖二进制（Fat Binary），通用二进制文件中将多个支持不同 CPU 架构的二进制文件打包成一个文件，系统在加载运行该程序时，会根据通用二进制文件中提供的多个架构来与当前系统平台做匹配，运行适合当前系统的那个版本。</p>
<p>有人或许会好奇，不是讲 Mach-O 文件吗?怎么开始讲通用二进制文件，不要着急，看下面 <code>file</code> 命令查看 dyld 的打印，universal binary 前面不就是 Mach-O 吗</p>
<p>苹果自家系统中存在着很多通用二进制文件。比如 &#x2F;usr&#x2F;lib&#x2F;dyld，在终端中执行 <code>file</code> 命令可以查看它的信息：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> ~/ file /usr/lib/dyld</span><br><span class="line">/usr/lib/dyld： Mach-O universal binary with 3 architectures： [i386：Mach-O dynamic linker i386] [x86_64：Mach-O 64-bit dynamic linker x86_64] [arm64e]</span><br><span class="line">/usr/lib/dyld (<span class="keyword">for</span> architecture i386)：	Mach-O dynamic linker i386</span><br><span class="line">/usr/lib/dyld (<span class="keyword">for</span> architecture x86_64)：	Mach-O 64-bit dynamic linker x86_64</span><br><span class="line">/usr/lib/dyld (<span class="keyword">for</span> architecture arm64e)：	Mach-O 64-bit dynamic linker arm64e</span><br></pre></td></tr></table></figure>

<p>我们创建一个名为 test 的 iOS 工程，然后在 Xcode 中通过设置 Build Settings 中的 Architectures 来生成兼容各种架构的 APP</p>
<p><img src="84375053987242bda5a6f2207abf73f7~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"></p>
<p>编译之后，使用 <code>file</code> 命令查看生成的 ipa 包里的可执行文件</p>
<p><img src="6d1f4577c2fb4a3fa7b2266f44a20a08~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"></p>
<h2 id="lipo"><a href="#lipo" class="headerlink" title="lipo"></a>lipo</h2><p>系统提供了一个命令行工具<code>lipo</code>来操作通用二进制文件。它可以添加、提取、删除以及替换通用二进制文件中特定架构的二进制版本。</p>
<p>查看通用二进制文件信息： </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">lipo -info <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>提取 test 中 armv7 版本的二进制文件可以执行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">lipo <span class="built_in">test</span> -extract armv7 -output test_armv7</span><br></pre></td></tr></table></figure>

<p>提取 test 中 arm64 版本的二进制文件可以执行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">lipo <span class="built_in">test</span> -extract arm64 -output test_arm64</span><br></pre></td></tr></table></figure>

<p>合并 test_armv7 和 test_arm64：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">lipo -create test_armv7 test_arm64 -output test0</span><br></pre></td></tr></table></figure>

<p>删除 test 中 armv7s 版本的二进制文件可以执行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">lipo <span class="built_in">test</span> -remove armv7s -output test1</span><br></pre></td></tr></table></figure>

<p>通用二进制的”通用”不止针对可以直接运行的可以执行文件，系统中的动态库 .dylib 文件，静态库 .a 文件以及 Framework 等都可以是通用二进制文件，对它们同样也可以使用 <code>lipo</code> 命令来进行管理</p>
<p>接下来打开我们的 Xcode，按 command + shift + o 输入 mach-o&#x2F;fat.h 就可以看到对通用二进制文件格式的声明，从文件的命名和声明来看，将通用二进制叫作胖二进制或许更合适。胖二进制的头部定义如下：</p>
<p><img src="4240093e2e8f4c94aeeb393d242744b3~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="Snip20210627_130.png"></p>
<p><code>magic</code> 字段被定义为常量 FAT_MAGIC，它的取值根据架构是固定的，在 32 位架构上是 <strong>0xcafebabe</strong>，在 64 位架构上是 <strong>0xcafebabf</strong>，表示这是一个通用二进制文件。这里要说一下字节序，计算机硬件有两种储存数据的方式，分别为大端字节序，和小端字节序，大端字节序：高位字节在前，低位字节在后，这是人类读写数值的方法。小端字节序：低位字节在前，高位字节在后，是大多数机器读取数据的方式。下图所示的是同一个数字 01234567 在大端和小端下的存储方式<br></p>
<p><img src="93163b5b30e94d20b9164059e60e8b47~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="bg2016112201.gif"><br></p>
<p><code>nfat_arch</code> 字段表示后面的 Mach-O 文件的数量<br></p>
<p>每个通用二进制架构信息都使用 fat_arch 结构体表示，在 fat_header 结构体之后，紧接着的是一个或多个连续的 fat_arch 结构体，它的定义如下：</p>
<p><img src="b58efccc561546129423509f485bdd24~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"></p>
<p><code>cputype</code>字段是 cpu 说明符，类型是<code>cpu_type_t</code>，定义在&lt;mach&#x2F;machine.h&gt;文件，使用同样的 command + shift + o 然后输入头文件的方法可以打开 &lt;mach&#x2F;machine.h&gt; 文件，在 macOS 上取值一般为 <code>CPU_TYPE_I386</code> 或 <code>CPU_TYPE_X86_64</code>，在 iOS 平台上一般是 <code>CPU_TYPE_ARM</code> 或 <code>CPU_TYPE_ARM64</code> <br></p>
<p><code>cpu_subtype</code> 字段是机器说明符，类型是 <code>cpu_subtype_t</code>，同样定义在 &lt;mach&#x2F;machine.h&gt; 文件，macOS 上一般是 <code>CPU_SUBTYPE_I386_ALL</code>，<code>CPU_SUBTYPE_X86_64_ALL</code>，在 iOS 上一般则是 <code>CPU_SUBTYPE_ARM64_ALL</code>，<code>CPU_SUBTYPE_ARM_V7</code><br></p>
<p><code>offset</code> 字段指明了当前 Mach-O 数据相对于当前文件开头的偏移值<br></p>
<p><code>size</code> 字段指明了数据的大小<br></p>
<p><code>align</code> 字段指明了数据的内存对齐边界，取值必须是 2 的 n 次方，它确保了当前 cpu 架构的目标文件加载到内存中时，数据是经过内存优化对齐的</p>
<p>使用 <a href="https://github.com/gdbinit/MachOView">MachOView</a> 可以十分清楚的看到这些信息</p>
<p><img src="b729551411874ad489f96eec9739a78d~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"></p>
<p>在 fat_arch 结构体往下就是具体的 Mach-O 格式文件了，它的内容复杂得多，将在下一小节进行讨论。</p>
<h1 id="Mach-O"><a href="#Mach-O" class="headerlink" title="Mach-O"></a>Mach-O</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Mach-O（Mach Object file format）是一种文件格式，用于在 macOS、iOS 以及其他基于 Mach 内核的操作系统上保存可执行文件、目标文件、动态库和内核转储。Mach-O 格式是这些系统上程序的核心组成部分，存储了程序运行所需的所有信息，比如代码、数据、符号表、调试信息等。</p>
<p>熟悉 Mach-O 文件格式，有助于了解苹果软件底层运行机制，更好的掌握 dyld 加载 Mach-O 的步骤，为自己动手开发 Mach-O 相关的加解密工具打下基础</p>
<ol>
<li>MacOS 上的可执行文件是一种 Mach-O 文件(比如 ruby，phtyon…)，但不是所有可执行文件都是 Mach-O 文件</li>
<li>库文件是一种 Mach-O 文件，动态库 .dylib，静态库 .a，还有 Framework 都是一种 Mach-O 文件</li>
<li>.o 文件(clang 编译 c 源文件得到的)也叫目标文件夹，是一种 Mach-O 文件</li>
<li>.dsym 文件(符号表)也是一种 Mach-O 文件</li>
<li>dyld 是可执行文件，自然也是一种 Mach-O 文件</li>
</ol>
<p>以上这些都属于 Mach-O 文件，当然除了以上这五种，还有其他类型的 Mach-O 文件，只是这五种比较常见…其他还有八种，其他八种会在下面对 Mach-O 文件结构的介绍中提到</p>
<p>从上面 MachOView 的截图中可以看到，test 文件内有 4 种不同架构的文件，每种架构的文件都可以称它为一个 Mach-O 文件，而刚刚所讲的通用二进制文件就是一个文件如果包含了 1 种以上的 Mach-O 文件，那么他就是通用二进制文件</p>
<p>我们知道了 Mach-O 文件就是一堆有着特定结构的二进制数据，那么我们如何从这一堆的二进制里获取我们所需要的数据?如果做过股票行情 APP，IM 通讯底层 SDK 或者说使用过 socket 长连接对二进制数据进行过处理，发送，接收的同学，一定会知道对一堆的二进制如何有效的处理，提取我们想要的数据的。以我曾经做过的一款股票行情软件为例，里面就定义了大量的结构体类型，用结构体来对二进制数据进行解析，得到我们想要的数据，那么这个 Mach-O 文件的解析有没有对应的结构体呢?</p>
<p>当然有，在 Xcode 中使用 command + shift + o 搜索 mach-o&#x2F;loader.h 就会发现一堆的结构体，这些结构体都是系统用来解析 Mach-O 文件的，我们也能从中获取到不少的信息</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>一个典型的 Mach-O 文件结构如下图所示：</p>
<p><img src="62725ae27df140d393ceba29767885ec~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="v2-35f7008ce676b29129f9ec8bed3c464f_r.png"></p>
<p>从图中可以了解到一个 Mach-O 文件的结构包括 Header，Load commands 和 Data</p>
<ul>
<li><strong>Header</strong>：描述了 Mach-O 的 cpu 架构、文件类型以及加载命令等信息。</li>
<li><strong>Load commands</strong>：指定文件的逻辑结构和文件在虚拟内存中的布局。</li>
<li><strong>Data</strong>：原始段数据。每个段 Segment 都有一个或多个 Section，它们存放了具体的数据。</li>
</ul>
<h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><p>可以使用 <code>otool</code> 命令来查看 Mach-O 文件的头部信息</p>
<p><img src="b862cd3818584c92b5905e930bd73acb~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"></p>
<p>这个部分的定义，可以通过在 Xcode 中，按 command + shift + o 输入 mach-o&#x2F;loader.h 的方式找到</p>
<p><img src="332dbf14f8484f068963603e06ed1417~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"></p>
<ul>
<li><strong><code>magic</code></strong> 在截图中都能看到的宏定义，对 32 位架构的程序来说，它的值就是 <strong>0xfeedface</strong>，可以使用 <strong>MH_MAGIC</strong> 宏代替。对 64 位架构的程序来说，它的值就是 <strong>0xfeedfacf</strong>，对应的宏  <strong>MH_MAGIC_64</strong></li>
<li><strong><code>cputype</code></strong> 和上一节中所讲的 fat_header 结构体的含义完全相同</li>
<li><strong><code>cpusubtype</code></strong> 同上</li>
<li><strong><code>filetype</code></strong> 表示 Mach-O 文件的具体类型，值有下图所示的12种，常见的有 MH_EXECUTE(可执行文件)，MH_DYLIB(动态库)，MH_DYLINKER(动态连接器)，MH_DSYM(符号表文件)<br><img src="55f1fff26073490d9d7309002b2ba726~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"></li>
<li><strong><code>ncmds</code></strong> load commands 的数量</li>
<li><strong><code>sizeofcmds</code></strong> 所有 load commands 的占的字节数</li>
<li><strong><code>flags</code></strong> 标记，值比较多，最好去头文件中查看详细说明</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>	MH_NOUNDEFS	0x1		<span class="comment">/* the object file has no undefined</span></span></span><br><span class="line"><span class="comment"><span class="meta">					   references */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MH_INCRLINK	0x2		<span class="comment">/* the object file is the output of an</span></span></span><br><span class="line"><span class="comment"><span class="meta">					   incremental link against a base file</span></span></span><br><span class="line"><span class="comment"><span class="meta">					   and can&#x27;t be link edited again */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MH_DYLDLINK	0x4		<span class="comment">/* the object file is input for the</span></span></span><br><span class="line"><span class="comment"><span class="meta">					   dynamic linker and can&#x27;t be staticly</span></span></span><br><span class="line"><span class="comment"><span class="meta">					   link edited again */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MH_BINDATLOAD	0x8		<span class="comment">/* the object file&#x27;s undefined</span></span></span><br><span class="line"><span class="comment"><span class="meta">					   references are bound by the dynamic</span></span></span><br><span class="line"><span class="comment"><span class="meta">					   linker when loaded. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MH_PREBOUND	0x10		<span class="comment">/* the file has its dynamic undefined</span></span></span><br><span class="line"><span class="comment"><span class="meta">					   references prebound. */</span></span></span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>reserved</code></strong> 这个字段只在 64 位架构的 Mach-O 文件中才有，目前它的取值系统保留</li>
</ul>
<p>使用 MachOView 查看 Header 的信息</p>
<p><img src="0ed044569438410193a72cb6d98e4728~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"></p>
<h3 id="Load-Commands"><a href="#Load-Commands" class="headerlink" title="Load Commands"></a>Load Commands</h3><p>Load Commands 描述的是文件的加载信息，加载信息有很多，加载的段、符号表、动态库信息等都在 Load Commands 中取到。这个部分信息还是比较有用的，我们可以从这里获取到符号表和字符串表的偏移量，下文中会有详细的解释。</p>
<p>Load Commands 加载命令紧跟在 Header 之后，所有加载命令的前两个字段必须是 cmd 和 cmdsize，cmd 字段用该命令类型的常量填充，头文件中定义了许多的宏用于该字段，每个命令类型都有一个特定的结构。cmdsize 字段是以字节为单位的特定加载命令结构的大小，再加上它后面作为加载命令一部分的任何内容（即节结构、字符串等）要前进到下一个加载命令，可以将 cmdsize 加上当前加载命令的偏移量</p>
<p><img src="b99f9142f65a44e1845403893446cba0~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"></p>
<p>cmd 字段的取值有目前有 50 多种，太多了就不全部粘贴出来了…</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LC_REQ_DYLD 0x80000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Constants for the cmd field of all load commands， the type */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LC_SEGMENT	0x1	<span class="comment">/* segment of this file to be mapped */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LC_SYMTAB	0x2	<span class="comment">/* link-edit stab symbol table info */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LC_SYMSEG	0x3	<span class="comment">/* link-edit gdb symbol table info (obsolete) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LC_THREAD	0x4	<span class="comment">/* thread */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LC_UNIXTHREAD	0x5	<span class="comment">/* unix thread (includes a stack) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LC_LOADFVMLIB	0x6	<span class="comment">/* load a specified fixed VM shared library */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LC_IDFVMLIB	0x7	<span class="comment">/* fixed VM shared library identification */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LC_IDENT	0x8	<span class="comment">/* object identification info (obsolete) */</span></span></span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>所有的这些加载命令由系统内核加载器直接使用，或由动态链接器处理。其中几个常见的加载命令有<code>LC_LOAD_DYLIB</code>、<code>LC_SEGMENT</code>、<code>LC_MAIN</code>、<code>LC_CODE_SIGNATURE</code>、<code>LC_ENCRYPTION_INFO</code>等，下面介绍其中的几个</p>
<h4 id="LC-LOAD-DYLIB"><a href="#LC-LOAD-DYLIB" class="headerlink" title="LC_LOAD_DYLIB"></a>LC_LOAD_DYLIB</h4><p><code>LC_LOAD_DYLIB</code>：表示这是一个需要动态加载的链接库。它使用 dylib_command 结构体表示。定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dylib_command</span> &#123;</span></span><br><span class="line">	<span class="type">uint32_t</span>	cmd。		<span class="comment">/* LC_ID_DYLIB， LC_LOAD_&#123;，WEAK_&#125;DYLIB，</span></span><br><span class="line"><span class="comment">					   LC_REEXPORT_DYLIB */</span></span><br><span class="line">	<span class="type">uint32_t</span>	cmdsize。	<span class="comment">/* includes pathname string */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dylib</span>	<span class="title">dylib</span>。		/* <span class="title">the</span> <span class="title">library</span> <span class="title">identification</span> */</span></span><br><span class="line"><span class="class">&#125;。</span></span><br></pre></td></tr></table></figure>

<p>当 cmd 类型是<code>LC_ID_DYLIB</code>，<code>LC_LOAD_DYLIB</code>，<code>LC_LOAD_WEAK_DYLIB</code>，<code>LC_REEXPORT_DYLIB</code>时，都使用 dylib_command 结构体表示。其中 dylib 结构体存储要加载的动态库的具体信息如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dylib</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">lc_str</span>  <span class="title">name</span>。			/* <span class="title">library</span>&#x27;<span class="title">s</span> <span class="title">path</span> <span class="title">name</span> */</span></span><br><span class="line"><span class="class">    <span class="title">uint32_t</span> <span class="title">timestamp</span>。			/* <span class="title">library</span>&#x27;<span class="title">s</span> <span class="title">build</span> <span class="title">time</span> <span class="title">stamp</span> */</span></span><br><span class="line"><span class="class">    <span class="title">uint32_t</span> <span class="title">current_version</span>。		/* <span class="title">library</span>&#x27;<span class="title">s</span> <span class="title">current</span> <span class="title">version</span> <span class="title">number</span> */</span></span><br><span class="line"><span class="class">    <span class="title">uint32_t</span> <span class="title">compatibility_version</span>。	/* <span class="title">library</span>&#x27;<span class="title">s</span> <span class="title">compatibility</span> <span class="title">vers</span> <span class="title">number</span>*/</span></span><br><span class="line"><span class="class">&#125;。</span></span><br></pre></td></tr></table></figure>

<p><code>name</code> 字段是链接库的完整路径，动态链接器在加载库时，通用此路径来进行加载它。<br><br><code>timestamp</code>字段描述了库构建时的时间戳<br><br><code>current_version</code>与<code>compatibility_version</code>指明了前当版本与兼容的版本号<br></p>
<p>如果你看了我的上一篇文章 <a href="https://juejin.cn/post/6977384497000448030">代码注入</a> 里面提到了 <code>yololib</code>，这个工具的原理基本就是利用这条 <code>LC_LOAD_DYLIB</code> 加载命令的相关信息实现的</p>
<h4 id="LC-MAIN"><a href="#LC-MAIN" class="headerlink" title="LC_MAIN"></a>LC_MAIN</h4><p><code>LC_MAIN</code>：此加载命令记录了可执行文件的主函数 main() 的位置。它使用 entry_point_command 结构体表示。定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">entry_point_command</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span>  cmd。	<span class="comment">/* LC_MAIN only used in MH_EXECUTE filetypes */</span></span><br><span class="line">    <span class="type">uint32_t</span>  cmdsize。	<span class="comment">/* 24 */</span></span><br><span class="line">    <span class="type">uint64_t</span>  entryoff。	<span class="comment">/* file (__TEXT) offset of main() */</span></span><br><span class="line">    <span class="type">uint64_t</span>  stacksize。<span class="comment">/* if not zero， initial stack size */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>entryoff 字段中就指定了 main() 函数的文件偏移。stacksize 指定了初始的堆栈大小。</p>
<h4 id="LC-SEGMENT-LC-SEGMENT-64"><a href="#LC-SEGMENT-LC-SEGMENT-64" class="headerlink" title="LC_SEGMENT&#x2F;LC_SEGMENT_64"></a>LC_SEGMENT&#x2F;LC_SEGMENT_64</h4><p><code>LC_SEGMENT/LC_SEGMENT_64</code>：段加载命令，描述了 32 位或 64 位 Mach-O 文件的段的信息，常见的段有 <code>__PAGEZERO</code>，<code>__TEXT</code>，<code>__DATA</code>，<code>__LINKEDIT</code>。</p>
<p><code>__PAGEZERO</code> 是一个空段，它位于文件起始段的位置</p>
<p><code>__TEXT</code> 和 <code>__DATA</code> 分别是文本段和数据段，分别存储了代码信息和数据信息</p>
<p><code>__LINKEDIT</code> 是链接信息段。段(segment)又可以细分为section，每个段(segment)可以包含多个section</p>
<p>段使用 segment_command 结构体来表示，它的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segment_command</span> &#123;</span> <span class="comment">/* for 32-bit architectures */</span></span><br><span class="line">	<span class="type">uint32_t</span>	cmd。		<span class="comment">/* LC_SEGMENT */</span></span><br><span class="line">	<span class="type">uint32_t</span>	cmdsize。	<span class="comment">/* includes sizeof section structs */</span></span><br><span class="line">	<span class="type">char</span>		segname[<span class="number">16</span>]。	<span class="comment">/* segment name */</span></span><br><span class="line">	<span class="type">uint32_t</span>	vmaddr。		<span class="comment">/* memory address of this segment */</span></span><br><span class="line">	<span class="type">uint32_t</span>	vmsize。		<span class="comment">/* memory size of this segment */</span></span><br><span class="line">	<span class="type">uint32_t</span>	fileoff。	<span class="comment">/* file offset of this segment */</span></span><br><span class="line">	<span class="type">uint32_t</span>	filesize。	<span class="comment">/* amount to map from the file */</span></span><br><span class="line">	<span class="type">vm_prot_t</span>	maxprot。	<span class="comment">/* maximum VM protection */</span></span><br><span class="line">	<span class="type">vm_prot_t</span>	initprot。	<span class="comment">/* initial VM protection */</span></span><br><span class="line">	<span class="type">uint32_t</span>	nsects。		<span class="comment">/* number of sections in segment */</span></span><br><span class="line">	<span class="type">uint32_t</span>	flags。		<span class="comment">/* flags */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>segname</code> 字段是一个 16 字节大小的空间，用来存储段的名称，比如__TEXT…<br></p>
<p><code>vmaddr</code> 字段指明了段要加载的虚拟内存地址<br></p>
<p><code>vmsize</code> 字段指明了段所占的虚拟内存的大小<br></p>
<p><code>fileoff</code> 字段指明了段数据所在文件中偏移地址<br></p>
<p><code>filesize</code> 字段指明了段数据实际的大小<br></p>
<p><code>maxprot</code> 字段指明了页面所需要的最高内存保护<br></p>
<p><code>initprot</code> 字段指明了页面初始的内存保护<br></p>
<p><code>nsects</code> 字段指明了段所包含的节区（section）<br></p>
<p><code>flags</code> 字段指明了段的标志信息<br></p>
<p>还有很多 Load Commands 加载命令，这里就不一一介绍了…贴一张图大概了解下</p>
<p><img src="f3f71180aa9843feb445011970d67772~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"></p>
<p>使用 MachOView 查看 Load Commands 的内容</p>
<p><img src="38e722b0733e401a8945d2a834f32ae8~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"></p>
<h3 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h3><p>数据区，除了 Header 和 Load Commands 外所有的原始数据。Load Commands 是对数据的汇总概括，而数据区则是真实的数据。Load Commands 与数据区的关系就像书的目录与章节的关系，如图所示，Segment 为 __TEXT 的段里，显示有 8 个 section，每个 section 具体的内容就在 Data 区里了</p>
<p><img src="dddae1f46a564c6c9158b4fcd32635dc~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"></p>
<p>接下里介绍几个比较重要的 section</p>
<h4 id="TEXT，-text"><a href="#TEXT，-text" class="headerlink" title="(__TEXT，__text)"></a>(<code>__TEXT</code>，<code>__text</code>)</h4><p>这里存放的是汇编后的代码，当我们进行编译时，每个 .m 文件会经过预编译-&gt;编译-&gt;汇编形成 .o 文件，称之为目标文件。汇编后，所有的代码会形成汇编指令存储在 .o 文件的 (<code>__TEXT，__text</code>) 区（（<code>__DATA，__data</code>）也是类似）。</p>
<p>链接后，所有的 .o 文件会合并成一个文件，所有 .o 文件的 (<code>__TEXT，__text</code>) 数据都会按链接顺序存放到应用文件的 (<code>__TEXT，__text</code>) 中。</p>
<p><img src="570ed1a3f60c4e93a1daabd21ffedbea~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"></p>
<h4 id="TEXT，-objc-methname"><a href="#TEXT，-objc-methname" class="headerlink" title="(__TEXT，__objc_methname)"></a>(<code>__TEXT，__objc_methname</code>)</h4><p>这里存放了项目里，所有我们用 Objective-C 写的方法名</p>
<p><img src="2057b7ec64464ce3837bc7f885881527~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"></p>
<h4 id="TEXT，-objc-classname"><a href="#TEXT，-objc-classname" class="headerlink" title="(__TEXT，__objc_classname)"></a>(<code>__TEXT，__objc_classname</code>)</h4><p>这里存放了项目里所有 Objective-C 类的名字</p>
<p><img src="9ab7d736e345420ab2cdd8076c08057d~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"></p>
<p>class-dump 工具能够解析出每个类的方法，属性，成员变量，应该就是来自上面两个 section 的数据了，当然这只是我的猜测，具体怎么实现的就要去看 class-dump 的源码了</p>
<h4 id="Symbol-Table"><a href="#Symbol-Table" class="headerlink" title="Symbol Table"></a>Symbol Table</h4><p>符号表，这个是重点中的重点，符号表是将地址和符号联系起来的桥梁。符号表并不能直接存储符号，而是存储符号位于字符串表的位置。</p>
<p><img src="2721f7baa7b941e6be63421636ef4764~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"></p>
<h4 id="String-Table"><a href="#String-Table" class="headerlink" title="String Table"></a>String Table</h4><p>字符串表所有的变量名、函数名等，都以字符串的形式存储在字符串表中。</p>
<p><img src="47a85d63ea9a43c29531012586a964c2~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"></p>
<h4 id="Dynamic-Symbol-Table"><a href="#Dynamic-Symbol-Table" class="headerlink" title="Dynamic Symbol Table"></a>Dynamic Symbol Table</h4><p>动态符号表存储的是动态库函数位于符号表的偏移信息。(<code>__DATA</code>，<code>__la_symbol_ptr</code>) section 可以从动态符号表中获取到该 section 位于符号表的索引数组。动态符号表并不存储符号信息，而是存储其位于符号表的偏移信息。Fishhook 源码看起来比较复杂主要是因为 hook 的是动态链接的函数，索引和链接关系比较绕。但是我们自己编写的 C 函数不是动态链接的，而是在编译链接后代码指令就存储在文件内部的函数，因此不会用到动态符号表也就无法 hook。</p>
<p><img src="322f3e1e56ed40309400dc4a483e79d5~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"></p>
<p>当然，关于 Mach-O 文件的知识远不止这么点，但是要完全讲清楚里面的所有内容，那估计不是这么一篇文章能够讲的清楚的，至少也得是一本书了，我也只是网上收集到的一些资料，自己写了篇总结而已<br></p>
<h1 id="Mach-O-的应用"><a href="#Mach-O-的应用" class="headerlink" title="Mach-O 的应用"></a>Mach-O 的应用</h1><p><a href="https://github.com/nygard/class-dump">class-dump</a> 这个工具就是通过对 Mach-O 文件的解析得到的结果。</p>
]]></content>
      <categories>
        <category>iOS 逆向与安全</category>
      </categories>
  </entry>
  <entry>
    <title>SDWebimage设置图片时URL不变，但图片改变的解决办法</title>
    <url>/2018/07/17/SDWebimage%E8%AE%BE%E7%BD%AE%E5%9B%BE%E7%89%87%E6%97%B6URL%E4%B8%8D%E5%8F%98%EF%BC%8C%E4%BD%86%E5%9B%BE%E7%89%87%E6%94%B9%E5%8F%98%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<p>本篇文章转载自<a href="https://blog.csdn.net/xumugui007/article/details/51605546">SDWebImage支持URL不变时更新图片内容</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SDWebImage在iOS项目中是一个很常用的开源库，而且众所周知的是，它是基于URL作为Key来实现图片缓存机制的。在90%左右的情况下，</span><br><span class="line">图片与URL是一一对应的，即使服务器修改了图片也会相应的变更URL。但是在少数情况下，服务器修改了图片后不会变更相应的URL，也就是</span><br><span class="line">说图片本身的内容变了然而它的URL没有变化，那么按照对SDWebImage的常规使用方法的话，客户端肯定更新不到同一URL对应到服务器已变</span><br><span class="line">更的图片内容。</span><br></pre></td></tr></table></figure>

<p>基于这一现象，我们来进行分析。</p>
<p>客户端第一次请求图片时，Charles抓包得知response header里有一个名为Last-Modified、数据是时间戳的键值对。</p>
<p>客户端第二次及以后请求图片时，通过Charles抓包发现，服务器返回304 not modified状态，说明服务器在接收客户端请求后通过某种判断逻辑得出结论：“客户端已缓存的图片与服务器图片都是最新的”，那么服务器如何判断的呢？</p>
<p>通过查阅HTTP协议相关的资料得知，与服务器返回的Last-Modified相对应的request header里可以加一个名为If-Modified-Since的key，value即是服务器回传的服务端图片最后被修改的时间，第一次图片请求时If-Modified-Since的值为空，第二次及以后的客户端请求会把服务器回传的Last-Modified值作为If-Modified-Since的值传给服务器，这样服务器每次接收到图片请求时就将If-Modified-Since与Last-Modified进行比较，如果客户端图片已陈旧那么返回状态码200、Last-Modified、图片内容，客户端存储Last-Modified和图片；如果客户端图片是最新的那么返回304 Not Modified、不会返回Last-Modified、图片内容。</p>
<p>关于服务器的比较逻辑，需要强调一下。</p>
<p>经查资料得知，Apache比较时是看If-Modified-Since之后有没有更新图片，Nginx比较时是看If-Modified-Since与Last-Modified是否相等，所以对于Apache服务器环境客户端每次都要严格的存储服务器回传的Last-Modified以便下次请求时作为If-Modified-Since的值传给服务器，对于Nginx服务器环境客户端不必存储服务器回传的Last-Modified，每次请求时只需将图片自身的fileModificationDate作为If-Modified-Since的值传服务器即可。在实际开发中，如果遇到明明传了If-Modified-Since、服务器图片也变更了、但是客户端却请求不到最新的图片的情况时，那么就需要查看一下服务器对这两个时间戳的比较逻辑。</p>
<p>那么，现在我们可以回到SDWebImage上来了。通过查看SDWebImageDownloader的源码得知，它开放了一个headersFilter的block，意在让开发者可以对所有图片请求追加一些额外的header，这正合我意。那么我们就可以在诸如AppDelegate didFinishLaunching的地方追加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SDWebImageDownloader *imgDownloader = SDWebImageManager.sharedManager.imageDownloader;</span><br><span class="line">imgDownloader.headersFilter  = ^NSDictionary *(NSURL *url, NSDictionary *headers) &#123;</span><br><span class="line"> </span><br><span class="line">    NSFileManager *fm = [[NSFileManager alloc] init];</span><br><span class="line">    NSString *imgKey = [SDWebImageManager.sharedManager cacheKeyForURL:url];</span><br><span class="line">    NSString *imgPath = [SDWebImageManager.sharedManager.imageCache defaultCachePathForKey:imgKey];</span><br><span class="line">    NSDictionary *fileAttr = [fm attributesOfItemAtPath:imgPath error:nil];</span><br><span class="line"> </span><br><span class="line">    NSMutableDictionary *mutableHeaders = [headers mutableCopy];</span><br><span class="line"> </span><br><span class="line">    NSDate *lastModifiedDate = nil;</span><br><span class="line"> </span><br><span class="line">    if (fileAttr.count &gt; 0) &#123;</span><br><span class="line">        if (fileAttr.count &gt; 0) &#123;</span><br><span class="line">            lastModifiedDate = (NSDate *)fileAttr[NSFileModificationDate];</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];</span><br><span class="line">    formatter.timeZone = [NSTimeZone timeZoneWithAbbreviation:@&quot;GMT&quot;];</span><br><span class="line">    formatter.locale = [[NSLocale alloc] initWithLocaleIdentifier:@&quot;en_US&quot;];</span><br><span class="line">    formatter.dateFormat = @&quot;EEE, dd MMM yyyy HH:mm:ss z&quot;;</span><br><span class="line"> </span><br><span class="line">    NSString *lastModifiedStr = [formatter stringFromDate:lastModifiedDate];</span><br><span class="line">    lastModifiedStr = lastModifiedStr.length &gt; 0 ? lastModifiedStr : @&quot;&quot;;</span><br><span class="line">    [mutableHeaders setValue:lastModifiedStr forKey:@&quot;If-Modified-Since&quot;];</span><br><span class="line"> </span><br><span class="line">    return mutableHeaders;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后，加载图片的地方以前怎么写还是怎么写，但别忘了Option是SDWebImageRefreshCached</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSURL *imgURL = [NSURL URLWithString:@&quot;http://handy-img-storage.b0.upaiyun.com/3.jpg&quot;];</span><br><span class="line">[[self imageView] sd_setImageWithURL:imgURL</span><br><span class="line">                    placeholderImage:nil</span><br><span class="line">                             options:SDWebImageRefreshCached];</span><br></pre></td></tr></table></figure>

<p>经测试，服务器只修改图片不变更URL的时候，客户端也可以更新到最新的图片。</p>
<p>从以上第一段代码内容可以看出我采用的是与ngix服务器比较逻辑对应的代码，BTW:我测试的服务器是又拍云，说明又拍云的比较逻辑是等与不等的关系判断，不是大小关系的判断。</p>
<p>这里顺便说一下，如果服务器的环境是类似于Apache的比较逻辑时，客户端可以把Last-Modified存放在图片的名称上(这需要修改SDWebImage源码，不建议)，或者用一个plist文件存放图片key名称与时间的对应关系(这个不用修改源码)。</p>
<p>OK，到此这次的主题已得到完美解决。</p>
]]></content>
      <tags>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title>Cycript</title>
    <url>/2024/10/27/Cycript/</url>
    <content><![CDATA[<h1 id="什么是-Cycript"><a href="#什么是-Cycript" class="headerlink" title="什么是 Cycript"></a>什么是 Cycript</h1><p>Cycript 是一种用于 iOS 操作系统的脚本语言，同时也是该语言的解释器（一般来说不需要编译的脚本语言都会提供它对应的解释器，比如 Python、JavaScript、Ruby、PHP 等），Cycript 是 JavaScript，Objective-C++ 等语言的混合物这意味着它能理解 JavaScript，Objective-C++ 甚至是 Objective-C 语法，但是需要注意的是 Cycript 主要支持 JavaScript 的语法，对前端开发人员比较友好，而由于 Swift 吸收了 JavaScript 等其他各种语言的优点，所以 Cycript 中也能看到 Swift 的影子，Cycript 对 Objective-C 语法并不是完全支持，比如 Objective-C 创建一个 UIView 的代码是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UIView *view = [[UIView alloc] init];</span><br></pre></td></tr></table></figure>

<p>而在 Cycript 中，&#x3D; 号后面的部分可以识别，而前面的部分不支持，需要使用 JavaScript 的语法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var view = [[UIView alloc] init]</span><br></pre></td></tr></table></figure>

<p>作者最初设计的目的好像就是希望通过 JavaScript 学习使用 Cocoa&#x2F;UIKit 。</p>
<p>Cycript 同时还是一个可交互的控制台工具。主要用于在运行时与 iOS 应用程序远程交互、调试和分析。它允许开发人员以一种动态的方式与 iOS 应用程序进行通信，甚至可以修改其行为。这一点对比 lldb 来说更加灵活，lldb 调试时总是需要中断当前调试的进程，当然 lldb 有它的优势是可以下断点调试，可以手动砸壳 APP，是苹果的亲儿子等等优势。</p>
<p>Cycript 在越狱设备上广泛使用，越狱 iOS 安装 cycript 工具之后可以在越狱 iOS 上直接调试大部分 APP。在非越狱的设备上也是可以使用的，虽然一般在非越狱开发都会使用苹果 Xcode 提供的 lldb 调试，cycript 提供了一个 cycript.framework 库可以用来集成到 APP 中实现非越狱环境下的远程（通过 IP 地址和端口号）调试，这一点就非常酷炫了，想想在非越狱环境下你在远程调试分析一个 APP。有些人认为 Cycript 只能用于界面分析。。。其实 Cycript 远比大多数人想象的要强大…</p>
<p>cycript 的源码位于 <a href="https://git.saurik.com/cycript.git">https://git.saurik.com/cycript.git</a> 感兴趣的同学们可以下载下来看看。</p>
<p>Cycript 的主要特点包括：</p>
<ol>
<li><p><strong>动态注入和交互：</strong> Cycript 可以将脚本注入到运行中的应用程序进程中，从而允许开发人员在应用程序的上下文中执行代码。这使得开发人员可以检查应用程序的内部状态、调用其方法并进行交互。</p>
</li>
<li><p><strong>访问对象和类：</strong> Cycript 允许开发人员直接访问运行中的对象和类的属性、方法和成员变量。这对于调试和分析应用程序非常有用，尤其是当源代码不可用或者难以访问时。</p>
</li>
<li><p><strong>修改应用程序行为：</strong> 使用 Cycript，开发人员可以在运行时修改应用程序的行为，例如重定义方法、改变变量值等。这使得开发人员可以实时测试和验证不同的应用程序行为。</p>
</li>
<li><p><strong>探索界面元素：</strong> Cycript 还可以用于查找和探索应用程序的界面元素（例如视图和控件），以便更好地了解应用程序的界面层次结构和布局。</p>
</li>
</ol>
<h1 id="非越狱环境使用-cycript"><a href="#非越狱环境使用-cycript" class="headerlink" title="非越狱环境使用 cycript"></a>非越狱环境使用 cycript</h1><p>在非越狱环境下使用有两个前提条件</p>
<ul>
<li>Cycript.framework 将这个框架集成到你的 iOS 项目中。</li>
<li>cycript 终端命令行工具。在 MacOS 的终端运行这个工具，加上 IP 地址和端口就能和 iOS 项目建立联系，实现调试探索 APP 了。</li>
</ul>
<h2 id="iOS-项目集成-Cycript-framework"><a href="#iOS-项目集成-Cycript-framework" class="headerlink" title="iOS 项目集成 Cycript.framework"></a>iOS 项目集成 Cycript.framework</h2><p>从官网 <a href="http://www.cycript.org/">http://www.cycript.org/</a> 下载最新版本的 cycript 可能无法直接使用，会报一些库找不到的错误，没关系我们一步步解决。本人使用的是 MacOS ventura 13.5 的系统，进入下载文件夹后解压刚刚下载好的 cycript_0.9.594.zip 压缩包后如下图所示：</p>
<p><img src="5d087a97d00a42d992bc0ee0082bf942~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"></p>
<p>其中 Cycript.ios 里面就有我们需要的 Cycript.framework 文件。黑色的 cycript 就是我们需要的终端命令行工具。先将 Cycript.framework 集成到我们的 iOS 项目中，我这里新建了一个 CycriptDemo 的空工程。</p>
<p><img src="d32b77ce2d2d43d797261dc7c2cfd036~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"></p>
<p>Cycript.framework 集成成功之后，我们在 APP 启动的时候添加一点代码，如下图：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;AppDelegate.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;Cycript/Cycript.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AppDelegate</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AppDelegate</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="type">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</span><br><span class="line">    <span class="comment">// Override point for customization after application launch.</span></span><br><span class="line">    CYListenServer(<span class="number">3335</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>这里填写的端口号，只要是可用的端口号就都可以。可用的端口范围取决于您的操作系统和网络设置。通常情况下，TCP&#x2F;IP 协议定义的端口号范围是从 0 到 65535。然而，其中一些端口已经被标准协议用于特定的服务（例如，端口 80 用于 HTTP，端口 443 用于 HTTPS 等），因此不是所有的端口都可以随意使用。</p>
<p>通常情况下，非特权用户（普通用户）可以使用的端口号范围是从 1024 到 49151，而特权用户（如管理员或超级用户）可以使用从 0 到 1023 的端口号。</p>
<p>现在，运行 CycriptDemo 将 APP 安装到未越狱的 iPhone 上。不出意外应该会遇到以下报错</p>
<p><img src="f3c93ab5caf7421eaf931148a2e1f7b2~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"></p>
<p>让人感到有点莫名其妙，不过开发过程中有报错并不可怕，按照报错的提示去解决就好了，可怕的是没有任何提示而又没有按照预期的运行这才是最可怕的，根本无从下手解决。在做安全防护的时候也是如此，不要给出任何明显的提示或者报错，这样会让攻击者更容易就找到破解的办法。</p>
<p>回到之前解压的 cycript_0.9.594 目录中，在 Cycript.lib 目录下存在 libcycript.db 文件，将它拖进项目中就可以解决。</p>
<p><img src="4a5430071b9d4819a57fc505b1728485~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"></p>
<p>到这里 iOS 端的准备工作就差不多做好了。。。</p>
<h2 id="解决-cycript-命令行工具依赖库问题"><a href="#解决-cycript-命令行工具依赖库问题" class="headerlink" title="解决 cycript 命令行工具依赖库问题"></a>解决 cycript 命令行工具依赖库问题</h2><p>下一步我们需要解决 cycript 终端命令行工具的依赖库找不到的问题，让 cycript 成功运行起来。首先打开终端进入到刚刚解压的 cycript_0.9.594 文件夹，输入 <code>./cycript</code> 执行在我的环境下给出如下报错：</p>
<p><img src="754d10ee59f64fd490c8d83144604021~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"></p>
<p>意思就是找不到 Python.framework 库，这是由于 MacOS 在版本 macOS 11.0（Big Sur）中正式移除了预装的 Python 2.7。cycript 在 2016 年之后就停止更新了，在无法更新 cycript 的依赖库的情况下（或许可以通过反汇编修改二进制，但目前看没有这个必要），我们只能想办法在上述指定位置安装 Python 库，也不一定要使用指定 Python2.7 版本，因为在软件开发领域新版本的程序一般都会向下兼容老版本的程序，就是说如果一个软件的依赖库找不到了，可以使用较新的版本的库直接替换，如果用更老的版本就可能出现问题，这个做开发的应该都知道但没想到。</p>
<p>所以我准备将我电脑上已经安装好的 Python3.11 版本的 Python.framework 复制到到上述路径并修改一下版本号就行了。如果你的电脑上本来就没有安装 Python 库，那就使用 <code>brew install python</code> 安装好了。安装好之后同样找到 Python.framework 复制到上述路径。</p>
<p>使用 <code>brew list python</code> 发现我的电脑已安装的 Python 版本</p>
<p><img src="17e012e78782425d8ff0fe2291f1946e~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="Xnip2023-08-18_21-53-47.png"></p>
<p>由于 MacOS 的 SIP 限制，&#x2F;System&#x2F;… 路径是只读的，在 MacOS 13.5 上即使禁用了 SIP 也依旧无法修改。也许有办法只是目前我还没有找到可以修改的方法。<br>好在给出的错误提示，指出了多个路径都找不到同一个库，于是猜测到这么多路径中只要有一个路径存在指定库就可以，其中最后一个路径 &#x2F;Library 目录是可以修改的，于是尝试将 Python3.11 版本的 Python.framework 复制到 &#x2F;Library&#x2F;Framework&#x2F; 目录下，并将 Versions 目录下的 3.11 重命名为 2.7 之后就解决了上面这个报错。最终结果就是按照上面报错的最后一个路径 <code>/Library/Frameworks/Python.framework/Versions/2.7/Python</code> 配置好一个 Python 可执行文件。</p>
<p>继续输入 <code>./cycript</code> 看是否能运行成功。没有那么顺利，在我的环境下，又报了以下错误：</p>
<p><img src="680174bfc5e94845a56322e7cb17577d~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"></p>
<p>解决方式跟刚刚类似，找到电脑上已安装的 libruby.dylib 库，将它复制到了 <code>/usr/local/lib/</code> 目录下，这个 <code>/usr/local/</code> 目录一般就是用来存放用户级别的库的。如果你的电脑上没有安装 ruby 库，那就先安装好，再复制到 <code>/usr/local/lib/</code> 目录下，并重命名为 <code>libruby.2.0.0.dylib</code>。</p>
<p>继续输入 <code>./cycript</code> 发现进入了交互环境了，表示依赖库都配置好了，如果你还有其他报错，继续按照刚刚的方法解决就行了。</p>
<p><img src="3f6beead8c5648efb1ce1d5d1e539a3c~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"></p>
<h2 id="开始远程调试"><a href="#开始远程调试" class="headerlink" title="开始远程调试"></a>开始远程调试</h2><p>接下来找到 iPhone 所在网络的 IP 地址，确认 iPhone 和 Mac 需要在同一局域网内。打开刚刚安装的 CycriptDemo ，然后在 Mac 终端输入 <code>./cycript -r IP:端口号</code> 如果不出意外（除非你新建的项目 bundleIdentifier 是之前使用过的，并且之前该 APP 已经成功安装运行并允许使用无线局域网），那么大概率是无法连接成功的，会报以下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*** _syscall(connect(socket_, info-&gt;ai_addr, info-&gt;ai_addrlen)):../Console.cpp(306):CYSocketRemote [errno=60]</span><br></pre></td></tr></table></figure>

<p>这是 socket 连接返回的错误码，错误码 “errno&#x3D;60” 对应的是 “ETIMEDOUT”，这是基于一般的网络编程经验和标准的错误码定义而来。这是因为我们新创建工程并没有获取到使用无线局域网络的用户授权，也就是很多 APP 第一次启动访问网络时会弹出的授权提示，如下图所示。所以在我们新创建的 CycriptDemo 工程中还需要添加一些访问网络的代码，让系统自动弹出这个授权弹窗并选择无线局域网与蜂窝网络、或者仅限无线局域网都可以。如果你不小心点击了不允许，可以在 iOS 的设置 APP 中找到你当前的 APP -&gt; 无线数据，重新选择。</p>
<p align="center"><img src="b82b620ff8304730881adfcb4796f159~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="IMG_0106.PNG" width="30%"></p>

<p>添加如下访问网络连接的代码再次启动时就会弹出上面的授权弹窗。如果你是集成到已经获取了授权的项目中，可以不用添加这行代码。获取到用户授权之后可以删除掉。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</span><br><span class="line">    <span class="comment">// Override point for customization after application launch.</span></span><br><span class="line">    [[[<span class="built_in">NSURLSession</span> sharedSession] dataTaskWithRequest:[<span class="built_in">NSURLRequest</span> requestWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@&quot;https://httpbin.org/get&quot;</span>]]] resume];</span><br><span class="line">    CYListenServer(<span class="number">3335</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成功获取使用无线局域网授权之后，我们再次尝试连接，应该可以看到以下结果：</p>
<p><img src="f0f3c160f2c44b3a80889a1592ec35a5~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"></p>
<p>有时候还有可能会遇到以下错误</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">*** _syscall(connect(socket_, info-&gt;ai_addr, info-&gt;ai_addrlen)):../Console.cpp(306):CYSocketRemote [errno=61]</span><br></pre></td></tr></table></figure>

<p>这个一般是 APP 还没有启动成功，服务还没开始运行，或者在后台被杀掉导致的。确保 APP 在前台并且启动完成之后再连接就好了。</p>
<p>连接成功进入交互环境后可以输入 <code>UIApp</code> 获取应用实例对象，这是 Cycript 对 iOS 中的 <code>[UIApplication sharedApplication]</code> 的包装，也可以直接输入 <code>[UIApplication sharedApplication]</code> 获取，就像在 lldb 调试那样。退出交互环境使用键盘快捷键 control + D ,或者输入 <code>?exit</code> 。</p>
<p><img src="d6407aa127834c71937f55b80ccef1ba~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"></p>
<h1 id="越狱环境下使用-cycript"><a href="#越狱环境下使用-cycript" class="headerlink" title="越狱环境下使用 cycript"></a>越狱环境下使用 cycript</h1><p>在越狱环境下使用 cycript 就没有那么麻烦了，只需要在 Cydia 或者 Sileo 中搜索并安装 Cycript 。安装好之后通过 ssh 远程连接到越狱 iPhone 之后，直接可以输入 <code>cycript -p pid或进程名称</code> 就可以开始调试了。可以使用 <code>ps -A | grep app</code> 获取到 pid 或者 进程名称。如果提示没有 <code>ps</code> 这个命令，需要安装 adv-cmds 工具，不过一般在安装 Cycript 的时候应该已经一并安装了。</p>
<p>关于如何通过 ssh 远程连接到越狱 iPhone 可以看我之前的文章 <a href="https://juejin.cn/post/7262982452768145465">从 Mac 远程登录到 iPhone</a>。</p>
<p>在越狱设备上输入 <code>ps -A | grep app</code> 获取 pid 或 进程名称的结果如下：</p>
<p><img src="177b4189f70b4a058ed8ac4b0743ebe6~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"></p>
<p>前面的数字就是 pid ，路径最后就是进程名称。我们以红框中的 SpringBoard APP 为例，附加到这个 APP 中。这个 APP 就是我们 iOS 用户最熟悉的陌生人了，天天看的最多，用的最多的手机桌面。输入以下代码会看到手机桌面显示出了弹窗</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">iPhone:~ root# cycript -p SpringBoard</span><br><span class="line">cy# var alertvc = [UIAlertController alertControllerWithTitle:@<span class="string">&quot;title&quot;</span> message:@<span class="string">&quot;message&quot;</span> preferredStyle:1]</span><br><span class="line"><span class="comment">#&quot;&lt;UIAlertController: 0x101b66a00&gt;&quot;</span></span><br><span class="line">cy# [alertvc addAction:[UIAlertAction actionWithTitle:@<span class="string">&quot;confirm&quot;</span> style:0 handler:nil]]</span><br><span class="line">cy# [alertvc addAction:[UIAlertAction actionWithTitle:@<span class="string">&quot;cancel&quot;</span> style:1 handler:nil]]</span><br><span class="line">cy# [UIApp.keyWindow.rootViewController presentViewController:alertvc animated:YES completion:nil]</span><br><span class="line">cy# </span><br></pre></td></tr></table></figure>

<p>iPhone 桌面显示如图：</p>
<p align="center"><img src="08b3e4241c4b40f08027510a234cfc8d~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="IMG_0004.PNG" width="50%"></p>

<h1 id="cycript-基础用法"><a href="#cycript-基础用法" class="headerlink" title="cycript 基础用法"></a>cycript 基础用法</h1><p>好了，到这里不论你是在非越狱环境还是在越狱环境应该都可以进入 Cycript 与 APP 的交互环境了。现在先了解一下 Cycript 提供的一些基础用法，就用刚刚在非越狱环境使用 Cycript 中创建的 CycriptDemo 进行演示。打开手机上的 CycriptDemo APP，然后打开终端 cd 进入 cycript_0.9.594 目录下并进行连接（有需要可以配置成环境变量方便全局使用），如下图：</p>
<p><img src="7d2dedd81252481882bf270369a201d7~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"></p>
<h2 id="创建最简单的-UIView-并添加到-keyWindow-上"><a href="#创建最简单的-UIView-并添加到-keyWindow-上" class="headerlink" title="创建最简单的 UIView 并添加到 keyWindow 上"></a>创建最简单的 UIView 并添加到 keyWindow 上</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cy# var rect = new (struct CGRect)</span><br><span class="line">&amp;&#123;origin:&#123;x:new Number&#123;&#125;,y:new Number&#123;&#125;&#125;,size:&#123;width:new Number&#123;&#125;,height:new Number&#123;&#125;&#125;&#125;</span><br><span class="line">cy# rect-&gt;origin.x = 50</span><br><span class="line">50</span><br><span class="line">cy# rect-&gt;origin.y = 100</span><br><span class="line">100</span><br><span class="line">cy# rect-&gt;size.width = 100</span><br><span class="line">100</span><br><span class="line">cy# rect-&gt;size.height = 60</span><br><span class="line">60</span><br><span class="line">cy# var greenView = [[UIView alloc] initWithFrame:*rect]</span><br><span class="line"><span class="comment">#&quot;&lt;UIView: 0x10450a690; frame = (50 100; 100 60); layer = &lt;CALayer: 0x282ddbcc0&gt;&gt;&quot;</span></span><br><span class="line">cy# greenView.backgroundColor = [UIColor greenColor]</span><br><span class="line"><span class="comment">#&quot;UIExtendedSRGBColorSpace 0 1 0 1&quot;</span></span><br><span class="line">cy# [UIApp.keyWindow addSubview:greenView]</span><br></pre></td></tr></table></figure>
<p>APP 的显示如图：</p>
<p align="center"><img src="dada50269c8546cfb5dfe1c6f5d6d672~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="IMG_0110.PNG" width="30%"></p>

<p>可以看到，Cycript 中的 CGRect 用起来并不是特别方便，而且默认也没有提供对 CGRectMake() 函数的支持，这一点我也不是太明白。不过我们可以定义自己的函数，实现同样的功能。代码如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cy# <span class="keyword">function</span> CGPointMake(x, y) &#123; <span class="built_in">return</span> &#123;0 : x, 1 : y&#125; &#125;</span><br><span class="line">cy# <span class="keyword">function</span> CGSizeMake(w, h) &#123; <span class="built_in">return</span> &#123;0 : w, 1 : h&#125; &#125;</span><br><span class="line">cy# <span class="keyword">function</span> CGRectMake(x, y, w, h) &#123; <span class="built_in">return</span> &#123;0 : CGPointMake(x, y), 1 : CGSizeMake(w, h) &#125; &#125;</span><br><span class="line">cy# var rect2 = CGRectMake(160, 100, 100, 60)</span><br><span class="line">&#123;0:&#123;0:160,1:100&#125;,1:&#123;0:100,1:60&#125;&#125;</span><br><span class="line">cy# var redView = [[UIView alloc] initWithFrame:rect2]</span><br><span class="line"><span class="comment">#&quot;&lt;UIView: 0x107610070; frame = (160 100; 100 60); layer = &lt;CALayer: 0x282de62e0&gt;&gt;&quot;</span></span><br><span class="line">cy# redView.backgroundColor = [UIColor redColor]</span><br><span class="line"><span class="comment">#&quot;UIExtendedSRGBColorSpace 1 0 0 1&quot;</span></span><br><span class="line">cy# [UIApp.keyWindow addSubview:redView]</span><br></pre></td></tr></table></figure>

<p>我们定义了 CGPointMake(),CGSizeMake(),CGRectMake() 三个函数实现了类似的功能。并使用 CGRectMake() 创建了一个新的红色视图 <code>redView</code> 并添加到了 <code>keyWindow</code> 上。</p>
<p>APP 显示如下：</p>
<p align="center"><img src="1dba7f979c874e118ab93d948e241b1f~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="IMG_0111.PNG" width="30%"></p>

<h2 id="内存地址"><a href="#内存地址" class="headerlink" title="#内存地址"></a>#内存地址</h2><p>使用 #内存地址 获取内存地址所在的对象。比如我们刚刚创建的 redView ，这是我们创建的变量所以可以直接使用 redView 变量获取对象，但是在平时调试过程中我们很少会创建变量，而是通过打印输出很多对象的内存地址，通过 # 符号获取这个对象。使用 #内存地址 修改我们刚刚创建的 redView 的大小的代码如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#0x107610070.backgroundColor = [UIColor orangeColor]</span></span><br></pre></td></tr></table></figure>

<p>可以看到我们的 redView 的背景色被修改为橙色了。</p>
<h2 id="对象"><a href="#对象" class="headerlink" title="*对象"></a>*对象</h2><p>使用 * 号加对象，会打印出对象的所有成员变量名和对应的值。以我们刚刚修改的 redView 为例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cy# *#0x107610070</span><br><span class="line">&#123;isa:UIView,_responderFlags:@error,_constraintsExceptingSubviewAutoresizingConstraints:null,_cachedTraitCollection:#<span class="string">&quot;&lt;UITraitCollection: 0x2814e8620; UserInterfaceIdiom = Phone, DisplayScale = 3, DisplayGamut = P3, HorizontalSizeClass = Compact, VerticalSizeClass = Regular, UserInterfaceStyle = Light, UserInterfaceLayoutDirection = LTR, ForceTouchCapability = Available, PreferredContentSizeCategory = XS, AccessibilityContrast = Normal, UserInterfaceLevel = Base&gt;&quot;</span>,_animationInfo:null,_layer:#<span class="string">&quot;&lt;CALayer: 0x282de62e0&gt;&quot;</span>,_layerRetained:null,_gestureRecognizers:null,_window:#<span class="string">&quot;&lt;UIWindow: 0x1045057e0; frame = (0 0; 414 896); gestureRecognizers = &lt;NSArray: 0x28238d770&gt;; layer = &lt;UIWindowLayer: 0x28238d860&gt;&gt;&quot;</span>,_subviewCache:@[],_viewDelegate:null,_cachedScreenScale:new Number&#123;&#125;,_layoutEngineWidth:new Number&#123;&#125;,_viewFlags:@error,_unsatisfiableConstraintsLoggingSuspensionCount:0,_pseudo_id:8,_retainCount:new Number&#123;&#125;,_draggingSourceDelegate:null,_tintAdjustmentDimmingCount:0,_layoutSubviewsCount:0,_imminentLayoutSubviewsCount:0,_countOfFocusedAncestorTrackingViewsInSubtree:0,_layoutMarginsGuide:null,_minXVariable:null,_minYVariable:null,_boundsWidthVariable:null,_boundsHeightVariable:null,_layoutEngine:null,_stashedLayoutVariableObservations:null,_internalConstraints:null,_safeAreaLayoutGuide:null,_keyboardLayoutGuide:null,_readableContentGuide:null,__preferedContentsFormat:new Number&#123;&#125;,__lastNotifiedTraitCollection:#<span class="string">&quot;&lt;UITraitCollection: 0x2814e41c0; UserInterfaceIdiom = Phone, DisplayScale = 3, DisplayGamut = P3, HorizontalSizeClass = Compact, VerticalSizeClass = Regular, UserInterfaceStyle = Light, UserInterfaceLayoutDirection = LTR, ForceTouchCapability = Available, PreferredContentSizeCategory = XS, AccessibilityContrast = Normal, UserInterfaceLevel = Base&gt;&quot;</span>,__alignmentRectOriginCache:null,_rawLayoutMargins:&#123;top:new Number&#123;&#125;,left:new Number&#123;&#125;,bottom:new Number&#123;&#125;,right:new Number&#123;&#125;&#125;,_inferredLayoutMargins:&#123;top:new Number&#123;&#125;,left:new Number&#123;&#125;,bottom:new Number&#123;&#125;,right:new Number&#123;&#125;&#125;,_safeAreaInsets:&#123;top:new Number&#123;&#125;,left:new Number&#123;&#125;,bottom:new Number&#123;&#125;,right:new Number&#123;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="递归打印层级结构"><a href="#递归打印层级结构" class="headerlink" title="递归打印层级结构"></a>递归打印层级结构</h2><h3 id="递归打印视图层级结构"><a href="#递归打印视图层级结构" class="headerlink" title="递归打印视图层级结构"></a>递归打印视图层级结构</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cy# UIApp.keyWindow.recursiveDescription()</span><br><span class="line">@<span class="string">&quot;&lt;UIWindow: 0x1045057e0; frame = (0 0; 414 896); gestureRecognizers = &lt;NSArray: 0x28238d770&gt;; layer = &lt;UIWindowLayer: 0x28238d860&gt;&gt;\n   | &lt;UITransitionView: 0x1076068d0; frame = (0 0; 414 896); autoresize = W+H; layer = &lt;CALayer: 0x282ddd500&gt;&gt;\n   |    | &lt;UIDropShadowView: 0x102e07170; frame = (0 0; 414 896); autoresize = W+H; layer = &lt;CALayer: 0x282dc4900&gt;&gt;\n   |    |    | &lt;UIView: 0x107607070; frame = (0 0; 414 896); autoresize = W+H; layer = &lt;CALayer: 0x282ddd480&gt;&gt;\n   | &lt;UIView: 0x10450a690; frame = (50 100; 100 60); layer = &lt;CALayer: 0x282ddbcc0&gt;&gt;\n   | &lt;UIView: 0x107610070; frame = (160 100; 100 60); layer = &lt;CALayer: 0x282de62e0&gt;&gt;&quot;</span></span><br></pre></td></tr></table></figure>

<p>会发现打印的字符串中有很多 \n 符号并没有真正的换行。可以使用 <code>toString()</code> 函数让 \n 真正的换行</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cy# UIApp.keyWindow.recursiveDescription().toString()</span><br><span class="line">`&lt;UIWindow: 0x1045057e0; frame = (0 0; 414 896); gestureRecognizers = &lt;NSArray: 0x28238d770&gt;; layer = &lt;UIWindowLayer: 0x28238d860&gt;&gt;</span><br><span class="line">   | &lt;UITransitionView: 0x1076068d0; frame = (0 0; 414 896); autoresize = W+H; layer = &lt;CALayer: 0x282ddd500&gt;&gt;</span><br><span class="line">   |    | &lt;UIDropShadowView: 0x102e07170; frame = (0 0; 414 896); autoresize = W+H; layer = &lt;CALayer: 0x282dc4900&gt;&gt;</span><br><span class="line">   |    |    | &lt;UIView: 0x107607070; frame = (0 0; 414 896); autoresize = W+H; layer = &lt;CALayer: 0x282ddd480&gt;&gt;</span><br><span class="line">   | &lt;UIView: 0x10450a690; frame = (50 100; 100 60); layer = &lt;CALayer: 0x282ddbcc0&gt;&gt;</span><br><span class="line">   | &lt;UIView: 0x107610070; frame = (160 100; 100 60); layer = &lt;CALayer: 0x282de62e0&gt;&gt;`</span><br></pre></td></tr></table></figure>

<p>这样看起来就清晰多了。</p>
<h3 id="递归打印根控制器的层级结构"><a href="#递归打印根控制器的层级结构" class="headerlink" title="递归打印根控制器的层级结构"></a>递归打印根控制器的层级结构</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cy# UIApp.keyWindow.rootViewController._printHierarchy().toString()</span><br><span class="line"><span class="string">&quot;&lt;ViewController 0x1045049f0&gt;, state: appeared, view: &lt;UIView 0x107607070&gt;&quot;</span></span><br></pre></td></tr></table></figure>

<p>由于我们的 CycriptDemo APP 中只有一个根视图控制器，所以只能看到这样的打印。</p>
<h3 id="递归打印自动布局信息"><a href="#递归打印自动布局信息" class="headerlink" title="递归打印自动布局信息"></a>递归打印自动布局信息</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cy# UIApp.keyWindow._autolayoutTrace().toString()</span><br><span class="line">`</span><br><span class="line">UIWindow:0x1045057e0</span><br><span class="line">|   UITransitionView:0x1076068d0</span><br><span class="line">|   |   UIDropShadowView:0x102e07170</span><br><span class="line">|   |   |   UIView:0x107607070</span><br><span class="line">|   UIView:0x10450a690</span><br><span class="line">|   UIView:0x107610070</span><br><span class="line"></span><br><span class="line">Legend:</span><br><span class="line">\t* - is laid out with auto layout</span><br><span class="line">\t+ - is laid out manually, but is represented <span class="keyword">in</span> the layout engine because translatesAutoresizingMaskIntoConstraints = YES</span><br><span class="line">\t\u2022 - layout engine host`</span><br></pre></td></tr></table></figure>
<p>这里出现了一些不该显示的 \t 字符，猜测可能是解析字符串的时候出了点问题，在打印对象的 <code>_ivarDescription</code> 和 <code>_methodDescription</code> 的时候也会出现。可惜 Cycript 的作者已经停止更新了。。。</p>
<h2 id="choose-查询类或其子类的实例对象"><a href="#choose-查询类或其子类的实例对象" class="headerlink" title="choose 查询类或其子类的实例对象"></a>choose 查询类或其子类的实例对象</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cy# choose(UIView)</span><br><span class="line">[#<span class="string">&quot;&lt;UIWindow: 0x1045057e0; frame = (0 0; 414 896); gestureRecognizers = &lt;NSArray: 0x28238d770&gt;; layer = &lt;UIWindowLayer: 0x28238d860&gt;&gt;&quot;</span>,#<span class="string">&quot;&lt;UIDimmingView: 0x1045065a0; frame = (0 0; 0 0); opaque = NO; gestureRecognizers = &lt;NSArray: 0x28238d230&gt;; layer = &lt;CALayer: 0x282dd9ea0&gt;&gt;&quot;</span>,#<span class="string">&quot;&lt;UIDimmingView: 0x1045070e0; frame = (0 0; 0 0); opaque = NO; gestureRecognizers = &lt;NSArray: 0x28238d1a0&gt;; layer = &lt;CALayer: 0x282dda100&gt;&gt;&quot;</span>,#<span class="string">&quot;&lt;UIView: 0x10450a690; frame = (50 100; 100 60); layer = &lt;CALayer: 0x282ddbcc0&gt;&gt;&quot;</span>,#<span class="string">&quot;&lt;UITransitionView: 0x1076068d0; frame = (0 0; 414 896); autoresize = W+H; layer = &lt;CALayer: 0x282ddd500&gt;&gt;&quot;</span>,#<span class="string">&quot;&lt;UIView: 0x107607070; frame = (0 0; 414 896); autoresize = W+H; layer = &lt;CALayer: 0x282ddd480&gt;&gt;&quot;</span>,#<span class="string">&quot;&lt;UIView: 0x107610070; frame = (160 100; 100 60); layer = &lt;CALayer: 0x282de62e0&gt;&gt;&quot;</span>,#<span class="string">&quot;&lt;UIDropShadowView: 0x102e07170; frame = (0 0; 414 896); autoresize = W+H; layer = &lt;CALayer: 0x282dc4900&gt;&gt;&quot;</span>]</span><br></pre></td></tr></table></figure>

<h2 id="tab-键自动补全代码"><a href="#tab-键自动补全代码" class="headerlink" title="tab 键自动补全代码"></a>tab 键自动补全代码</h2><p>在输入代码的时候，可以尝试使用 tab 键进行自动补全或者代码提示。在输入的代码足够分析出正确的完整代码的时候按一次 tab 键会自动补全，在输入的代码不足以分析出正确的代码的时候按两下 tab 键会给出所有可能得提示，在输入的代码完全不够解析的时候终端会有声音提醒，再多输入几个字符试试就好了。我们以对象的私有方法或成员变量（以下划线_开头）为例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cy# choose(UIView)</span><br><span class="line">[#<span class="string">&quot;&lt;UIWindow: 0x1045057e0; frame = (0 0; 414 896); gestureRecognizers = &lt;NSArray: 0x28238d770&gt;; layer = &lt;UIWindowLayer: 0x28238d860&gt;&gt;&quot;</span>,#<span class="string">&quot;&lt;UIDimmingView: 0x1045065a0; frame = (0 0; 0 0); opaque = NO; gestureRecognizers = &lt;NSArray: 0x28238d230&gt;; layer = &lt;CALayer: 0x282dd9ea0&gt;&gt;&quot;</span>,#<span class="string">&quot;&lt;UIDimmingView: 0x1045070e0; frame = (0 0; 0 0); opaque = NO; gestureRecognizers = &lt;NSArray: 0x28238d1a0&gt;; layer = &lt;CALayer: 0x282dda100&gt;&gt;&quot;</span>,#<span class="string">&quot;&lt;UIView: 0x10450a690; frame = (50 100; 100 60); layer = &lt;CALayer: 0x282ddbcc0&gt;&gt;&quot;</span>,#<span class="string">&quot;&lt;UITransitionView: 0x1076068d0; frame = (0 0; 414 896); autoresize = W+H; layer = &lt;CALayer: 0x282ddd500&gt;&gt;&quot;</span>,#<span class="string">&quot;&lt;UIView: 0x107607070; frame = (0 0; 414 896); autoresize = W+H; layer = &lt;CALayer: 0x282ddd480&gt;&gt;&quot;</span>,#<span class="string">&quot;&lt;UIView: 0x107610070; frame = (160 100; 100 60); layer = &lt;CALayer: 0x282de62e0&gt;&gt;&quot;</span>,#<span class="string">&quot;&lt;UIDropShadowView: 0x102e07170; frame = (0 0; 414 896); autoresize = W+H; layer = &lt;CALayer: 0x282dc4900&gt;&gt;&quot;</span>]</span><br><span class="line">cy# <span class="comment">#0x107610070._</span></span><br><span class="line">Display all 501 possibilities? (y or n)</span><br><span class="line">cy# <span class="comment">#0x107610070._lay</span></span><br><span class="line">_layer()                                           _layoutEngine                                      _layoutEngineRelativeAlignmentRectOriginIsValid()  _layoutRect()</span><br><span class="line">_layoutDebuggingIdentifier                         _layoutEngineCreateIfNecessary()                   _layoutHeightDependsOnWidth                        _layoutVariablesWithAmbiguousValue()</span><br><span class="line">_layoutDebuggingTitle()                            _layoutEngineHostConstraints()                     _layoutMarginsGuideIfExists()</span><br><span class="line">_layoutDescriptionIfDifferentFromDefault()         _layoutEngineIfAvailable()                         _layoutMarginsGuideIgnoresSystemMinimumMargins</span><br><span class="line">cy# <span class="comment">#0x107610070._lay</span></span><br></pre></td></tr></table></figure>

<p>首先使用 choose 查询 UIView 或其子类的实例对象。选取其中的一个 #0x107610070 ，输入 ._ 之后会出现提示显示所有 501 个可能的结果？输入 y 表示显示，n 不显示。501 个结果太多了，我选择不显示，继续输入 lay 之后按两下 tab 键由于数量不是很多于是直接将所有可能得结果都显示出来了。这个功能我只能说🐂🍺</p>
<h1 id="cycript-高级用法"><a href="#cycript-高级用法" class="headerlink" title="cycript 高级用法"></a>cycript 高级用法</h1><p>我们刚刚创建了几个变量和函数，这些变量和函数都的确处于进程的内存当中，但是当 APP 进程被杀掉重新启动的时候，我们创建的变量和函数就都会消失。如果我们需要在每次进入交互环境的时候，重新辛辛苦苦编写重复的函数代码那可就太折磨人了。</p>
<p>Cycript 作者早就想到了这样的情况，所以它支持从文件加载自己的脚本。首先编写好 Cycript 的 .cy 文件，我们 tool.cy 为例。.cy 文件使用的是 JavaScript 语法，所以没有相关背景知识的开发人员编写起来可能会感到很困难。没错，作者本人就是如此，为了实现了一个函数并让它按照预期运行就经受了一番痛苦的折磨。。。这里参考了 MJ 大神的一些<a href="https://github.com/CoderMJLee/mjcript">源码</a>，并对其中个人感觉不是很实用的进行了删减，对一些做了修改。同时对 @import 方式进行了优化，在 @import 的时候，会给出 .cy 文件中的一些关键信息，这样就不用去记忆一些变量和函数名。同时也省去了需要使用文件名.才能调用函数的麻烦（这里是参考了 AloneMonkey 大神的写法）。</p>
<h2 id="编写-cy-文件"><a href="#编写-cy-文件" class="headerlink" title="编写 .cy 文件"></a>编写 .cy 文件</h2><p>tool.cy 文件源码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params">tool</span>) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> t = tool.<span class="property">constants</span> = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="title class_">MJPointMake</span> = <span class="keyword">function</span>(<span class="params">x, y</span>) &#123; </span><br><span class="line">		<span class="keyword">return</span> &#123;<span class="number">0</span> : x, <span class="number">1</span> : y&#125;; </span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="title class_">MJSizeMake</span> = <span class="keyword">function</span>(<span class="params">w, h</span>) &#123; </span><br><span class="line">		<span class="keyword">return</span> &#123;<span class="number">0</span> : w, <span class="number">1</span> : h&#125;; </span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="title class_">MJRectMake</span> = <span class="keyword">function</span>(<span class="params">x, y, w, h</span>) &#123; </span><br><span class="line">		<span class="keyword">return</span> &#123;<span class="number">0</span> : <span class="title class_">MJPointMake</span>(x, y), <span class="number">1</span> : <span class="title class_">MJSizeMake</span>(w, h)&#125;; </span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回 bundleIdentifier</span></span><br><span class="line">	t.<span class="property">bundleId</span> = [[<span class="title class_">NSBundle</span> mainBundle] bundleIdentifier];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回安装包路径</span></span><br><span class="line">	t.<span class="property">bundlePath</span> = [[<span class="title class_">NSBundle</span> mainBundle] bundlePath];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> _MJFrontVc = <span class="keyword">function</span>(<span class="params">vc</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (vc.<span class="property">presentedViewController</span>) &#123;</span><br><span class="line">        	<span class="keyword">return</span> <span class="title function_">_MJFrontVc</span>(vc.<span class="property">presentedViewController</span>);</span><br><span class="line">	    &#125;<span class="keyword">else</span> <span class="keyword">if</span> ([vc <span class="attr">isKindOfClass</span>:[<span class="title class_">UITabBarController</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">	        <span class="keyword">return</span> <span class="title function_">_MJFrontVc</span>(vc.<span class="property">selectedViewController</span>);</span><br><span class="line">	    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([vc <span class="attr">isKindOfClass</span>:[<span class="title class_">UINavigationController</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">	        <span class="keyword">return</span> <span class="title function_">_MJFrontVc</span>(vc.<span class="property">visibleViewController</span>);</span><br><span class="line">	    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    	<span class="keyword">var</span> count = vc.<span class="property">childViewControllers</span>.<span class="property">count</span>;</span><br><span class="line">    		<span class="keyword">for</span> (<span class="keyword">var</span> i = count - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    			<span class="keyword">var</span> childVc = vc.<span class="property">childViewControllers</span>[i];</span><br><span class="line">    			<span class="keyword">if</span> (childVc &amp;&amp; childVc.<span class="property">view</span>.<span class="property">window</span>) &#123;</span><br><span class="line">    				vc = <span class="title function_">_MJFrontVc</span>(childVc);</span><br><span class="line">    				<span class="keyword">break</span>;</span><br><span class="line">    			&#125;</span><br><span class="line">    		&#125;</span><br><span class="line">	        <span class="keyword">return</span> vc;</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回最靠近用户的控制器</span></span><br><span class="line">	t.<span class="property">frontVc</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="title function_">_MJFrontVc</span>(<span class="title class_">UIApp</span>.<span class="property">keyWindow</span>.<span class="property">rootViewController</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="title class_">MJIsString</span> = <span class="keyword">function</span>(<span class="params">str</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">typeof</span> str == <span class="string">&#x27;string&#x27;</span> || str <span class="keyword">instanceof</span> <span class="title class_">String</span>;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> _MJClass = <span class="keyword">function</span>(<span class="params">className</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!className) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(missingParamStr);</span><br><span class="line">		<span class="keyword">if</span> (<span class="title class_">MJIsString</span>(className)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="title class_">NSClassFromString</span>(className);</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">if</span> (!className) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(invalidParamStr);</span><br><span class="line">		<span class="comment">// 对象或者类</span></span><br><span class="line">		<span class="keyword">return</span> className.<span class="title function_">class</span>();</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取 className 的所有子类，reg 正则过滤</span></span><br><span class="line">	t.<span class="property">subclassesWith</span> = <span class="keyword">function</span>(<span class="params">className, reg</span>) &#123;</span><br><span class="line">		className = <span class="title function_">_MJClass</span>(className);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> [c <span class="keyword">for</span> <span class="title function_">each</span> (c <span class="keyword">in</span> <span class="title class_">ObjectiveC</span>.<span class="property">classes</span>) </span><br><span class="line">		<span class="keyword">if</span> (c != className </span><br><span class="line">			&amp;&amp; <span class="title function_">class_getSuperclass</span>(c) </span><br><span class="line">			&amp;&amp; [c <span class="attr">isSubclassOfClass</span>:className] </span><br><span class="line">			&amp;&amp; (!reg || reg.<span class="title function_">test</span>(c)))</span><br><span class="line">			];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取按钮的 TouchUpInsideEvent 的 target 和 actions</span></span><br><span class="line">	t.<span class="property">touchUpInsideTargetAndActionWith</span> = <span class="keyword">function</span>(<span class="params">btn</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (![btn <span class="attr">isKindOfClass</span>:[<span class="title class_">UIControl</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;invalid parameter type,must be kind of UIControl class&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	    <span class="keyword">var</span> allTargets = [[btn allTargets] allObjects];</span><br><span class="line">    	<span class="keyword">var</span> dict = [<span class="title class_">NSMutableDictionary</span> dictionary];</span><br><span class="line">    	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; allTargets.<span class="property">count</span>; i++) &#123;</span><br><span class="line">    		<span class="keyword">var</span> actions = [btn <span class="attr">actionsForTarget</span>:allTargets[i] <span class="attr">forControlEvent</span>:<span class="title class_">UIControlEventTouchUpInside</span>];</span><br><span class="line">    		[dict <span class="attr">setValue</span>:actions <span class="attr">forKey</span>:[allTargets[i] description]];</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> dict;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> _MJGetMethods = <span class="keyword">function</span>(<span class="params">className, reg, clazz</span>) &#123;</span><br><span class="line">		className = <span class="title function_">_MJClass</span>(className);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> count = <span class="keyword">new</span> <span class="keyword">new</span> <span class="title class_">Type</span>(<span class="string">&#x27;I&#x27;</span>);</span><br><span class="line">		<span class="keyword">var</span> classObj = clazz ? className.<span class="property">constructor</span> : className;</span><br><span class="line">		<span class="keyword">var</span> methodList = <span class="title function_">class_copyMethodList</span>(classObj, count);</span><br><span class="line">		<span class="keyword">var</span> methodsArray = [];</span><br><span class="line">		<span class="keyword">var</span> methodNamesArray = [];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; *count; i++) &#123;</span><br><span class="line">			<span class="keyword">var</span> method = methodList[i];</span><br><span class="line">			<span class="keyword">var</span> selector = <span class="title function_">method_getName</span>(method);</span><br><span class="line">			<span class="keyword">var</span> name = <span class="title function_">sel_getName</span>(selector);</span><br><span class="line">			<span class="keyword">if</span> (reg &amp;&amp; !reg.<span class="title function_">test</span>(name)) <span class="keyword">continue</span>;</span><br><span class="line">			methodsArray.<span class="title function_">push</span>(&#123;</span><br><span class="line">				selector : selector, </span><br><span class="line">				type : <span class="title function_">method_getTypeEncoding</span>(method)</span><br><span class="line">			&#125;);</span><br><span class="line">			methodNamesArray.<span class="title function_">push</span>(name);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="title function_">free</span>(methodList);</span><br><span class="line">		<span class="keyword">return</span> [methodsArray, methodNamesArray];</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">var</span> _MJMethods = <span class="keyword">function</span>(<span class="params">className, reg, clazz</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="title function_">_MJGetMethods</span>(className, reg, clazz)[<span class="number">0</span>];</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 打印对象方法</span></span><br><span class="line">	t.<span class="property">instanceMethods</span> = <span class="keyword">function</span>(<span class="params">className, reg</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="title function_">_MJMethods</span>(className, reg);</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打印类方法</span></span><br><span class="line">	t.<span class="property">classMethods</span> = <span class="keyword">function</span>(<span class="params">className, reg</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="title function_">_MJMethods</span>(className, reg, <span class="literal">true</span>);</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打印响应者</span></span><br><span class="line">	t.<span class="property">rp</span> = <span class="keyword">function</span>(<span class="params">target</span>) &#123;</span><br><span class="line">		<span class="keyword">var</span> result = <span class="string">&quot;&quot;</span> + target.<span class="title function_">toString</span>();</span><br><span class="line">		<span class="keyword">while</span> (target.<span class="property">nextResponder</span>) &#123;</span><br><span class="line">			result += <span class="string">&quot;\n&quot;</span> + target.<span class="property">nextResponder</span>.<span class="title function_">toString</span>();</span><br><span class="line">			target = target.<span class="property">nextResponder</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> tool.<span class="property">constants</span>) &#123;</span><br><span class="line">		<span class="title class_">Cycript</span>.<span class="property">all</span>[k] = tool.<span class="property">constants</span>[k];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;)(<span class="built_in">exports</span>);</span><br></pre></td></tr></table></figure>

<h2 id="越狱环境下使用-cy-文件"><a href="#越狱环境下使用-cy-文件" class="headerlink" title="越狱环境下使用 .cy 文件"></a>越狱环境下使用 .cy 文件</h2><p>在越狱环境下，可以将编写好的 tool.cy 文件放到 <code>/usr/lib/cycript0.9/com/masterking</code> 目录下。这里的 masterking 是文件夹名，你可以自己创建一个文件夹换成你想要的名字。Cycript 成功附加到 APP 进程之后，使用以下命令就可以导入该文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cy# @import com.masterking.tool</span><br><span class="line">&#123;constants:&#123;bundleId:@<span class="string">&quot;com.masterking.CycriptDemo&quot;</span>,bundlePath:@<span class="string">&quot;/var/containers/Bundle/Application/85010A56-FF88-4EDE-A9CA-BA5C76638197/CycriptDemo.app&quot;</span>,frontVc:<span class="function"><span class="title">function</span></span> ()&#123;<span class="built_in">return</span> s(UIApp.keyWindow.rootViewController)&#125;,subclassesWith:<span class="keyword">function</span> (r,i)&#123;r=d(r);<span class="built_in">return</span> <span class="keyword">function</span>(n,t)&#123;var e;n=[];&#123;e=ObjectiveC.classes;<span class="keyword">for</span>(t <span class="keyword">in</span> e)&#123;t=e[t];<span class="keyword">if</span>(t!=r&amp;&amp;class_getSuperclass(t)&amp;&amp;objc_msgSend(t,<span class="string">&quot;isSubclassOfClass:&quot;</span>,r)&amp;&amp;(!i||i.test(t)))n.push(t)&#125;&#125;<span class="built_in">return</span> n&#125;()&#125;,touchUpInsideTargetAndActionWith:<span class="keyword">function</span> (r)&#123;var e,t,n,i;<span class="keyword">if</span>(!objc_msgSend(r,<span class="string">&quot;isKindOfClass:&quot;</span>,objc_msgSend(UIControl,<span class="string">&quot;class&quot;</span>)))&#123;throw new Error(<span class="string">&quot;invalid parameter type,must be kind of UIControl class&quot;</span>)&#125;i=objc_msgSend(objc_msgSend(r,<span class="string">&quot;allTargets&quot;</span>),<span class="string">&quot;allObjects&quot;</span>);n=objc_msgSend(NSMutableDictionary,<span class="string">&quot;dictionary&quot;</span>);<span class="keyword">for</span>(e=0;e&lt;i.count;e++)&#123;t=objc_msgSend(r,<span class="string">&quot;actionsForTarget:forControlEvent:&quot;</span>,i[e],UIControlEventTouchUpInside);objc_msgSend(n,<span class="string">&quot;setValue:forKey:&quot;</span>,t,objc_msgSend(i[e],<span class="string">&quot;description&quot;</span>))&#125;<span class="built_in">return</span> n&#125;,instanceMethods:<span class="keyword">function</span> (t,e)&#123;<span class="built_in">return</span> i(t,e)&#125;,classMethods:<span class="keyword">function</span> (t,e)&#123;<span class="built_in">return</span> i(t,e,!0)&#125;,rp:<span class="keyword">function</span> (t)&#123;var e;e=<span class="string">&quot;&quot;</span>+t.toString();<span class="keyword">while</span>(t.nextResponder)&#123;e+=<span class="string">&quot;\n&quot;</span>+t.nextResponder.toString();t=t.nextResponder&#125;<span class="built_in">return</span> e&#125;&#125;&#125;</span><br><span class="line">cy# frontVc()</span><br><span class="line"><span class="comment">#&quot;&lt;ViewController: 0x10f119400&gt;&quot;</span></span><br></pre></td></tr></table></figure>

<p>可以看到输出了 tool.cy 中的源码，这样不必要记忆函数名和变量名，写好了导入就可以直接使用，也不需要使用 tool.frontVc() 调用函数，直接 frontVc() 就可以调用，同时还可以使用 tab 键补全函数代码。</p>
<h2 id="非越狱环境下使用-cy-文件"><a href="#非越狱环境下使用-cy-文件" class="headerlink" title="非越狱环境下使用 .cy 文件"></a>非越狱环境下使用 .cy 文件</h2><h3 id="逆向开发的情况使用-cy-文件"><a href="#逆向开发的情况使用-cy-文件" class="headerlink" title="逆向开发的情况使用 .cy 文件"></a>逆向开发的情况使用 .cy 文件</h3><p>在非越狱环境下进行逆向开发，首先推荐的肯定是 AloneMonkey 的 <a href="https://github.com/AloneMonkey/MonkeyDev">MonkeyDev</a> 工具提供了 Xcode 工程模板，可以像正向开发那样方便的使用 Xcode 在未越狱环境进行逆向开发。由于也是很多年没有更新了，没有适配最近的几个 Xcode 版本导致可能无法成功安装。看到 Fork 里有人适配了 Xcode 13 ，使用 Xcode 13 的可以试试。由于我本人使用的是 Xcode 14.3.1 所以就没有尝试，由于之前的 Xcode 可以成功安装，于是我下载了旧版本的 Xcode 好像是 12.4。安装到了 Mac 13.5 上，会显示无法打开。不需要打开使用，直接运行 MonkeyDev 安装脚本根据提示安装，然后还是修改了 md-install 脚本之后，再升级到最新的 Xcode 版本经过一番折腾，终于算是用上了。</p>
<p><img src="4246583878e94515b9949784d0d5d9ce~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"></p>
<p>MonkeyApp 工程默认就集成了 cycript 库到项目中，经过我的观察好像不是使用的 Cycript.framework 的方式，但是也能通过 cycript 连接成功。使用自己的 .cy 文件的方式有两种，一种是使用 MDConfig.plist 配置文件，在其中添加自己的 .cy 文件配置。这个配置文件也很简单，需要一个 url 就行了，配置一个本地环境的 url 也可以。或者直接将 cy 代码复制到 content 中(这种我没试过，感兴趣的可以自己试试) 这两种方式不需要自己再手动 @import 导入 tool.cy 文件，非常省事。</p>
<p><img src="cf16fa5d3acb4cc982cd6b536b97f03d~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"></p>
<p>另一种就是手动将 tool.cy 文件拖进项目中。</p>
<p><img src="f411a3d535084fdba616bdfd5f167961~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"></p>
<p>然后再进入 cycript 交互环境的时候，手动 @import 导入一下，如下图：</p>
<p><img src="cb8b5096ea8a4e0e83ab321131a31f88~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"></p>
<h3 id="正向开发的情况使用-cy-文件"><a href="#正向开发的情况使用-cy-文件" class="headerlink" title="正向开发的情况使用 .cy 文件"></a>正向开发的情况使用 .cy 文件</h3><p>在非越狱环境正向开发的情况下，原以为可以将 tool.cy 文件打包进 APP 的安装包中之后就可以 @import 导入了。万万没有想到并没有这么简单，不确定是哪里出了问题，如果有知道的大神可以在评论区交流一下。会报以下错误：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cy# @import tool</span><br><span class="line">throw new TypeError&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>最关键的信息在{}里面没有显示。。。也没办法了</p>
<h1 id="cycript-实战"><a href="#cycript-实战" class="headerlink" title="cycript 实战"></a>cycript 实战</h1><p>能看到这里的人一定都是热爱学习的人，这里给大家准备了一个惊喜，使用 cycript 绕过某付费直播 APP 观看限制。为了防止有人说我打广告嫌疑和规避法律责任，这里不会明确是哪个 APP 并在此声明<strong>本文案例供技术交流，禁止用于商业及非法用途，如产生法律纠纷与本人无关。</strong>。</p>
<p>APP 图标大概长这样：</p>
<p align="center"><img src="47c8b94fb8c94609967e486c351a4001~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="Xnip2023-08-23_18-15-42.png"></p>

<p>下载好 APP 之后，进入 APP 的包里面，发现干净的很，分析一下原来是 Flutter 项目生成的 iOS APP。Flutter 项目也没关系，不管是什么技术，只要你需要兼容 iOS 平台，就绕不开 iOS 的技术栈 Cocoa touch 框架。</p>
<p align="center"><img src="6b877efc8b264d7ea6dcf4855c6f3580~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png" width="70%"></p>

<p>启动 APP，进入某个直播间发现有一个 30 秒的倒计时之后便出现了如下界面。</p>
<p align="center"><img src="d9b7a7ec1161497a9c1d643ce9cff150~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png" width="30%"></p>

<p>打开终端，使用 cycript 远程附加到 APP 上。递归打印出当前 APP 的界面层级结构：</p>
<p><img src="414b7f2551dc49c48e3f4a37438d17f9~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"></p>
<p>根据经验，推测绿框中的视图应该就是弹出来的视图，让它隐藏之后你就会看到你想要看的东西了😛。。。当然目前这种做法只不过是在内存中修改了视图的 hidden 属性，如果想要做到永久的修改 APP 的逻辑，还需要学习更多的内容，我会在接下来的时间里陆续更新内容，敬请期待。也欢迎感兴趣的开发者共同学习，一起交流。</p>
]]></content>
      <categories>
        <category>iOS 逆向与安全</category>
      </categories>
  </entry>
  <entry>
    <title>iOS 应用砸壳</title>
    <url>/2024/10/27/iOS-%E5%BA%94%E7%94%A8%E7%A0%B8%E5%A3%B3/</url>
    <content><![CDATA[<h1 id="什么是壳"><a href="#什么是壳" class="headerlink" title="什么是壳"></a>什么是壳</h1><p>在软件保护和安全领域，“壳”指的是利用特殊的算法对应用程序的二进制文件进行加密或包装的保护层，通常被称为 “加壳”。壳的作用是保护应用程序的代码，防止未经授权的访问、篡改和逆向工程。壳通常会在应用程序启动时将其解密到内存中，以便正常运行。</p>
<p>苹果会在应用发布到 App Store 时，对应用程序进行 DRM（数字版权管理）保护，这种保护即一种壳，目的是防止非法分发。所以从 App Store 下载的应用程序，我们无法使用 hopper，ghidra，ida 等逆向工具进行静态分析，也无法使用 class-dump 这样的工具导出头文件。需要对其进行解密也就是砸壳，也有人喜欢称脱壳之后，才能进行逆向分析。</p>
<p>iOS 应用加壳只有苹果公司内部自己能处理，所以我们只讨论砸壳的方式：</p>
<h1 id="砸壳的方式"><a href="#砸壳的方式" class="headerlink" title="砸壳的方式"></a>砸壳的方式</h1><ol>
<li><p><strong>静态砸壳或硬砸壳：</strong>就是在已经掌握和了解壳的加密算法和逻辑之后在不运行应用程序的情况下将应用程序的壳进行解密处理。静态砸壳的方法难度大，而且加密方发现应用被破解之后就可能会该用更高级和复杂的加密技术。</p>
</li>
<li><p><strong>动态砸壳：</strong>动态砸壳就是从运行在进程内存空间中的可执行文件镜像入手，将内存中的内容进行转储（dump）处理实现脱壳。这种方式实现起来相对简单且不必关心使用的是什么加密技术。</p>
</li>
</ol>
<p>iOS 砸壳大多采用动态砸壳的方式。</p>
<h1 id="查看-iOS-应用的壳状态"><a href="#查看-iOS-应用的壳状态" class="headerlink" title="查看 iOS 应用的壳状态"></a>查看 iOS 应用的壳状态</h1><p><code>LC_ENCRYPTION_INFO_64</code> 是 Mach-O 文件格式中的一个加载命令（load command），用于描述 64 位 Mach-O 文件的加密信息。该加载命令常见于 macOS 和 iOS 应用程序的可执行文件中，主要包含应用程序是否加密及其相关的加密信息。</p>
<h2 id="主要字段"><a href="#主要字段" class="headerlink" title="主要字段"></a>主要字段</h2><ul>
<li><strong>cryptoff</strong>：加密数据的偏移量，表示从文件的哪个位置开始加密数据。</li>
<li><strong>cryptsize</strong>：加密数据的大小，以字节为单位，指示被加密的范围。</li>
<li><strong>cryptid</strong>：加密标识符，用于表明数据是否被加密。值为 0 表示数据未加密；其他值表示数据已加密。</li>
</ul>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>在 iOS 应用中，<code>LC_ENCRYPTION_INFO_64</code> 常用于 <strong>FairPlay</strong> DRM（数字版权管理）保护。iOS 应用在上传到 App Store 时，苹果会对其进行加密保护，以防止未经授权的访问或修改。通过检查 <code>LC_ENCRYPTION_INFO_64</code> 的字段值，可以判断应用是否经过 DRM 加密保护。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>查看 <code>LC_ENCRYPTION_INFO_64</code> 信息有以下两种方式：</p>
<ol>
<li><strong>图形化工具：</strong>MachOView</li>
<li><strong>命令行工具：</strong>otool</li>
</ol>
<h3 id="MachOView"><a href="#MachOView" class="headerlink" title="MachOView"></a><a href="https://github.com/gdbinit/MachOView">MachOView</a></h3><p><strong>MachOView</strong> 是一款用于 macOS 的图形化工具，专门设计用于分析和查看 Mach-O 文件格式。Mach-O（Mach Object）是 macOS 和 iOS 操作系统使用的可执行文件格式，包含了二进制可执行文件、库文件、内核扩展等。</p>
<p>MachOView 提供了一个直观的界面，可以帮助开发者和逆向工程人员深入分析 Mach-O 文件的结构和内容。它展示了文件头、加载命令、段（segments）、节（sections）、符号表（symbol table）、动态符号、字符串表等各种信息。</p>
<h4 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h4><ul>
<li><strong>查看文件头</strong>：展示 Mach-O 文件的文件头信息，例如文件类型、CPU 架构等。</li>
<li><strong>加载命令</strong>：列出所有的加载命令，包括动态库依赖、入口点、数据段等。</li>
<li><strong>段和节</strong>：显示所有的段和节信息，并可以查看它们的详细内容。</li>
<li><strong>符号表</strong>：解析并显示符号表和动态符号，包括全局符号和本地符号。</li>
<li><strong>反汇编</strong>：支持代码段的反汇编，以查看可执行代码的汇编指令。</li>
<li><strong>导出功能</strong>：可以将分析结果导出为文本格式，以供进一步分析。</li>
</ul>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>MachOView 是 macOS 和 iOS 逆向工程、应用开发及安全研究的重要工具。它使得用户可以深入了解 Mach-O 文件的内部结构，适合用于以下场景：</p>
<ul>
<li><strong>应用逆向工程</strong>：了解应用内部的函数、符号等信息。</li>
<li><strong>安全研究</strong>：分析应用是否进行了加密保护，研究其安全机制。</li>
<li><strong>调试和开发</strong>：查看动态库依赖、文件结构等信息，以帮助调试和优化。</li>
</ul>
<h4 id="下载和安装"><a href="#下载和安装" class="headerlink" title="下载和安装"></a>下载和安装</h4><p>MachOView 可以通过项目的 GitHub 页面进行下载，支持 macOS 平台。使用者可以直接下载预编译的二进制文件，或通过源码自行编译安装。</p>
<p>使用 MachOView 查看可执行文件的 <code>LC_ENCRYPTION_INFO_64</code> 信息</p>
<p><img src="Xnip2024-10-14_16-56-13.jpg"></p>
<h3 id="otool"><a href="#otool" class="headerlink" title="otool"></a>otool</h3><p><code>otool</code> 是 macOS 上的一个命令行工具，用于显示可执行文件、动态库和目标文件的各种低级信息。它是开发者用来分析、调试和检查 Mach-O 文件结构的重要工具。Mach-O（Mach Object）文件格式是 macOS 和 iOS 使用的可执行文件格式，包括应用程序、动态库和内核扩展等。对于从事 macOS 或 iOS 应用开发及逆向工程的人员，<code>otool</code> 是一个非常有用的工具。</p>
<p><code>otool</code> 并非 macOS 系统自带的，而是随 <strong>Xcode Command Line Tools</strong> 一起提供的。因此，默认情况下 macOS 并不包含 <code>otool</code>。要使用 <code>otool</code>，需要先安装 <strong>Xcode Command Line Tools</strong>。幸运的是，不需要安装完整的 Xcode 应用，只需安装命令行工具即可获取 otool。</p>
<p>可以通过以下命令快速安装 Xcode Command Line Tools：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure>

<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p>假设我们有一个 Mach-O 文件 <code>example</code>，可以用以下命令查看其是壳的状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> ~/ otool -l MachO文件 | grep crypt</span><br><span class="line">     cryptoff 16384</span><br><span class="line">    cryptsize 265289728</span><br><span class="line">      cryptid 0</span><br></pre></td></tr></table></figure>

<p>显示 <code>cryptid 0</code> 表示壳已经被解密。</p>
<h1 id="iOS-应用砸壳工具"><a href="#iOS-应用砸壳工具" class="headerlink" title="iOS 应用砸壳工具"></a>iOS 应用砸壳工具</h1><h2 id="dumpdecrypted"><a href="#dumpdecrypted" class="headerlink" title="dumpdecrypted"></a><a href="https://github.com/stefanesser/dumpdecrypted">dumpdecrypted</a></h2><p>是一个动态库，利用 DYLD 的环境变量，将自己插入需要砸壳的进程中，但是很多年没有维护更新了。。。</p>
<h2 id="Clutch"><a href="#Clutch" class="headerlink" title="Clutch"></a><a href="https://github.com/KJCracks/Clutch">Clutch</a></h2><p>是一个 iOS 上命令行程序，也是很多年没有维护更新了。下载编译后在 iOS12.5.7 上，能砸壳一些简单的 app，但是像微信，支付宝这样的 app 会失败。</p>
<h2 id="frida-ios-dump"><a href="#frida-ios-dump" class="headerlink" title="frida-ios-dump"></a><a href="https://github.com/AloneMonkey/frida-ios-dump">frida-ios-dump</a></h2><p>是一个 python 脚本，目前最强的 iOS 砸壳脚本，支持最新版本微信，支付宝等。</p>
<h2 id="LLDB"><a href="#LLDB" class="headerlink" title="LLDB"></a>LLDB</h2><p>Xcode 自带的调试器，使用 lldb 命令手动实现砸壳。</p>
<h2 id="AppDump2"><a href="#AppDump2" class="headerlink" title="AppDump2"></a>AppDump2</h2><p>是一个 iOS App，不需要越狱设备，但是设备需要安装巨魔才能安装 AppDump2 实现砸壳。。。</p>
]]></content>
      <categories>
        <category>iOS 逆向与安全</category>
      </categories>
  </entry>
  <entry>
    <title>iOS逆向与安全开篇介绍</title>
    <url>/2024/03/27/iOS%E9%80%86%E5%90%91%E4%B8%8E%E5%AE%89%E5%85%A8%E5%BC%80%E7%AF%87%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="学习-iOS-逆向开发的前提"><a href="#学习-iOS-逆向开发的前提" class="headerlink" title="学习 iOS 逆向开发的前提"></a>学习 iOS 逆向开发的前提</h1><ul>
<li>有一定的正向开发经验（最起码对 iOS 系统的 UIKit 框架有一定的了解）</li>
<li>一台越狱的 iOS 设备（推荐至少是 64 位架构，iPhone 是从 iPhone 5s 开始，iPad 是从 iPad Air 和 iPad mini 2 开始）</li>
<li>一台 Mac 电脑，理论上来说 Linux 或 Windows 也可以（实际上作者没有实践过）</li>
<li>时间和恒心</li>
</ul>
<h1 id="什么是-iOS-逆向开发"><a href="#什么是-iOS-逆向开发" class="headerlink" title="什么是 iOS 逆向开发"></a>什么是 iOS 逆向开发</h1><p>很多 iOS 开发者可能都不是科班出身的程序员，所以对于逆向开发可能没有任何概念。实不相瞒，作者本人就是如此。工作多年后才慢慢接触并了解了逆向开发，逆向工程等相关的知识。</p>
<p>逆向开发（Reverse Engineering）是一种通过分析和研究已有软件或系统的内部结构、逻辑和功能，以理解其实现方式的技术。在软件开发中，逆向开发通常涉及反编译、反汇编或动态调试，以揭示目标程序的代码逻辑和功能。</p>
<p>iOS 逆向开发是指通过分析已有的 iOS 应用程序或 iOS 系统来理解其内部结构、行为以及工作原理的过程。与常规开发（从源代码构建应用程序）相反，逆向开发是在没有源代码的情况下，逆向分析编译后的二进制文件，研究应用的工作机制。</p>
<h1 id="学习-iOS-逆向开发有什么用"><a href="#学习-iOS-逆向开发有什么用" class="headerlink" title="学习 iOS 逆向开发有什么用"></a>学习 iOS 逆向开发有什么用</h1><ul>
<li><p><strong>应用分析与调试：</strong>使用工具来调试和分析应用程序，理解其功能实现。研究员常用 LLDB、Hopper、Ghidra 等工具来反汇编和反编译 iOS 应用，以了解代码的工作方式。</p>
</li>
<li><p><strong>破解和去除限制：</strong>通过逆向手段绕过某些应用的限制，如应用内购买、付费功能等。虽然这属于非法行为，但仍是逆向开发中不可忽视的一部分。</p>
</li>
<li><p><strong>安全性研究与漏洞发现：</strong>逆向开发在 iOS 安全研究中非常重要。通过逆向工程，安全研究人员可以分析应用的加密算法、安全协议等，寻找漏洞并提出防御措施。</p>
</li>
<li><p><strong>学习与模仿：</strong>开发者通过逆向分析成熟的应用来学习优秀的开发技巧，或者模仿某些功能。</p>
</li>
</ul>
<p>玩过 LOL 的老玩家应该还记得多年前某些辅助工具可以实现自己使用任意皮肤，这也是通过逆向开发做到的，属于 window 逆向方向的，而 iOS 平台的有移除 App 内的广告，绕过打卡类 App 的 Wi-Fi 限制，GPS 检测实现任意打卡，微信自动抢红包，还有游戏的外挂辅助软件也都是通过逆向开发实现的。。。这些都是正向开发做不到，或者不可能提供的。这些也正是逆向开发的用武之地。当然，学会了如何破解别人的 APP，自然也知道了该如何去防护自己的 APP，提高安全性，不会进攻谈什么安全防护呢。</p>
<p>以上这些功能，如果你听到了就感觉到很兴奋，那么恭喜你来对了地方！通过本门课程的学习，以上案例都有可能可以实现。不过还是需要提醒一下大家，一般来说逆向开发的难度相较于正向开发会更加困难，想要掌握逆向开发并不是一件容易的事情，需要持之以恒的学习。</p>
<h1 id="关于-iOS-开发人员的概念解释"><a href="#关于-iOS-开发人员的概念解释" class="headerlink" title="关于 iOS 开发人员的概念解释"></a>关于 iOS 开发人员的概念解释</h1><ol>
<li><p><strong>iOS 应用开发人员</strong></p>
<p> iOS 应用开发人员通常是指那些为 iOS 系统开发应用程序的人。他们主要使用苹果的开发工具和框架，比如 Xcode、Swift、Objective-C 等，目标是创建可以在苹果的 App Store 上发布的应用程序。这类开发人员的主要工作是围绕用户体验、界面设计、功能实现和优化应用性能。</p>
<p> 他们的主要任务包括：</p>
<ul>
<li>开发和维护 iPhone、iPad 上运行的应用程序</li>
<li>使用 iOS SDK（软件开发工具包）和相关的 API（如 UIKit、Core Data、ARKit 等）</li>
<li>与后端服务交互（通常使用 RESTful API 或 GraphQL）</li>
<li>解决与应用程序相关的性能和安全问题</li>
<li>测试和调试应用程序 <br></li>
</ul>
</li>
<li><p><strong>iOS 系统开发人员（越狱插件、底层开发等）</strong></p>
<p> 真正意义上的 iOS 开发人员更适合用于描述那些进行 iOS 系统级开发的人。这些开发人员深入到 iOS 系统的底层，做与操作系统本身相关的开发工作，比如修改系统行为、开发越狱插件、研究内核安全性或进行硬件驱动开发。</p>
<p> 他们的主要任务包括：</p>
<ul>
<li>研究 iOS 系统的底层结构和安全机制</li>
<li>开发越狱工具、插件（比如 Cydia 插件）</li>
<li>修改系统设置或行为，允许用户做出官方系统不允许的操作</li>
<li>逆向工程或研究系统漏洞</li>
<li>优化或修改内核（kernel）层的功能</li>
</ul>
</li>
</ol>
<p>市场上面招聘的 iOS 开发人员基本上都是指 iOS 应用开发人员。iOS 系统开发人员的岗位较少。但如果 iOS 应用开发人员具备逆向分析开发的能力则是一项优势。</p>
<h1 id="本书如何学习"><a href="#本书如何学习" class="headerlink" title="本书如何学习"></a>本书如何学习</h1><p>作者将以微信抢红包的实战项目出发，从 0 到 1 演示如何实现微信抢红包插件，实现插件过程中涉及到的技术和理论知识都会在后续的章节中详细介绍，对 iOS 逆向开发感兴趣的同学通过这个项目，可以迅速的建立对 iOS 逆向开发的整体认知。</p>
]]></content>
      <categories>
        <category>iOS 逆向与安全</category>
      </categories>
  </entry>
  <entry>
    <title>iPhoneX上pop回到根控制器上漂移的bug</title>
    <url>/2018/04/28/iPhoneX%E4%B8%8Apop%E5%9B%9E%E5%88%B0%E6%A0%B9%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B8%8A%E6%BC%82%E7%A7%BB%E7%9A%84bug/</url>
    <content><![CDATA[<p>记录一个在iPhone X上发生的诡异的bug…语言怎么描述都太苍白,那么直接看图<br><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/master/BrowserPreview_tmp201804281808.gif"></p>
<p>只有在滑动到最底部的时候,push到下一个页面,然后在pop回来就会出现contentOffset.y值自动偏移的现象…</p>
<p>视图的层次结构如图:<br><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/master/Snip20180428_1.png"></p>
<p>选中的视图控制器就是TabBarController的第二个子控制器,控制器的view就是一个UICollectionView;我是很懵逼的…同事说可能是iPhone X上的安全距离的原因(但我还是很懵逼)…于是我对视图层次结构做了下修改;</p>
<ul>
<li>取消修改控制器的view为UICollectionView</li>
<li>将UICollectionView作为控制器的view的子视图</li>
<li>设置collectionView的约束为,上左右等于控制器的view,下等于控制器的view的下面,但是偏移一个-34的高度(仅在iPhone X上)</li>
</ul>
<p>修改之后的视图层次结构如下:<br><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/master/Snip20180428_2.png"></p>
<p>这样,collectionView不再漂移了…对上述偏移的值进行修改测试可以发现,当这个值小于等于-34的时候就不会发生漂移,大于-34时就会发生漂移…换一句话的意思就是,如果collectionView距离底部的距离小于34的那么就会漂移,大于等于34不会发生漂移…</p>
]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>密码学概述</title>
    <url>/2021/06/10/%E5%AF%86%E7%A0%81%E5%AD%A6%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>密码学（来自希腊语kryptos，意思是隐藏）一词的核心是指使数据无法被窥探者读取的技术。当然，密码学也可以用于其他目的。密码学包括一系列技术，如验证数据的真实性（检测是否修改）、确定个人或其他实体的身份、确定谁发送了特定消息或创建了特定数据片段、通过网络安全地发送数据、用密码或口令安全地锁定文件等等。</p>
<p>计算机安全中使用的加密主要有两种类型，称为对称密钥加密和非对称密钥加密。</p>
<h1 id="对称密钥加密"><a href="#对称密钥加密" class="headerlink" title="对称密钥加密"></a>对称密钥加密</h1><p>对称密钥加密（也称为秘密密钥加密）是大多数人熟悉的密钥的经典用法：使用相同的密钥来加密和解密数据。经典且最容易破解的版本是凯撒密码（以朱利叶斯·凯撒命名），其中消息中的每个字母都被替换为字母表中固定位置数的字母（例如，“a”被“c”替换，“b”被替换为“d”等）。在凯撒密码中，用于加密和解密消息的密钥只是字母表旋转的位数以及旋转的方向。现代对称密钥算法更加复杂并且更难破解。</p>
<p>有许多不同的算法用于对称密钥加密，提供从最低限度到几乎牢不可破的安全性。其中一些算法提供了强大的安全性、易于代码实现以及快速的加密和解密。此类算法对于加密存储在计算机上的文件以保护它们以防未经授权的个人使用计算机等目的非常有用。但它们在从一台计算机向另一台计算机发送消息时用处不大，因为通信通道的两端都必须拥有相同的密钥并且必须保证其安全。此类密钥的分发和安全存储可能很困难，并且可能会造成安全漏洞。</p>
<p>虽然交换或创建对称密钥的安全技术可以在一定程度上克服这个问题（例如 Diffie-Hellman 密钥交换），但随着非对称密钥加密算法的发明，出现了一种用于计算机通信的更实用的解决方案。</p>
<p>常见的现代对称密钥加密算法有 DES，3DES，AES 等</p>
<h2 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h2><p>数据加密标准（英语：Data Encryption Standard，缩写为 DES）是一种对称密钥加密算法，1976 年被美国联邦政府的国家标准局确定为联邦资料处理标准，随后在国际上广泛流传开来。</p>
<p>DES 现在已经不是一种安全的加密方法，主要因为它使用的 56 位密钥过短。1999 年 1 月，distributed.net 与电子前哨基金会合作，在 22 小时 15 分钟内即公开破解了一个 DES 密钥。<br>也有一些分析报告提出了该算法的理论上的弱点，虽然在实际中难以应用。为了提供实用所需的安全性，可以使用 DES 的派生算法 3DES 来进行加密，虽然 3DES 也存在理论上的攻击方法。DES 标准和 3DES 标准已逐渐被高级加密标准（AES）所取代。</p>
<h2 id="3DES"><a href="#3DES" class="headerlink" title="3DES"></a>3DES</h2><p>三重数据加密算法（英语：Triple Data Encryption Algorithm，缩写为 TDEA，Triple DEA），或称 3DES（Triple DES），是一种对称密钥加密块密码，相当于是对每个数据块应用三次资料加密标准（DES）算法。由于计算机运算能力的增强，原版 DES 由于密钥长度过低容易被暴力破解；3DES 即是设计用来提供一种相对简单的方法，即通过增加 DES 的密钥长度来避免类似的攻击，而不是设计一种全新的块密码算法。</p>
<h2 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h2><p>高级加密标准（英语：Advanced Encryption Standard，缩写：AES），又称 Rijndael加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的 DES，已经被多方分析且广为全世界所使用。经过五年的甄选流程，高级加密标准由美国国家标准与技术研究院（NIST）于 2001 年 11 月 26 日发布于 FIPS PUB 197，并在 2002 年 5 月 26 日成为有效的标准。现在，高级加密标准已然成为对称密钥加密中最流行的算法之一。</p>
<p>该算法为比利时密码学家 Joan Daemen 和 Vincent Rijmen 所设计，结合两位作者的名字，以 Rijndael 为名投稿高级加密标准的甄选流程。</p>
<h2 id="加密模式"><a href="#加密模式" class="headerlink" title="加密模式"></a>加密模式</h2><p>对称加密算法的加密模式是指在对称加密过程中，明文如何被切分、填充和加密，以及密文如何被解密和还原成原始的明文。常见的对称加密算法包括 AES（高级加密标准）和 DES（数据加密标准），它们可以使用不同的加密模式来实现数据的保密性。</p>
<p>虽然加密模式通常应用于对称加密，它亦可以应用于公钥加密，例如在原理上对 RSA 进行处理，但在实用中，公钥密码学通常不用于加密较长的信息，而是使用结合对称加密和公钥加密的混合加密方案。</p>
<p>常见的对称加密模式包括：</p>
<ul>
<li>电子密码本模式（ECB）：是最简单的加密模式，将明文分成固定大小的块，然后每个块单独加密。这种模式的问题在于相同的明文块会加密成相同的密文块，可能导致安全性问题。</li>
<li>密码分组链接模式（CBC）：1976 年，IBM 发明了密码分组链接（CBC，Cipher-block chaining）模式。在 CBC 模式中，每个明文块先与前一个密文块进行异或后，再进行加密。在这种方法中，每个密文块都依赖于它前面的所有明文块。同时，为了保证每条消息的唯一性，在第一个块中需要使用初始化向量。</li>
<li>计数器模式（CTR）：将一个计数器与明文块进行加密，然后再将结果与明文进行异或操作，从而产生密文。这种模式可以并行处理，并且不需要对明文进行填充，因此在某些情况下更高效。</li>
<li>密文反馈模式（CFB）：将前一个密文块作为加密器的输入，然后将结果与明文进行异或操作，得到密文。这种模式可以进行流加密，即逐位地进行加密和解密。</li>
<li>输出反馈模式（OFB）：类似于CFB，但是加密器的输出用于生成密钥流，而不是直接与明文进行异或操作。</li>
</ul>
<p>这些加密模式的选择取决于应用场景、安全需求和性能要求。在实际应用中，需要根据具体情况选择最合适的加密方式和模式。</p>
<h2 id="对称加密的终端练习"><a href="#对称加密的终端练习" class="headerlink" title="对称加密的终端练习"></a>对称加密的终端练习</h2><p>MacOS 自带了一个叫 OpenSSL 的开源加密工具包，提供了一系列的加密算法和安全通信协议的实现，包括 SSL 和 TLS。它由一组函数库和命令行工具组成，可以用于处理数字证书、实现安全通信协议、进行加密和解密等任务。</p>
<p>由于 DES，3DES 目前都不太推荐了，所以这里仅使用 AES 算法演示。</p>
<p>使用 openssl 对明文 helloworld 进行 AES 算法 ECB 模式加密的命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;helloworld&quot;</span> | openssl enc -e -aes-256-ecb -a -pbkdf2 -K 123456</span><br></pre></td></tr></table></figure>

<p>会输出如下结果</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">bnPkNleniCxX5rE1JjnOYg==</span><br></pre></td></tr></table></figure>

<p>对以上结果解密的命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;bnPkNleniCxX5rE1JjnOYg==&quot;</span> | openssl enc -d -aes-256-ecb -a -pbkdf2 -K</span><br><span class="line"> 123456</span><br></pre></td></tr></table></figure>


<p>对明文 helloworld 进行 aes cbc 加密的命令是：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> helloworld | openssl enc -e -aes-256-cbc -a -pbkdf2 -K 123456</span><br><span class="line">U2FsdGVkX19TcP2WjEKOsVXGblFWLGMJM/1dDgvY/S8=</span><br></pre></td></tr></table></figure>

<p>这里 -k 后面的参数 123456 就是用到的密钥。对上面的输出进行解密的命令是：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> U2FsdGVkX19TcP2WjEKOsVXGblFWLGMJM/1dDgvY/S8= | openssl enc -d -aes-256</span><br><span class="line">-cbc -a -pbkdf2 -K 123456</span><br><span class="line">helloworld</span><br></pre></td></tr></table></figure>

<h2 id="iOS-中使用对称加密"><a href="#iOS-中使用对称加密" class="headerlink" title="iOS 中使用对称加密"></a>iOS 中使用对称加密</h2><p>iOS 系统提供了一个 CommonCrypto 库用于加密解密，生成消息摘要（hash）等功能。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;ViewController.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;CommonCrypto/CommonCrypto.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSData</span> *encryptAES256CBC(<span class="built_in">NSData</span> *data, <span class="built_in">NSData</span> *key, <span class="built_in">NSData</span> *iv) &#123;</span><br><span class="line">    size_t bufferSize = data.length + kCCBlockSizeAES128;</span><br><span class="line">    uint8_t buffer[bufferSize];</span><br><span class="line">    size_t numBytesEncrypted = <span class="number">0</span>;</span><br><span class="line">    CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt,</span><br><span class="line">                                          kCCAlgorithmAES,</span><br><span class="line">                                          kCCOptionPKCS7Padding,</span><br><span class="line">                                          key.bytes, key.length,</span><br><span class="line">                                          iv.bytes,</span><br><span class="line">                                          data.bytes, data.length,</span><br><span class="line">                                          buffer, bufferSize,</span><br><span class="line">                                          &amp;numBytesEncrypted);</span><br><span class="line">    <span class="keyword">if</span> (cryptStatus == kCCSuccess) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSData</span> dataWithBytes:buffer length:numBytesEncrypted];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Error: %d&quot;</span>, cryptStatus);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSData</span> *decryptAES256CBC(<span class="built_in">NSData</span> *data, <span class="built_in">NSData</span> *key, <span class="built_in">NSData</span> *iv) &#123;</span><br><span class="line">    size_t bufferSize = data.length + kCCBlockSizeAES128;</span><br><span class="line">    uint8_t buffer[bufferSize];</span><br><span class="line">    size_t numBytesDecrypted = <span class="number">0</span>;</span><br><span class="line">    CCCryptorStatus cryptStatus = CCCrypt(kCCDecrypt,</span><br><span class="line">                                          kCCAlgorithmAES,</span><br><span class="line">                                          kCCOptionPKCS7Padding,</span><br><span class="line">                                          key.bytes, key.length,</span><br><span class="line">                                          iv.bytes,</span><br><span class="line">                                          data.bytes, data.length,</span><br><span class="line">                                          buffer, bufferSize,</span><br><span class="line">                                          &amp;numBytesDecrypted);</span><br><span class="line">    <span class="keyword">if</span> (cryptStatus == kCCSuccess) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSData</span> dataWithBytes:buffer length:numBytesDecrypted];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Error: %d&quot;</span>, cryptStatus);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line">    <span class="built_in">NSString</span> *plaintext = <span class="string">@&quot;helloworld&quot;</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *key = <span class="string">@&quot;12345678123456781234567812345678&quot;</span>; <span class="comment">// 32字节长的密钥</span></span><br><span class="line">    <span class="built_in">NSString</span> *iv = <span class="string">@&quot;0123456789abcdef&quot;</span>; <span class="comment">// 16字节长的初始化向量</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSData</span> *plaintextData = [plaintext dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    <span class="built_in">NSData</span> *keyData = [key dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    <span class="built_in">NSData</span> *ivData = [iv dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSData</span> *encryptedData = encryptAES256CBC(plaintextData, keyData, ivData);</span><br><span class="line">    <span class="keyword">if</span> (encryptedData) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Encrypted data: %@&quot;</span>, [encryptedData base64EncodedStringWithOptions:<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSData</span> *decryptedData = decryptAES256CBC(encryptedData, keyData, ivData);</span><br><span class="line">    <span class="keyword">if</span> (decryptedData) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Decrypted data: %@&quot;</span>, [[<span class="built_in">NSString</span> alloc] initWithData:decryptedData encoding:<span class="built_in">NSUTF8StringEncoding</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>上面的 iOS 代码中使用的加密和解密函数，等价于以下 openssl 终端命令：</p>
<p>加密</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;helloworld&quot;</span> | openssl enc -e -aes-256-cbc -K <span class="string">&quot;3132333435363738313233343536373831323334353637383132333435363738&quot;</span> -iv <span class="string">&quot;30313233343536373839616263646566&quot;</span> -<span class="built_in">base64</span></span><br><span class="line">dMujh+yeGsbTA0xqdhae4Q==</span><br></pre></td></tr></table></figure>

<p>解密</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;dMujh+yeGsbTA0xqdhae4Q==&quot;</span> | openssl enc -d -aes-256-cbc -K <span class="string">&quot;3132333435363738313233343536373831323334353637383132333435363738&quot;</span> -iv <span class="string">&quot;30313233343536373839616263646566&quot;</span> -<span class="built_in">base64</span></span><br><span class="line">helloworld%</span><br></pre></td></tr></table></figure>

<p>openssl 的 -K 和 -iv 参数的类型是 16 进制编码的字符串。12345678123456781234567812345678 的 16 进制编码就是 3132333435363738313233343536373831323334353637383132333435363738，同样 0123456789abcdef 的 16 进制编码就是 30313233343536373839616263646566</p>
<h1 id="非对称密钥加密"><a href="#非对称密钥加密" class="headerlink" title="非对称密钥加密"></a>非对称密钥加密</h1><p>在非对称密钥加密中，不同的密钥用于加密和解密消息。最有用的非对称密钥算法是那些不能从另一个密钥推导出密钥的算法。在这种情况下，一个密钥可以公开，而另一个密钥则保持安全。这种安排通常称为公钥密码术，并且与对称加密相比具有一些明显的优势：消除了向大量用户分发密钥的必要性，并且该算法可用于身份验证以及加密。</p>
<p>第一个广泛使用的公钥算法由 Ron Rivest、Adi Shamir 和 Len Adleman 于 1977 年描述，被称为 RSA 加密，源自其缩写。尽管此后又创建了其他公钥算法，但 RSA 仍然是最常用的。该方法的数学原理超出了本文档的范围，可以在互联网和许多密码学书籍中找到。该算法基于两个大素数及其乘积的数学运算。人们认为它的强度与分解非常大的数的难度有关。以现代数字计算机当前和可预见的速度，在生成 RSA 密钥时选择足够长的素数应该可以使该算法无限期地安全。然而，这一观点尚未得到数学证明，并且快速分解算法或完全不同的破解 RSA 加密的方法是有可能的。此外，如果实用的量子计算机被开发出来，分解大数将不再是一个棘手的问题。</p>
<p>其他公钥算法基于与 RSA 具有同等复杂性的不同数学，包括 ElGamal 加密和椭圆曲线加密。它们的使用类似于 RSA 加密（尽管它们背后的数学原理不同），并且本文档不会进一步讨论它们。</p>
<h2 id="RSA-算法"><a href="#RSA-算法" class="headerlink" title="RSA 算法"></a>RSA 算法</h2><p>1977 年三位麻省理工学院的数学家 罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起设计了一种算法，可以实现非对称加密。这个算法用他们三个人的名字命名，叫做 RSA 算法。</p>
<h3 id="RSA-密钥生成过程"><a href="#RSA-密钥生成过程" class="headerlink" title="RSA 密钥生成过程"></a>RSA 密钥生成过程</h3><p>在 RSA 算法中，首先选择两个大质数 p 和 q，然后计算他们的乘积 n &#x3D; p * q。接下来，计算欧拉函数 φ(n) &#x3D; (p-1)(q-1)。在选择公钥 e 时，需要确保 e 和 φ(n) 互质。<br>然后找到一个整数 d，使得（e * d）mod φ(n) &#x3D; 1。这个 d 就是私钥。</p>
<h3 id="RSA-加密和解密"><a href="#RSA-加密和解密" class="headerlink" title="RSA 加密和解密"></a>RSA 加密和解密</h3><p>在 RSA 加密过程中，明文 m 经过公钥 e 进行加密得到密文 c ，计算公式为 c &#x3D; m<sup>e</sup> % n。在 RSA 解密过程中，密文 c 经过私钥 d 进行解密得到明文 m，计算公式为 m &#x3D; c<sup>d</sup> % n。</p>
<blockquote>
<p>一个问题？在 RSA 算法中，为什么 e 和 φ(n) 互质，d 是 e 的模反元素，就可以保证 M<sup>e * d</sup> % n &#x3D; M 呢？我听过某讲师说是基于欧拉定理，但是欧拉定理的推导中是要求 m 和 n 互质的，但是刚刚 RSA 密钥生成过程中并没有要求 m 和 n 互质，只需要 m 小于 n 就够了。</p>
</blockquote>
<h3 id="RSA-算法的终端练习"><a href="#RSA-算法的终端练习" class="headerlink" title="RSA 算法的终端练习"></a>RSA 算法的终端练习</h3><p>使用 openssl 生成 RSA 私钥的命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">openssl genrsa -out private_key.pem 2048</span><br></pre></td></tr></table></figure>

<p>这个命令会生成一个 2048 位长度的 RSA 私钥，并将其保存在名为 private_key.pem 的文件中。</p>
<p>将私钥转换成对应的公钥，可以使用以下命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">openssl rsa -pubout -<span class="keyword">in</span> private_key.pem -out public_key.pem</span><br></pre></td></tr></table></figure>

<p>现在在当前目录下就会存在两个文件，一个是公钥 <em>public_key.pem</em>，一个是私钥 <em>private_key.pem</em> 。</p>
<p>接下来我们使用这对密钥进行加密解密的演示，先创建一个文件 original.txt 存放明文数据，命令如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;密码是123456&quot;</span> &gt; original.txt</span><br></pre></td></tr></table></figure>

<p>使用公钥对 original.txt 文件进行加密并生成一个 encrypted.txt 文件的命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">openssl pkeyutl -encrypt -<span class="keyword">in</span> original.txt -out encrypted.txt -pubin -inkey public_key.pem</span><br></pre></td></tr></table></figure>

<p>可以使用 <code>cat encrypted.txt </code> 查看加密后的结果，发现是一堆乱码，啥也看不懂。。。接下来使用私钥对 encrypted.txt 文件进行解密并生成一个 decrypted.txt 文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">openssl pkeyutl -decrypt -<span class="keyword">in</span> encrypted.txt -out decrypted.txt -inkey private_key.pem</span><br></pre></td></tr></table></figure>

<p>使用 <code>cat decrypted.txt </code> 查看解密后的结果，可以看到跟 original.txt 的内容是一模一样的。</p>
<!--
### RSA 的数学原理
理解 RSA 的密钥生成过程和加密解密需要一定的数学基础，欧拉函数，欧拉定理，模反元素。如果不感兴趣的也可以跳过本节内容。

了解欧拉函数之前，首先需要知道什么是两个数互质，如果两个正整数，除了 1 以外，没有其他公因数，那么这两个数就是互质的。

#### 欧拉函数

欧拉函数也称为欧拉 φ 函数（phi函数），通常用符号 φ(n) 表示，是一个与正整数 n 相关的算术函数。它表示小于或等于 n 的正整数中与 n 互质的数的个数。

欧拉函数的性质：

* 如果 n 为质数，那么 φ(n) = n - 1
* 如果 n 是两个互质的整数 a，b 之积，那么 φ(n) = φ(a) * φ(b)

结合上面两点可以得到以下结论，如果 n 是两个质数 p1，p2 之积，那么

φ(n) = φ(p1) * φ(p2) = (p1 - 1) * (p2 - 1)

#### 欧拉定理

如果两个正整数 m 和 n 互质，那么 m 的 φ(n) 次方减去 1，可以被 n 整除。即：

m<sup>φ(n)</sup> mod n = 1

这个是已经证明的数学定理，不需要怀疑它的正确性。将上式两边同时加上 k 次方可以得到

m<sup>k * φ(n)</sup> mod n = 1

再将两边同时乘以 m 可以得到：

m<sup>k * φ(n) + 1</sup> mod n = m

#### 模反元素
-->

<h3 id="iOS-中使用非对称加密算法"><a href="#iOS-中使用非对称加密算法" class="headerlink" title="iOS 中使用非对称加密算法"></a>iOS 中使用非对称加密算法</h3><p>iOS 提供了 Security.framework 框架用于帮助开发者实现各种安全相关的功能。这个框架包含了处理加密、密钥管理、证书、信任策略和安全通信的基本功能。通过使用 Security 框架，开发者可以确保应用程序的数据保护、安全传输和用户身份验证等功能。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;ViewController.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;Security/Security.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"><span class="comment">// 生成密钥对</span></span><br><span class="line">- (<span class="built_in">NSDictionary</span> *)generateKeyPair &#123;</span><br><span class="line">    <span class="built_in">NSDictionary</span> *parameters = @&#123;</span><br><span class="line">        (__bridge <span class="type">id</span>)kSecAttrKeyType : (__bridge <span class="type">id</span>)kSecAttrKeyTypeRSA,</span><br><span class="line">        (__bridge <span class="type">id</span>)kSecAttrKeySizeInBits : @<span class="number">2048</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">CFErrorRef</span> createError = <span class="literal">NULL</span>;</span><br><span class="line">    SecKeyRef privateKeyRef = SecKeyCreateRandomKey((__bridge <span class="built_in">CFDictionaryRef</span>)parameters, &amp;createError);</span><br><span class="line">    SecKeyRef publicKeyRef  = SecKeyCopyPublicKey(privateKeyRef);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (privateKeyRef &amp;&amp; publicKeyRef &amp;&amp; createError == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">NSData</span> *publicKeyData = (__bridge_transfer <span class="built_in">NSData</span> *)SecKeyCopyExternalRepresentation(publicKeyRef, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">NSData</span> *privateKeyData = (__bridge_transfer <span class="built_in">NSData</span> *)SecKeyCopyExternalRepresentation(privateKeyRef, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">CFRelease</span>(privateKeyRef); <span class="comment">// 释放 privateKeyRef</span></span><br><span class="line">        <span class="built_in">CFRelease</span>(publicKeyRef); <span class="comment">// 释放 publicKeyRef</span></span><br><span class="line">        <span class="keyword">return</span> @&#123;</span><br><span class="line">            <span class="string">@&quot;publicKey&quot;</span>: publicKeyData,</span><br><span class="line">            <span class="string">@&quot;privateKey&quot;</span>: privateKeyData</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Failed to generate key pair: %@&quot;</span>, (__bridge <span class="built_in">NSError</span> *)createError);</span><br><span class="line">        <span class="keyword">if</span> (createError) &#123;</span><br><span class="line">            <span class="built_in">CFRelease</span>(createError); <span class="comment">// 释放错误对象</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (privateKeyRef) &#123;</span><br><span class="line">            <span class="built_in">CFRelease</span>(privateKeyRef); <span class="comment">// 释放 privateKeyRef</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (publicKeyRef) &#123;</span><br><span class="line">            <span class="built_in">CFRelease</span>(publicKeyRef); <span class="comment">// 释放 publicKeyRef</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用公钥加密数据</span></span><br><span class="line">- (<span class="built_in">NSData</span> *)encryptDataWithPublicKey:(SecKeyRef)publicKey data:(<span class="built_in">NSData</span> *)data &#123;</span><br><span class="line">    <span class="built_in">CFErrorRef</span> error = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">CFDataRef</span> encryptedData = SecKeyCreateEncryptedData(publicKey, kSecKeyAlgorithmRSAEncryptionPKCS1, (__bridge <span class="built_in">CFDataRef</span>)data, &amp;error);</span><br><span class="line">    <span class="keyword">if</span> (encryptedData &amp;&amp; error == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">NSData</span> *result = (__bridge_transfer <span class="built_in">NSData</span> *)encryptedData;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Encryption failed with error: %@&quot;</span>, (__bridge <span class="built_in">NSError</span> *)error);</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            <span class="built_in">CFRelease</span>(error);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (encryptedData) &#123;</span><br><span class="line">            <span class="built_in">CFRelease</span>(encryptedData);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用私钥解密数据</span></span><br><span class="line">- (<span class="built_in">NSData</span> *)decryptDataWithPrivateKey:(SecKeyRef)privateKey data:(<span class="built_in">NSData</span> *)data &#123;</span><br><span class="line">    <span class="built_in">CFErrorRef</span> error = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">CFDataRef</span> decryptedData = SecKeyCreateDecryptedData(privateKey, kSecKeyAlgorithmRSAEncryptionPKCS1, (__bridge <span class="built_in">CFDataRef</span>)data, &amp;error);</span><br><span class="line">    <span class="keyword">if</span> (error == <span class="literal">NULL</span> &amp;&amp; decryptedData) &#123;</span><br><span class="line">        <span class="built_in">NSData</span> *data = (__bridge <span class="built_in">NSData</span> *)decryptedData;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Decryption failed with error: %@&quot;</span>, (__bridge <span class="built_in">NSError</span> *)error);</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            <span class="built_in">CFRelease</span>(error);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (decryptedData) &#123;</span><br><span class="line">            <span class="built_in">CFRelease</span>(decryptedData);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line">    <span class="built_in">NSDictionary</span> *keyPair = [<span class="keyword">self</span> generateKeyPair];</span><br><span class="line">    <span class="built_in">NSData</span> *publicKeyData = keyPair[<span class="string">@&quot;publicKey&quot;</span>];</span><br><span class="line">    <span class="built_in">NSData</span> *privateKeyData = keyPair[<span class="string">@&quot;privateKey&quot;</span>];</span><br><span class="line">    <span class="keyword">if</span> (publicKeyData &amp;&amp; privateKeyData) &#123;</span><br><span class="line">        <span class="built_in">NSMutableDictionary</span> *attributes = @&#123;</span><br><span class="line">            (__bridge <span class="type">id</span>)kSecAttrKeyType : (__bridge <span class="type">id</span>)kSecAttrKeyTypeRSA,</span><br><span class="line">            (__bridge <span class="type">id</span>)kSecAttrKeyClass : (__bridge <span class="type">id</span>)kSecAttrKeyClassPublic</span><br><span class="line">        &#125;.mutableCopy;</span><br><span class="line">        SecKeyRef publicKeyRef = SecKeyCreateWithData((__bridge <span class="built_in">CFDataRef</span>)publicKeyData, (__bridge <span class="built_in">CFDictionaryRef</span>)attributes, <span class="literal">NULL</span>);</span><br><span class="line">        attributes[(__bridge <span class="type">id</span>)kSecAttrKeyClass] = (__bridge <span class="type">id</span>)kSecAttrKeyClassPrivate;</span><br><span class="line">        SecKeyRef privateKeyRef = SecKeyCreateWithData((__bridge <span class="built_in">CFDataRef</span>)privateKeyData, (__bridge <span class="built_in">CFDictionaryRef</span>)attributes, <span class="literal">NULL</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSString</span> *originalString = <span class="string">@&quot;Hello, World!&quot;</span>;</span><br><span class="line">        <span class="built_in">NSData</span> *originalData = [originalString dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSData</span> *encryptedData = [<span class="keyword">self</span> encryptDataWithPublicKey:publicKeyRef data:originalData];</span><br><span class="line">        <span class="keyword">if</span> (encryptedData) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;Encrypted Data: %@&quot;</span>, [encryptedData base64EncodedStringWithOptions:<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">NSData</span> *decryptedData = [<span class="keyword">self</span> decryptDataWithPrivateKey:privateKeyRef data:encryptedData];</span><br><span class="line">            <span class="keyword">if</span> (decryptedData) &#123;</span><br><span class="line">                <span class="built_in">NSString</span> *decryptedString = [[<span class="built_in">NSString</span> alloc] initWithData:decryptedData encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@&quot;Decrypted String: %@&quot;</span>, decryptedString);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h1 id="Hash-函数"><a href="#Hash-函数" class="headerlink" title="Hash 函数"></a>Hash 函数</h1><p>Hash，一般翻译做“散列”，也有直接音译为“哈希”的。哈希函数是一种将任意大小的输入数据转换为固定长度散列值的算法。哈希函数的主要作用是验证数据的完整性和唯一性，可以简单的理解为二进制数据的身份证或者指纹。常见的哈希函数包括 MD5、SHA-1 和 SHA-256 等。</p>
<p>哈希函数的特点：</p>
<ul>
<li>计算速度快</li>
<li>将任意长度的数据计算出固定长度的哈希值</li>
<li>对相同数据计算得到的结果是不变的</li>
<li>具备单向性，无法逆运算</li>
</ul>
<h2 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h2><p>即 Message Digest 5 的缩写，产生 128 位的哈希值。也就是 32 位 16 进制数。Mac 电脑终端一般自带 md5 命令，可以用于一些简单的计算。例如计算 “12345” 的 md5 值：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">md5 -s 12345</span><br><span class="line">MD5 (<span class="string">&quot;12345&quot;</span>) = 827ccb0eea8a706c4c34a16891f84e7b</span><br></pre></td></tr></table></figure>

<p>假设你有两份同名的文件，但是不确定内容是否是一样的。就可以使用 md5 查看两个文件的哈希值。</p>
<p>注意 md5 由于长度较短，目前已经不太安全，因为可以对明文和它的 md5 哈希值建立一个字典，比如 “12345” 的 md5 值是 827ccb0eea8a706c4c34a16891f84e7b 。目前某些解密网站已经建立了这样的字典，如 <a href="https://www.cmd5.com/">https://www.cmd5.com/</a> 所以如果你的需求对安全性要求较高的话，不推荐使用了。但如果是平时用来验证文件的唯一性倒也没什么太大问题。</p>
<h2 id="SHA"><a href="#SHA" class="headerlink" title="SHA"></a>SHA</h2><p>SHA 代表安全散列算法（Secure Hash Algorithm），是一种广泛使用的密码学哈希函数，用于生成数据的哈希值。哈希函数将输入数据转换为固定长度的数据串，通常是一串数字和字母的组合，该串称为哈希值或消息摘要。SHA 算法的哈希值长度可以根据具体的 SHA 版本而变化，比如 SHA-1 生成 160 位的哈希值，而 SHA-256 生成 256 位的哈希值。目前主流的 SHA 版本主要是 SHA-256 和 SHA-3。这两个版本都是较新的，并且在安全性和性能方面都得到了广泛认可。</p>
<h3 id="SHA-1"><a href="#SHA-1" class="headerlink" title="SHA-1"></a>SHA-1</h3><p>产生 160 位的散列值，目前已经不安全</p>
<h3 id="SHA-2"><a href="#SHA-2" class="headerlink" title="SHA-2"></a>SHA-2</h3><p>SHA-256，SHA-384，SHA-512，散列值长度分别是 256 位，384 位，512 位</p>
<h3 id="SHA-3"><a href="#SHA-3" class="headerlink" title="SHA-3"></a>SHA-3</h3><p>SHA-3 是 NIST 选定的一种新的哈希算法标准，也称为 Keccak。它是在 SHA-2 之后发布的，与 SHA-2 系列不同，SHA-3 提供了与之前版本不同的设计和性能特性。SHA-3 的最常见变体是 SHA-3-256，生成 256 位的哈希值。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul>
<li>HMAC（Hash-based Message Authentication Code）是一种用于验证消息完整性和真实性的加密方案。</li>
<li>拆词搜索</li>
<li>版权</li>
<li>数字签名</li>
</ul>
<h1 id="base64-编码"><a href="#base64-编码" class="headerlink" title="base64 编码"></a>base64 编码</h1><p>Base64 编码是一种将二进制数据转换成文本数据的编码方式。在 Base64 编码中，每个字符由 64 个字符中的一个表示，因此得名。Base64 编码常用于在网络传输中表示二进制数据，比如在电子邮件中传输附件、在网页中嵌入图片等场景。</p>
<p>Base64 编码的原理是将二进制数据每 6 位转换成一个字符，所以每 3 个字节（24 位）的二进制数据转换成 4 个 Base64 字符。如果原始数据长度不是 3 的倍数，则在末尾补上相应数量的 0，并用 “&#x3D;” 字符填充以保持长度是 4 的倍数。所以以后看到字符串的末尾是 “&#x3D;” 字符的时候，它有可能就是 Base64 编码后的字符串。</p>
<p>Base64 编码使用了 64 个字符，通常是大小写字母 a-z、A-Z、数字 0-9，以及两个额外的字符（通常是”+”和”&#x2F;“）作为基本字符集，不同的实现中有时候会用不同的字符集。</p>
<p>Base64 编码并不是加密算法，因为它可以轻松地被解码还原成原始数据。它的主要作用是在不支持二进制传输的环境中，将二进制数据表示为文本，便于传输和处理。</p>
<h1 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h1><p>数字签名是一种用于验证数据完整性和身份验证的技术。它使用非对称加密技术，结合了哈希函数和公钥加密算法，以确保数据的完整性、真实性和不可否认性。</p>
<p>数字签名通常由以下步骤组成：</p>
<ol>
<li>创建消息摘要：发送方使用哈希函数（如 SHA-256）生成消息的摘要或哈希值。这个摘要是一个固定长度的字符串，用于代表原始数据的内容。</li>
<li>使用私钥签名：发送方使用自己的私钥对消息摘要进行加密，形成数字签名。私钥只有发送方知道，因此只有发送方能够使用私钥进行签名。</li>
<li>传输数据：发送方将原始数据与数字签名一起发送给接收方。</li>
<li>验证签名：接收方收到数据后，使用发送方的公钥对数字签名进行解密，得到消息摘要。然后，接收方使用相同的哈希函数生成接收到的原始数据的摘要。如果两个摘要匹配，则表明数据未被篡改，签名有效；否则，数据可能已被篡改或签名无效。</li>
</ol>
<p>数字签名的主要目的是确保数据的完整性和真实性，同时提供身份验证和不可否认性，即发送方不能否认其曾经签署过数据。这使得数字签名在许多领域，如电子商务、数字文档、软件分发等方面发挥了重要作用。</p>
<p>简单的一句话概括，数字签名就是使用私钥对数据的哈希值进行加密。</p>
<h1 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h1><p>数字证书是一种用于加密和认证网络通信的安全工具。它是由一个权威的数字证书颁发机构（Certificate Authority，CA）签发的一种电子文档，用于确认特定实体的身份信息。数字证书包含了一些重要的信息，包括：</p>
<p>一个数字证书通常包含以下信息：</p>
<ul>
<li>主体信息：证书的主体是该证书所代表的实体，通常是一个个人、组织或网络设备。主体信息通常包括名称、电子邮件地址等。</li>
<li>公钥：证书包含了主体的公钥，用于加密和验证数字签名。这个公钥与主体的私钥配对，用于加密和解密通信数据。</li>
<li>证书序列号：每个证书都有一个唯一的序列号，用于标识该证书。</li>
<li>有效期：证书有一个有效期限，指定了证书的生效时间和到期时间。过期的证书不再可信。</li>
<li>数字签名：证书被 CA 用其私钥签名，以确保证书的真实性和完整性。客户端可以使用 CA 的公钥来验证数字签名。</li>
<li>颁发者信息：指定了颁发该证书的 CA 的信息。</li>
<li>扩展信息：可能包含一些其他信息，例如用途、策略等。</li>
</ul>
<p>数字证书在网络通信中广泛用于安全连接的建立，例如 HTTPS（安全的HTTP）、SSL&#x2F;TLS等。通过验证数字证书的真实性，可以确保与远程服务器之间的通信是安全的，并且可以防止中间人攻击等安全威胁。</p>
]]></content>
      <categories>
        <category>iOS 逆向与安全</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>密码学</tag>
        <tag>hash</tag>
        <tag>RSA</tag>
        <tag>DES</tag>
        <tag>AES</tag>
      </tags>
  </entry>
  <entry>
    <title>微信抢红包插件</title>
    <url>/2024/04/10/%E5%BE%AE%E4%BF%A1%E6%8A%A2%E7%BA%A2%E5%8C%85%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<p>本篇文章将介绍如何从 0 到 1 一步步实现微信抢红包插件功能，需要用到</p>
<ul>
<li><p>一部能越狱的 iPhone，作者使用的 iOS12.5.7 的 5s。</p>
<p>   推荐使用 iOS15 之前的设备，因为 iOS15 <a href="https://theapplewiki.com/wiki/Signed_System_Volume">SSV</a> 的出现诞生了一种新的越狱方案 <a href="https://theapplewiki.com/wiki/Rootless">rootless</a>。导致很多以前能运行的越狱插件，工具都无法在 iOS15 及后续的系统上正常运行。因为这些工具大多都还没有针对 rootless 进行适配。使用 iOS15 之前的设备能够更完美的进行教学，和拥有更好的体验。当你学有所成的时候，可以尝试对那些暂时没有适配的越狱插件，工具自己进行适配了。这里特别说明一下，rootless 越狱并不是指越狱后没有 root 权限，而是 iOS15 SSV 的出现导致即使是 root 用户也无法往系统目录（如&#x2F;System和&#x2F;usr）写入文件，类似于 macOS 上的 SIP，所以诞生了 rootless 解决方案。</p>
<p>   如果你是 iOS15 及以上的设备，那么越狱也推荐选择 rootful 越狱而不是 rootless，同样还是因为 rootless 很多工具无法使用的原因，比如砸壳工具 frida-ios-dump 在 rootless 越狱设备下大部分 App 都无法砸壳成功。作为普通用户，你可以选择 rootless 越狱，但如果你是想进行逆向学习，还是更推荐使用 rootful 越狱。</p>
</li>
<li><p>一台 Mac 电脑，作者使用的系统是 14.5。</p>
<p>  理论上来说 Linux 或 Windows 也可以，因为 Theos 支持，但是作者没有亲自实践过。</p>
</li>
<li><p>使用终端输入命令行的基本知识。比如 cd 进入目录或删除文件</p>
<p>  其实最好是有 Linux 或者 Unix 系统的基础知识。毕竟 iOS 系统内核 XNU 就是 Unix 类的系统。这一点不算是必要条件吧，可以在过程中学习。</p>
</li>
</ul>
<p>只需要具备以上先决条件即使你不了解 iOS 应用逆向开发也能实现这个功能，感受逆向开发的乐趣。而对于懂编程，对 iOS 应用逆向开发感兴趣的同学则可以通过这个实战项目，迅速的建立对 iOS 应用逆向开发的整体认知。作者将以这一实战项目为根基，实现项目过程中涉及的技术点为枝叶，建立起 iOS 应用逆向开发的知识体系。</p>
<p>从 0 到 1 实现微信抢红包项目的步骤为：</p>
<ol>
<li><a href="#1">越狱 iPhone</a> <ul>
<li><a href="#2">什么是 iPhone 越狱</a></li>
<li><a href="#3">越狱的原理</a></li>
<li><a href="#4">越狱的主要目的</a></li>
<li><a href="#5">越狱后的注意事项</a></li>
<li><a href="#6">iOS 越狱的四种类型</a></li>
<li><a href="#7">包管理器</a></li>
<li><a href="#8">越狱后常用的软件包</a></li>
<li><a href="#9">iOS 如何判断设备是否越狱</a></li>
</ul>
</li>
<li><a href="#10">脱壳微信</a><ul>
<li><a href="#11">下载 frida-ios-dump 项目</a></li>
<li><a href="#12">手机安装 frida</a></li>
<li><a href="#13">安装 frida-ios-dump 的依赖库</a></li>
<li><a href="#14">进行端口转发</a></li>
<li><a href="#15">运行 dump.py 脚本 </a></li>
</ul>
</li>
<li><a href="#16">安装 Theos 创建抢红包 tweak 项目</a></li>
<li><a href="#17">实现抢红包插件的 UI 代码</a></li>
<li><a href="#18">实现抢红包插件的功能代码</a><ul>
<li><a href="#19">1.定位收到微信消息的方法</a></li>
<li><a href="#20">2.定位打开红包的方法</a></li>
<li><a href="#21">3.静态分析开红包的方法</a></li>
<li><a href="#22">最终代码</a></li>
</ul>
</li>
</ol>
<!--
编写 tweak 的过程中用到了。。。
3. 界面分析：分析微信设置界面，实现抢红包功能 UI 界面
    * Cycript
    * Revael
    * Lookin
    * lldb 
5. 静态分析代码：反编译可执行文件，分析微信获取消息流程代码，开红包逻辑
    * MachOView，class-dump，Hopper Disassembler，ida，ghidra 等
6. 动态调试代码
    * lldb+debugserver
7. 编写插件：将我们的代码注入到app中，必要时可能需要重新签名，打包 ipa
-->

<h1 id="越狱-iPhone"><a href="#越狱-iPhone" class="headerlink" title="越狱 iPhone"></a>越狱 iPhone</h1><p>这一步不是本篇文章的重点。因为有很多更好的越狱教程，推荐个<a href="https://ios.cfw.guide/">网站</a>，大家自己去看，选择手机实现越狱。如果对越狱比较熟悉的同学就可以直接跳过这一部分了。</p>
<p>综合考虑下来，目前 8，8plus，x 都是不错的选择，价格合适，性能够用，LCD 屏不怕长时间亮屏幕导致烧屏，且最高支持 iOS16.7.10 越狱，即使出现任何问题导致白苹果，也可以通过刷机恢复之后再次越狱。不会像后面新出的手机如果出现问题，只能更新到最新系统，结果无法越狱的尴尬。</p>
<p>但从学习逆向的角度来说，可能最高搭载 iOS12.5.7 的 iPhone 6&#x2F;6plus 是更合适的选择，一是它是 iOS15 以前的系统许多逆向相关的工具都能正常使用，二是同前面一样即使因为越狱出现了任何问题导致手机无法正常使用，也完全可以通过刷机之后重新越狱，可刷机可越狱的机型就是这么任性。</p>
<p>当然，如果你手中刚好有一台 iOS15 系统之前的 iPhone，也完全可以使用它进行逆向学习，毕竟因为越狱导致 iPhone<br>无法正常使用的情况还是蛮少的，实在不放心就将数据备份已备恢复。</p>
<p>其实越狱 iPhone 并不是逆向开发的必要条件，因为有 <a href="https://github.com/AloneMonkey/MonkeyDev">MonkeyDev</a> 的存在可以实现在未越狱的 iOS 设备上开发插件，但在未越狱设备上开发插件时总会存在一些不方便的情况。比如一些知名的 App 都做了 CFBundleIdentifier 的防护，MonkeyDev 重签名 App 之后修改了 CFBundleIdentifier 就会导致获取不到数据的情况出现就会影响开发，虽然也可以做一些绕过措施但依旧存在其他的问题。</p>
<h2 id="什么是-iPhone-越狱"><a href="#什么是-iPhone-越狱" class="headerlink" title="什么是 iPhone 越狱"></a>什么是 iPhone 越狱</h2><p>iPhone 越狱是指通过特定工具或方法绕过苹果公司对 iOS 操作系统的限制，获取更高权限的过程。这使用户能够访问和修改系统文件、安装非苹果 App Store 中的应用程序，以及对系统进行其他未被官方允许的更改。</p>
<h2 id="越狱的原理"><a href="#越狱的原理" class="headerlink" title="越狱的原理"></a>越狱的原理</h2><p>越狱的原理主要在于利用 iOS 系统中的安全漏洞，获取 root 权限，从而绕过 Apple 的限制，允许用户安装未经过认证的应用和进行系统级的修改。一些开源的越狱工具如 <a href="https://github.com/palera1n/palera1n">palera1n</a>，<a href="https://github.com/opa334/Dopamine">Dopamine</a> 就是通过利用公开的 iOS 系统漏洞来实现的。</p>
<p>公开的 iOS 系统漏洞有 CVE-2021-1782，CVE-2022-32917，CVE-2021-30955 等等，CVE（Common Vulnerabilities and Exposures）是一个公共数据库，用于标识和记录已知的安全漏洞和暴露。每个 CVE 条目都有一个唯一的标识符，格式为 CVE-年份-序号。具体含义如下：</p>
<ul>
<li><strong>CVE：</strong>代表“通用漏洞和曝光”。</li>
<li><strong>年份：</strong>指出该漏洞首次被记录或公开的年份。</li>
<li><strong>序号：</strong>在该年份中，为该漏洞分配的唯一数字。</li>
</ul>
<p>至于这些公开的 iOS 系统漏洞是如何发现和记录的，一般通过以下这几种方式：</p>
<ul>
<li><p><strong>安全研究人员：</strong>独立的安全专家和研究机构会对软件和系统进行审计和测试，发现漏洞后会将其报告给开发者，并在确认后提交 CVE 申请。</p>
</li>
<li><p><strong>开发者和厂商：</strong>软件开发者和公司在进行内部安全测试时，可能会发现漏洞，并会向 CVE 数据库提交这些信息。</p>
</li>
<li><p><strong>社区报告：</strong>开源软件社区和用户在使用软件时，可能会发现安全问题并进行报告。这些报告有时会引发更深入的安全审计。</p>
</li>
<li><p><strong>安全会议和黑客大会：</strong>在这些会议上，研究人员通常会展示他们的研究成果，包括新发现的漏洞，之后这些信息可能会被记录为 CVE。</p>
</li>
<li><p><strong>自动化工具：</strong>一些工具会扫描软件和系统以发现已知的漏洞，并将结果报告给开发者或安全机构。</p>
</li>
</ul>
<p>那么安全研究人员又是如何发现漏洞的呢？一般也就是通过逆向工程，对二进制文件进行反汇编之后，分析代码的内部工作原理，找出潜在的漏洞。安全研究人员的要求通常比一般的程序员更高，主要体现在以下几个方面：</p>
<ul>
<li><p><strong>深厚的安全知识：</strong>安全研究人员需要深入了解安全理论、漏洞类型、攻击向量以及防御机制。</p>
</li>
<li><p><strong>逆向工程能力：</strong>能够反汇编和分析二进制文件，理解底层实现，以发现潜在漏洞。</p>
</li>
<li><p><strong>熟悉网络协议：</strong>对网络安全、协议分析和加密技术有深入理解，以识别网络层面的安全问题。</p>
</li>
<li><p><strong>编程能力：</strong>熟悉多种编程语言，能够编写自动化工具或脚本来测试和分析系统。</p>
</li>
<li><p><strong>持续学习：</strong>安全领域不断变化，研究人员需要跟上最新的安全威胁和防护措施，参与安全社区的讨论和研究。</p>
</li>
<li><p><strong>问题解决能力：</strong>能够分析复杂问题，进行创新性思考，以找到漏洞或制定有效的安全策略。</p>
</li>
</ul>
<h2 id="越狱的主要目的"><a href="#越狱的主要目的" class="headerlink" title="越狱的主要目的"></a>越狱的主要目的</h2><ol>
<li><strong>安装非官方应用：</strong> 越狱允许用户安装苹果官方 App Store 外的应用程序和插件。</li>
<li><strong>自定义界面：</strong> 用户可以通过越狱自定义 iOS 设备的界面和功能，如主题、图标等。</li>
<li><strong>增强功能：</strong> 可以使用各种增强功能的插件和工具，如系统优化、功能扩展等。</li>
<li><strong>完全的访问 iOS 文件系统：</strong> 越狱之后的 iOS 设备可以完全访问它的文件系统。</li>
<li><strong>提供逆向开发的环境：</strong> 越狱之后的 iOS 设备可以更方便的进行逆向开发。</li>
</ol>
<h2 id="越狱后的注意事项"><a href="#越狱后的注意事项" class="headerlink" title="越狱后的注意事项"></a>越狱后的注意事项</h2><ol>
<li>安全风险：<ul>
<li><strong>恶意软件和病毒：</strong>越狱解除了一些系统安全限制，非官方来源的应用可能包含恶意代码，增加设备感染恶意软件的风险。所以要谨慎安装不知名的插件。</li>
<li><strong>系统漏洞：</strong>越狱会使设备暴露于更大的安全漏洞中，黑客可以利用这些漏洞攻击设备。</li>
<li><strong>App 沙盒机制可能被绕过：</strong>虽然越狱不会直接破坏沙盒，但有的恶意插件可能试图绕过应用的沙盒保护，获取不应有的数据访问权限。</li>
</ul>
</li>
<li>系统稳定性降低：<ul>
<li><strong>崩溃和异常：</strong>越狱后安装的某些第三方插件和应用可能与系统不兼容，导致应用崩溃或系统不稳定，甚至出现无法启动的问题。</li>
<li><strong>电池续航缩短：</strong>某些越狱插件可能在后台耗电增加，导致设备电池续航能力下降。</li>
</ul>
</li>
<li>设备保修失效：<ul>
<li><strong>失去官方支持：</strong>苹果公司规定，越狱设备不再享有官方保修服务。如果越狱导致设备问题，官方可能拒绝维修。</li>
</ul>
</li>
<li>应用兼容性问题：<ul>
<li><strong>应用检测越狱：</strong>某些应用（如金融类、支付类、游戏类应用）可能会检测越狱状态，并拒绝在越狱设备上运行。</li>
</ul>
</li>
</ol>
<h2 id="iOS-越狱的四种类型"><a href="#iOS-越狱的四种类型" class="headerlink" title="iOS 越狱的四种类型"></a>iOS 越狱的四种类型</h2><p>有以下四种不同类型的越狱，每种类型取决于它与计算机的独立程度。</p>
<ul>
<li><p><strong>Untethered Jailbreaks 不受限制的越狱</strong></p>
<p>  不受限制的越狱可以被认为是所有越狱的圣杯。他们只需要通过网站、应用程序或计算机运行一次漏洞利用程序。之后，您的设备已完全越狱，不需要任何进一步的操作。即使您重新启动设备后，该漏洞仍将保留在设备上。</p>
<p>  不幸的是，已经很长一段时间没有为最终用户提供新的不受限制的越狱了，而且我们很可能以后都不会看到这样的越狱了。不受限制的越狱的唯一缺点是，如果出现问题，很可能会导致引导循环，要求您通过 iTunes 或 Finder（macOS Catalina 或更高版本）恢复设备。这种情况发生的可能性很低，但确实有可能。</p>
</li>
<li><p><strong>Semi-Untethered Jailbreaks 半不受限制的越狱</strong></p>
<p>  半自由越狱是近这些年来最流行的越狱类型。这种类型的越狱需要在每次重新启动或关闭 iOS 设备时执行漏洞利用。大部分是通过 iOS 设备上的应用程序或者网站运行漏洞。</p>
</li>
<li><p><strong>Semi-Tethered Jailbreaks 半受限制的越狱</strong></p>
<p>  半受限制的越狱与半不受限制的越狱非常相似，但是该漏洞必须使用计算机运行，而不是使用侧载应用程序。由于在每次重新启动 iOS 设备后需要计算机才能重新越狱，因此大多数人选择使用半不受限制的越狱。</p>
</li>
<li><p><strong>Tethered Jailbreaks 受限制的越狱</strong></p>
<p>  受限制的越狱并不适合公众使用。这些漏洞会修改设备，甚至即使没有越狱也需要 PC 才能启动。因此，这些往往只被为新版 iOS 做好准备的越狱开发人员使用。</p>
</li>
</ul>
<h2 id="包管理器"><a href="#包管理器" class="headerlink" title="包管理器"></a>包管理器</h2><p>在 iOS 设备未越狱时，我们只能通过 App Store 或爱思，沙漏这样的第三方平台下载安装应用程序。而越狱之后，我们不仅同样可以使用上面的方式下载安装应用程序，还可以通过像 Cydia，Sileo，等一些包管理器来安装 tweak，应用程序，命令行程序等其他软件。默认情况下，不同的越狱程序与不同的包管理器捆绑在一起，但目前最受欢迎的是 Sileo。</p>
<h3 id="Sileo"><a href="#Sileo" class="headerlink" title="Sileo"></a>Sileo</h3><p>Sileo 是 <a href="https://x.com/elihwyma">Amy</a> 为 iOS 11 及更高版本维护的包管理器。 Sileo 以其基于 Swift 的设计、快速性能和总体质量改进（例如适当的 iPad 支持）而自豪。</p>
<p>Sileo 默认安装在 Electra、Chimera、Odyssey、Taurine 和 Odysseyra1n 上。 Sileo 还可以在 iOS 12.0 及更高版本上通过 checkra1n 以及 unc0ver 下载。</p>
<h3 id="Cydia"><a href="#Cydia" class="headerlink" title="Cydia"></a>Cydia</h3><p>Cydia 是一个包管理器，长期以来被认为是越狱的代表，以前是大多数越狱的首选包管理器。Cydia 的原始创建者 Saurik 已停止维护该项目，但近年来 Sam Bingner 更新了适用于现代设备和 iOS 版本的软件。</p>
<p>关于包管理器的使用，这里不做更深入的介绍了，网上有很多介绍。</p>
<blockquote>
<p>在使用包管理器安装某些应用程序之后，包管理器有时会提示我们重启 SpringBoard 。</p>
<p>SpringBoard 是 iOS 的主屏幕应用程序，管理图标、壁纸、通知等元素，就是我们接触最多的 iOS 桌面。Apple 官方有专门的岗位 iOS SpringBoard Engineer 用于开发和维护 SpringBoard 。</p>
</blockquote>
<h2 id="越狱后常用的软件包"><a href="#越狱后常用的软件包" class="headerlink" title="越狱后常用的软件包"></a>越狱后常用的软件包</h2><ul>
<li><p><strong>Apple File Conduit “2”：</strong> </p>
<p>  简称 AFC2，是一款在越狱后的 iOS 设备上使用的工具，它扩展了默认的 Apple File Conduit 服务，使得用户可以通过 USB 连接访问 iOS 文件系统中的完整内容。通常情况下，非越狱设备的文件系统只能通过 AFC 协议访问有限的部分，而 AFC2 则允许用户访问系统的根目录及其他受限制的区域。Mac 使用如 iFunBox、iExplorer、3uTools 等工具配合 AFC2 实现对越狱设备文件系统的完整访问。</p>
</li>
<li><p><strong>AppSync Unified：</strong> </p>
<p>  它允许用户在设备上安装、管理和运行非官方签名的应用程序。这类应用通常包括未通过苹果审核的应用、已修改的应用、以及自行编译或未经 App Store 发布的应用。AppSync Unified 通过补丁系统文件，绕过了 iOS 的应用签名限制。</p>
</li>
<li><p><strong>Filza File Manager：</strong> </p>
<p>  是一款功能强大的文件管理器，专为越狱后的 iOS 设备设计。它允许用户在设备上直接浏览、管理和编辑文件系统的内容。Filza 提供了与桌面操作系统文件管理器类似的体验，让用户可以轻松访问和操作 iOS 设备上的所有文件，包括系统文件和应用数据。</p>
</li>
<li><p><strong><a href="../openssh/openssh.md">OpenSSH</a></strong> </p>
<p>  是一个开源的 SSH 实现，它提供服务器的功能，用于安全远程登录、命令执行和文件传输。iOS 安装之后可以我们可以使用 Mac 远程登录到设备上。</p>
</li>
</ul>
<blockquote>
<p>如果遇到包管理器下载安装某些软件包失败的情况，可以手动安装软件包。</p>
</blockquote>
<p>如果你已经下载了 .deb 文件（iOS 软件包的格式），可以通过以下步骤在 Sileo 中进行本地安装：</p>
<ol>
<li><strong>将 .deb 文件传输到设备上：</strong>你可以使用文件管理工具或其他方法将 .deb 文件传输到你的 iOS 设备上，比如使用文件传输工具或通过越狱后的文件系统。</li>
<li><strong>使用文件管理工具访问文件：</strong>在设备上打开你用来管理文件的工具（例如 Filza File Manager）。</li>
<li><strong>找到 .deb 文件：</strong>浏览到存储 .deb 文件的目录。</li>
<li><strong>使用 Sileo 安装：</strong>在文件管理工具中找到 .deb 文件，点击它，通常会弹出一个选项，允许你选择使用 Sileo 或其他包管理工具进行安装。</li>
<li><strong>确认安装：</strong>选择 Sileo 进行安装，Sileo 将会处理包的安装过程。</li>
</ol>
<h2 id="iOS-如何判断设备是否越狱"><a href="#iOS-如何判断设备是否越狱" class="headerlink" title="iOS 如何判断设备是否越狱"></a>iOS 如何判断设备是否越狱</h2><p>iOS 可以通过多种方法来检测设备是否越狱，主要是利用越狱后系统的某些变化和越狱工具的行为。以下是常见的越狱检测方法：</p>
<h3 id="检查系统文件的存在"><a href="#检查系统文件的存在" class="headerlink" title="检查系统文件的存在"></a>检查系统文件的存在</h3><p>越狱后，一些特定的文件和目录可能会存在，正常情况下这些文件不应该存在。例如：</p>
<ul>
<li><strong>Cydia 应用的路径：</strong>&#x2F;Applications&#x2F;Cydia.app，如果这个路径存在，说明设备很可能已经越狱。</li>
<li><strong>其他越狱工具的路径：</strong>比如 Sileo.app 或者 Zebra.app。</li>
</ul>
<p>常用代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ([[<span class="built_in">NSFileManager</span> defaultManager] fileExistsAtPath:<span class="string">@&quot;/Applications/Cydia.app&quot;</span>] ||</span><br><span class="line">    [[<span class="built_in">NSFileManager</span> defaultManager] fileExistsAtPath:<span class="string">@&quot;/Library/MobileSubstrate/MobileSubstrate.dylib&quot;</span>] ||</span><br><span class="line">    [[<span class="built_in">NSFileManager</span> defaultManager] fileExistsAtPath:<span class="string">@&quot;/usr/sbin/sshd&quot;</span>] ||</span><br><span class="line">    [[<span class="built_in">NSFileManager</span> defaultManager] fileExistsAtPath:<span class="string">@&quot;/etc/apt&quot;</span>]) &#123;</span><br><span class="line">    <span class="comment">// 设备已经越狱</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这种方式存在一个问题，即曾经越狱过的设备可能在系统中留下了这些文件，但后续升级了 iOS 之后失去了越狱状态就会导致明明是未越狱设备却被判定为越狱设备。</p>
<h3 id="检查是否能够访问系统的根目录"><a href="#检查是否能够访问系统的根目录" class="headerlink" title="检查是否能够访问系统的根目录"></a>检查是否能够访问系统的根目录</h3><p>越狱后，某些应用会获得更高权限，可以访问系统的根目录。因此，通过尝试在 &#x2F;private 目录下写入文件，可以判断设备是否越狱：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSError</span> *error;</span><br><span class="line"><span class="built_in">NSString</span> *testWrite = <span class="string">@&quot;/private/jailbreak_test.txt&quot;</span>;</span><br><span class="line">[<span class="string">@&quot;Jailbreak Test&quot;</span> writeToFile:testWrite atomically:<span class="literal">YES</span> encoding:<span class="built_in">NSUTF8StringEncoding</span> error:&amp;error];</span><br><span class="line"><span class="keyword">if</span> (error == <span class="literal">nil</span>) &#123;</span><br><span class="line">    <span class="comment">// 设备已越狱</span></span><br><span class="line">    [[<span class="built_in">NSFileManager</span> defaultManager] removeItemAtPath:testWrite error:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="检查是否可以调用-fork-函数"><a href="#检查是否可以调用-fork-函数" class="headerlink" title="检查是否可以调用 fork() 函数"></a>检查是否可以调用 fork() 函数</h3><p>iOS 设备在非越狱环境下不允许创建子进程，而越狱设备可以使用 fork() 函数来创建子进程。通过检查是否可以成功调用 fork()，可以判断设备是否越狱：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 设备已越狱</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="检测越狱工具的存在"><a href="#检测越狱工具的存在" class="headerlink" title="检测越狱工具的存在"></a>检测越狱工具的存在</h3><p>有些应用会检查常见的越狱工具，如 Cydia 或 Sileo 是否能够被打开：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ([[<span class="built_in">UIApplication</span> sharedApplication] canOpenURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@&quot;cydia://&quot;</span>]]) &#123;</span><br><span class="line">    <span class="comment">// 设备已越狱</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="检查动态库注入"><a href="#检查动态库注入" class="headerlink" title="检查动态库注入"></a>检查动态库注入</h3><p>越狱通常会引入一些动态库来修改系统行为。可以通过查看运行时的动态库是否有常见的越狱库，例如 MobileSubstrate:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> dyld_count = _dyld_image_count();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dyld_count; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(_dyld_get_image_name(i), <span class="string">&quot;MobileSubstrate&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 设备已越狱</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="脱壳微信"><a href="#脱壳微信" class="headerlink" title="脱壳微信"></a>脱壳微信</h1><p>对一个应用程序进行逆向分析之前，首先需要对其进行脱壳操作。至于什么是壳，请看 <a href="../binary_dumping/binary_dumping.md">iOS 应用脱壳</a></p>
<p>在 iOS12.5.7 上脱壳微信的方法有很多，这里只介绍 frida-ios-dump，要想成功脱壳还需要不少的配置和步骤。简单点来说就是使用 frida-ios-dump 需要用到 frida 等第三方库，而安装 frida 又需要用到其他的库，所以导致可能不会一次性就能成功运行脱壳。加上每个人的电脑环境不同，可能出现的问题千奇百怪，这里就记录作者本人使用过程中遇到的问题和解决的办法。</p>
<h3 id="1-手机安装-frida"><a href="#1-手机安装-frida" class="headerlink" title="1.手机安装 frida"></a>1.手机安装 frida</h3><p>在 cydia&#x2F;sileo 上添加源 <a href="https://build.frida.re/">https://build.frida.re</a>，点击 frida 安装就好了。可以参考<a href="https://frida.re/docs/ios/#with-jailbreak">官方文档</a> </p>
<h3 id="2-Mac下载-frida-ios-dump-项目"><a href="#2-Mac下载-frida-ios-dump-项目" class="headerlink" title="2.Mac下载 frida-ios-dump 项目"></a>2.Mac下载 <a href="https://github.com/AloneMonkey/frida-ios-dump">frida-ios-dump</a> 项目</h3><p>这一步是最简单的，大家都是程序员的话应该不用多说了吧。在终端输入以下命令下载：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/AloneMonkey/frida-ios-dump.git</span><br></pre></td></tr></table></figure>

<h3 id="3-安装-frida-ios-dump-的依赖库"><a href="#3-安装-frida-ios-dump-的依赖库" class="headerlink" title="3.安装 frida-ios-dump 的依赖库"></a>3.安装 frida-ios-dump 的依赖库</h3><p>按照 frida-ios-dump 的文档执行 <code>sudo pip install -r requirements.txt --upgrade</code> 的时候，出现了以下错误：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> ~/frida-ios-dump/ [master*] <span class="built_in">sudo</span> pip install -r requirements.txt --upgrade</span><br><span class="line">Password:</span><br><span class="line"><span class="built_in">sudo</span>: pip: <span class="built_in">command</span> not found</span><br></pre></td></tr></table></figure>

<p>这个问题好解决，由于作者是用 brew 安装的 python3，可以使用它附带的 pip3。所以修改为 pip3 就好了。输入 <code>sudo pip3 install -r requirements.txt --upgrade</code>，还是出错了：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> ~/frida-ios-dump/ [master*] <span class="built_in">sudo</span> pip3 install -r requirements.txt --upgrade</span><br><span class="line">WARNING: The directory <span class="string">&#x27;/Users/franky/Library/Caches/pip&#x27;</span> or its parent directory is not owned or is not writable by the current user. The cache has been disabled. Check the permissions and owner of that directory. If executing pip with <span class="built_in">sudo</span>, you should use <span class="built_in">sudo</span><span class="string">&#x27;s -H flag.</span></span><br><span class="line"><span class="string">error: externally-managed-environment</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">× This environment is externally managed</span></span><br><span class="line"><span class="string">╰─&gt; To install Python packages system-wide, try brew install</span></span><br><span class="line"><span class="string">    xyz, where xyz is the package you are trying to</span></span><br><span class="line"><span class="string">    install.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If you wish to install a Python library that isn&#x27;</span>t <span class="keyword">in</span> Homebrew,</span><br><span class="line">    use a virtual environment:</span><br><span class="line"></span><br><span class="line">    python3 -m venv path/to/venv</span><br><span class="line">    <span class="built_in">source</span> path/to/venv/bin/activate</span><br><span class="line">    python3 -m pip install xyz</span><br><span class="line"></span><br><span class="line">    If you wish to install a Python application that isn<span class="string">&#x27;t in Homebrew,</span></span><br><span class="line"><span class="string">    it may be easiest to use &#x27;</span>pipx install xyz<span class="string">&#x27;, which will manage a</span></span><br><span class="line"><span class="string">    virtual environment for you. You can install pipx with</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    brew install pipx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    You may restore the old behavior of pip by passing</span></span><br><span class="line"><span class="string">    the &#x27;</span>--break-system-packages<span class="string">&#x27; flag to pip, or by adding</span></span><br><span class="line"><span class="string">    &#x27;</span>break-system-packages = <span class="literal">true</span><span class="string">&#x27; to your pip.conf file. The latter</span></span><br><span class="line"><span class="string">    will permanently disable this error.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If you disable this error, we STRONGLY recommend that you additionally</span></span><br><span class="line"><span class="string">    pass the &#x27;</span>--user<span class="string">&#x27; flag to pip, or set &#x27;</span>user = <span class="literal">true</span><span class="string">&#x27; in your pip.conf</span></span><br><span class="line"><span class="string">    file. Failure to do this can result in a broken Homebrew installation.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Read more about this behavior here: &lt;https://peps.python.org/pep-0668/&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">note: If you believe this is a mistake, please contact your Python installation or OS distribution provider. You can override this, at the risk of breaking your Python installation or OS, by passing --break-system-packages.</span></span><br><span class="line"><span class="string">hint: See PEP 668 for the detailed specification.</span></span><br></pre></td></tr></table></figure>

<p>好在给出的提示足够多，解决方法也有。于是按照提示使用 python 虚拟环境。这个虚拟环境一开始给我的感觉很懵逼。但实际的做法就是在项目的目录下新建一个文件夹用于存放 python 相关的资源，这样不影响系统的 python 环境。按照提示输入以下命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> ~/frida-ios-dump/ [master] python3 -m venv path/to/venv</span><br><span class="line"> ~/frida-ios-dump/ [master] <span class="built_in">source</span> path/to/venv/bin/activate</span><br><span class="line">(venv)  ~/frida-ios-dump/ [master] pip3 install -r requirements.txt --upgrade</span><br><span class="line">Collecting asn1crypto (from -r requirements.txt (line 1))</span><br><span class="line">  Using cached asn1crypto-1.5.1-py2.py3-none-any.whl.metadata (13 kB)</span><br><span class="line">Collecting bcrypt (from -r requirements.txt (line 2))</span><br><span class="line">  Using cached bcrypt-4.2.0-cp39-abi3-macosx_10_12_universal2.whl.metadata (9.6 kB)</span><br><span class="line">Collecting cffi (from -r requirements.txt (line 3))</span><br><span class="line">  Using cached cffi-1.17.1-cp312-cp312-macosx_10_9_x86_64.whl.metadata (1.5 kB)</span><br><span class="line">Collecting colorama (from -r requirements.txt (line 4))</span><br><span class="line">  Using cached colorama-0.4.6-py2.py3-none-any.whl.metadata (17 kB)</span><br><span class="line">Collecting cryptography (from -r requirements.txt (line 5))</span><br><span class="line">  Using cached cryptography-43.0.1-cp39-abi3-macosx_10_9_universal2.whl.metadata (5.4 kB)</span><br><span class="line">Collecting enum34 (from -r requirements.txt (line 6))</span><br><span class="line">  Using cached enum34-1.1.10-py3-none-any.whl.metadata (1.6 kB)</span><br><span class="line">Collecting frida-tools (from -r requirements.txt (line 7))</span><br><span class="line">  Using cached frida_tools-13.3.0-py3-none-any.whl</span><br><span class="line">Collecting idna (from -r requirements.txt (line 8))</span><br><span class="line">  Using cached idna-3.10-py3-none-any.whl.metadata (10 kB)</span><br><span class="line">Collecting ipaddress (from -r requirements.txt (line 9))</span><br><span class="line">  Using cached ipaddress-1.0.23-py2.py3-none-any.whl.metadata (923 bytes)</span><br><span class="line">Collecting paramiko (from -r requirements.txt (line 10))</span><br><span class="line">  Using cached paramiko-3.5.0-py3-none-any.whl.metadata (4.4 kB)</span><br><span class="line">Collecting prompt-toolkit (from -r requirements.txt (line 11))</span><br><span class="line">  Using cached prompt_toolkit-3.0.48-py3-none-any.whl.metadata (6.4 kB)</span><br><span class="line">Collecting pyasn1 (from -r requirements.txt (line 12))</span><br><span class="line">  Using cached pyasn1-0.6.1-py3-none-any.whl.metadata (8.4 kB)</span><br><span class="line">Collecting pycparser (from -r requirements.txt (line 13))</span><br><span class="line">  Using cached pycparser-2.22-py3-none-any.whl.metadata (943 bytes)</span><br><span class="line">Collecting Pygments (from -r requirements.txt (line 14))</span><br><span class="line">  Using cached pygments-2.18.0-py3-none-any.whl.metadata (2.5 kB)</span><br><span class="line">Collecting PyNaCl (from -r requirements.txt (line 15))</span><br><span class="line">  Using cached PyNaCl-1.5.0-cp36-abi3-macosx_10_10_universal2.whl.metadata (8.7 kB)</span><br><span class="line">Collecting scp (from -r requirements.txt (line 16))</span><br><span class="line">  Using cached scp-0.15.0-py2.py3-none-any.whl.metadata (4.3 kB)</span><br><span class="line">Collecting six (from -r requirements.txt (line 17))</span><br><span class="line">  Using cached six-1.16.0-py2.py3-none-any.whl.metadata (1.8 kB)</span><br><span class="line">Collecting tqdm (from -r requirements.txt (line 18))</span><br><span class="line">  Using cached tqdm-4.66.5-py3-none-any.whl.metadata (57 kB)</span><br><span class="line">Collecting wcwidth (from -r requirements.txt (line 19))</span><br><span class="line">  Using cached wcwidth-0.2.13-py2.py3-none-any.whl.metadata (14 kB)</span><br><span class="line">Collecting frida&lt;17.0.0,&gt;=16.2.2 (from frida-tools-&gt;-r requirements.txt (line 7))</span><br><span class="line">  Using cached frida-16.5.5-cp37-abi3-macosx_10_13_x86_64.whl.metadata (2.0 kB)</span><br><span class="line">Collecting websockets&lt;14.0.0,&gt;=13.0.0 (from frida-tools-&gt;-r requirements.txt (line 7))</span><br><span class="line">  Using cached websockets-13.1-cp312-cp312-macosx_10_9_x86_64.whl.metadata (6.8 kB)</span><br><span class="line">Using cached asn1crypto-1.5.1-py2.py3-none-any.whl (105 kB)</span><br><span class="line">Using cached bcrypt-4.2.0-cp39-abi3-macosx_10_12_universal2.whl (472 kB)</span><br><span class="line">Using cached cffi-1.17.1-cp312-cp312-macosx_10_9_x86_64.whl (183 kB)</span><br><span class="line">Using cached colorama-0.4.6-py2.py3-none-any.whl (25 kB)</span><br><span class="line">Using cached cryptography-43.0.1-cp39-abi3-macosx_10_9_universal2.whl (6.2 MB)</span><br><span class="line">Using cached enum34-1.1.10-py3-none-any.whl (11 kB)</span><br><span class="line">Using cached idna-3.10-py3-none-any.whl (70 kB)</span><br><span class="line">Using cached ipaddress-1.0.23-py2.py3-none-any.whl (18 kB)</span><br><span class="line">Using cached paramiko-3.5.0-py3-none-any.whl (227 kB)</span><br><span class="line">Using cached prompt_toolkit-3.0.48-py3-none-any.whl (386 kB)</span><br><span class="line">Using cached pyasn1-0.6.1-py3-none-any.whl (83 kB)</span><br><span class="line">Using cached pycparser-2.22-py3-none-any.whl (117 kB)</span><br><span class="line">Using cached pygments-2.18.0-py3-none-any.whl (1.2 MB)</span><br><span class="line">Using cached PyNaCl-1.5.0-cp36-abi3-macosx_10_10_universal2.whl (349 kB)</span><br><span class="line">Using cached scp-0.15.0-py2.py3-none-any.whl (8.8 kB)</span><br><span class="line">Using cached six-1.16.0-py2.py3-none-any.whl (11 kB)</span><br><span class="line">Using cached tqdm-4.66.5-py3-none-any.whl (78 kB)</span><br><span class="line">Using cached wcwidth-0.2.13-py2.py3-none-any.whl (34 kB)</span><br><span class="line">Using cached frida-16.5.5-cp37-abi3-macosx_10_13_x86_64.whl (16.7 MB)</span><br><span class="line">Using cached websockets-13.1-cp312-cp312-macosx_10_9_x86_64.whl (155 kB)</span><br><span class="line">Installing collected packages: wcwidth, ipaddress, enum34, asn1crypto, websockets, tqdm, six, Pygments, pycparser, pyasn1, prompt-toolkit, idna, frida, colorama, bcrypt, frida-tools, cffi, PyNaCl, cryptography, paramiko, scp</span><br><span class="line">Successfully installed PyNaCl-1.5.0 Pygments-2.18.0 asn1crypto-1.5.1 bcrypt-4.2.0 cffi-1.17.1 colorama-0.4.6 cryptography-43.0.1 enum34-1.1.10 frida-16.5.5 frida-tools-13.3.0 idna-3.10 ipaddress-1.0.23 paramiko-3.5.0 prompt-toolkit-3.0.48 pyasn1-0.6.1 pycparser-2.22 scp-0.15.0 six-1.16.0 tqdm-4.66.5 wcwidth-0.2.13 websockets-13.1</span><br></pre></td></tr></table></figure>

<p>可以看到成功安装了 frida。可以使用 <code>pip3 list</code> 查看 frida 的版本号。确保 frida 的版本号和手机上的 frida 是同个版本。</p>
<h3 id="4-进行端口转发"><a href="#4-进行端口转发" class="headerlink" title="4.进行端口转发"></a>4.进行端口转发</h3><p>使用 frida-ios-dump 的前提是你的越狱设备安装并配置好了 <a href="../openssh/openssh.md">OpenSSH</a> 免密码登录。这可以看我之前写过的文章。</p>
<p>使用 iproxy 进行端口转发，<code>iproxy 2222:22</code> 通过 USB 将电脑上的 2222 端口和手机的 22 端口建立映射。这一步基本没什么问题。<code>iproxy</code> 是 <code>libimobiledevice</code> 工具集的一部分，所以通过 <code>brew</code> 安装 <code>libimobiledevice</code> 获得 <code>iproxy</code>。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">brew install libimobiledevice</span><br></pre></td></tr></table></figure>

<p>然后在终端新开一个窗口运行 <code>iproxy 2222:22</code>，之后这个终端窗口就不接受用户输入，无法交互了，但不要关闭它，因为它一直在工作中。。。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> ~/ iproxy 2222:22</span><br><span class="line">Creating listening port 2222 <span class="keyword">for</span> device port 22</span><br><span class="line">waiting <span class="keyword">for</span> connection</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h3 id="5-运行-dump-py-脚本"><a href="#5-运行-dump-py-脚本" class="headerlink" title="5.运行 dump.py 脚本"></a>5.运行 dump.py 脚本</h3><p>在运行 dump.py 脚本之前，我们可能还需要对它进行一些修改。打开 dump.py 文件，找到下面配置，在文件的 40-43 行。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">User = <span class="string">&#x27;root&#x27;</span></span><br><span class="line">Password = <span class="string">&#x27;alpine&#x27;</span></span><br><span class="line">Host = <span class="string">&#x27;localhost&#x27;</span></span><br><span class="line">Port = <span class="number">2222</span></span><br><span class="line">KeyFileName = <span class="literal">None</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这里的密码，是你在越狱 iPhone 之后设置的密码，如果是老旧的 iOS12 越狱可能是默认的密码 alpine。如果是新一点的版本如 iOS16，则是你越狱后安装 Sileo 时设置的密码，或者后续手动设置的密码。Host 设置为 localhost，是因为我们进行了 USB 端口转发，通过 USB 连接手机，就可以实现访问电脑的 2222 端口相当于访问了手机的 22 端口。</p>
<p>修改好以上配置之后使用命令 <code>python3 dump.py -l</code> 可以列举越狱设备上可砸壳的应用程序。然后输入以下命令 <code>python3 dump.py 微信</code> 运行，就可以看到终端脱壳的过程了。如果终端没有反应，可以手动打开 微信 app。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(venv)  ~/frida-ios-dump/ [master*] python3 dump.py 微信</span><br><span class="line">Start the target app 微信</span><br><span class="line">attach pid : 18956</span><br><span class="line">Dumping 微信 to /var/folders/rt/zkm8hst55kv45x396jh95v3h0000gn/T</span><br><span class="line">[frida-ios-dump]: Load ilink_network.framework success.</span><br><span class="line">[frida-ios-dump]: Load TPFFmpeg.framework success.</span><br><span class="line">[frida-ios-dump]: Load NewMessageRingUtil.framework success.</span><br><span class="line">[frida-ios-dump]: Load SoundTouch.framework success.</span><br><span class="line">[frida-ios-dump]: Load openssl.framework success.</span><br><span class="line">[frida-ios-dump]: Load MMRouter.framework success.</span><br><span class="line">[frida-ios-dump]: Load owl.framework success.</span><br><span class="line">[frida-ios-dump]: Load TPThirdParties.framework success.</span><br><span class="line">[frida-ios-dump]: Load andromeda.framework success.</span><br><span class="line">[frida-ios-dump]: Load matrixreport.framework success.</span><br><span class="line">[frida-ios-dump]: Load Lottie.framework success.</span><br><span class="line">[frida-ios-dump]: Load ProtobufLite.framework success.</span><br><span class="line">[frida-ios-dump]: Load App.framework success.</span><br><span class="line">[frida-ios-dump]: Load JavaScriptCore2.framework success.</span><br><span class="line">start dump /private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/WeChat</span><br><span class="line">0.00B [00:00, ?B/s]payload : &#123;<span class="string">&#x27;dump&#x27;</span>: <span class="string">&#x27;/var/mobile/Containers/Data/Application/CC606C90-0A7C-4829-B31E-3027FFFCE2D7/Documents/WeChat.322542873.fid&#x27;</span>, <span class="string">&#x27;path&#x27;</span>: <span class="string">&#x27;/private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/WeChat&#x27;</span>&#125;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/Users/franky/frida-ios-dump/path/to/venv/lib/python3.12/site-packages/frida/core.py&quot;</span>, line 562, <span class="keyword">in</span> _on_message</span><br><span class="line">    callback(message, data)</span><br><span class="line">  File <span class="string">&quot;/Users/franky/frida-ios-dump/dump.py&quot;</span>, line 571, <span class="keyword">in</span> on_message</span><br><span class="line">    scp.get(scp_from, scp_to)</span><br><span class="line">  File <span class="string">&quot;/Users/franky/frida-ios-dump/path/to/venv/lib/python3.12/site-packages/scp.py&quot;</span>, line 286, <span class="keyword">in</span> get</span><br><span class="line">    self._recv_all()</span><br><span class="line">  File <span class="string">&quot;/Users/franky/frida-ios-dump/path/to/venv/lib/python3.12/site-packages/scp.py&quot;</span>, line 440, <span class="keyword">in</span> _recv_all</span><br><span class="line">    raise SCPException(asunicode(msg[1:]))</span><br><span class="line">scp.SCPException: scp: /var/mobile/Containers/Data/Application/CC606C90-0A7C-4829-B31E-3027FFFCE2D7/Documents/WeChat.322542873.fid: No such file or directory</span><br><span class="line">0.00B [00:00, ?B/s]</span><br><span class="line">start dump /private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/TPThirdParties.framework/TPThirdParties</span><br><span class="line">0.00B [00:00, ?B/s]payload : &#123;<span class="string">&#x27;dump&#x27;</span>: <span class="string">&#x27;/var/mobile/Containers/Data/Application/CC606C90-0A7C-4829-B31E-3027FFFCE2D7/Documents/TPThirdParties.-1804490760.fid&#x27;</span>, <span class="string">&#x27;path&#x27;</span>: <span class="string">&#x27;/private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/TPThirdParties.framework/TPThirdParties&#x27;</span>&#125;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/Users/franky/frida-ios-dump/path/to/venv/lib/python3.12/site-packages/frida/core.py&quot;</span>, line 562, <span class="keyword">in</span> _on_message</span><br><span class="line">    callback(message, data)</span><br><span class="line">  File <span class="string">&quot;/Users/franky/frida-ios-dump/dump.py&quot;</span>, line 571, <span class="keyword">in</span> on_message</span><br><span class="line">    scp.get(scp_from, scp_to)</span><br><span class="line">  File <span class="string">&quot;/Users/franky/frida-ios-dump/path/to/venv/lib/python3.12/site-packages/scp.py&quot;</span>, line 286, <span class="keyword">in</span> get</span><br><span class="line">    self._recv_all()</span><br><span class="line">  File <span class="string">&quot;/Users/franky/frida-ios-dump/path/to/venv/lib/python3.12/site-packages/scp.py&quot;</span>, line 440, <span class="keyword">in</span> _recv_all</span><br><span class="line">    raise SCPException(asunicode(msg[1:]))</span><br><span class="line">scp.SCPException: scp: /var/mobile/Containers/Data/Application/CC606C90-0A7C-4829-B31E-3027FFFCE2D7/Documents/TPThirdParties.-1804490760.fid: No such file or directory</span><br><span class="line">0.00B [00:00, ?B/s]</span><br><span class="line">start dump /private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/TPFFmpeg.framework/TPFFmpeg</span><br><span class="line">0.00B [00:00, ?B/s]payload : &#123;<span class="string">&#x27;dump&#x27;</span>: <span class="string">&#x27;/var/mobile/Containers/Data/Application/CC606C90-0A7C-4829-B31E-3027FFFCE2D7/Documents/TPFFmpeg.-1887525640.fid&#x27;</span>, <span class="string">&#x27;path&#x27;</span>: <span class="string">&#x27;/private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/TPFFmpeg.framework/TPFFmpeg&#x27;</span>&#125;</span><br><span class="line">100%|██████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 12.3M/12.3M [00:00&lt;00:00, 34.7MB/s]</span><br><span class="line">start dump /private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/owl.framework/owl</span><br><span class="line">0.00B [00:00, ?B/s]payload : &#123;<span class="string">&#x27;dump&#x27;</span>: <span class="string">&#x27;/var/mobile/Containers/Data/Application/CC606C90-0A7C-4829-B31E-3027FFFCE2D7/Documents/owl.348061506.fid&#x27;</span>, <span class="string">&#x27;path&#x27;</span>: <span class="string">&#x27;/private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/owl.framework/owl&#x27;</span>&#125;</span><br><span class="line">100%|██████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 1.36M/1.36M [00:00&lt;00:00, 15.2MB/s]</span><br><span class="line">start dump /private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/ilink_network.framework/ilink_network</span><br><span class="line">0.00B [00:00, ?B/s]payload : &#123;<span class="string">&#x27;dump&#x27;</span>: <span class="string">&#x27;/var/mobile/Containers/Data/Application/CC606C90-0A7C-4829-B31E-3027FFFCE2D7/Documents/ilink_network.928538910.fid&#x27;</span>, <span class="string">&#x27;path&#x27;</span>: <span class="string">&#x27;/private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/ilink_network.framework/ilink_network&#x27;</span>&#125;</span><br><span class="line">100%|██████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 7.14M/7.14M [00:00&lt;00:00, 21.6MB/s]</span><br><span class="line">start dump /private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/SoundTouch.framework/SoundTouch</span><br><span class="line">0.00B [00:00, ?B/s]payload : &#123;<span class="string">&#x27;dump&#x27;</span>: <span class="string">&#x27;/var/mobile/Containers/Data/Application/CC606C90-0A7C-4829-B31E-3027FFFCE2D7/Documents/SoundTouch.1717022808.fid&#x27;</span>, <span class="string">&#x27;path&#x27;</span>: <span class="string">&#x27;/private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/SoundTouch.framework/SoundTouch&#x27;</span>&#125;</span><br><span class="line">100%|████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 113k/113k [00:00&lt;00:00, 2.13MB/s]</span><br><span class="line">start dump /private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/JavaScriptCore2.framework/JavaScriptCore2</span><br><span class="line">0.00B [00:00, ?B/s]payload : &#123;<span class="string">&#x27;dump&#x27;</span>: <span class="string">&#x27;/var/mobile/Containers/Data/Application/CC606C90-0A7C-4829-B31E-3027FFFCE2D7/Documents/JavaScriptCore2.514565318.fid&#x27;</span>, <span class="string">&#x27;path&#x27;</span>: <span class="string">&#x27;/private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/JavaScriptCore2.framework/JavaScriptCore2&#x27;</span>&#125;</span><br><span class="line">100%|██████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 12.6M/12.6M [00:00&lt;00:00, 34.6MB/s]</span><br><span class="line">start dump /private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/ProtobufLite.framework/ProtobufLite</span><br><span class="line">0.00B [00:00, ?B/s]payload : &#123;<span class="string">&#x27;dump&#x27;</span>: <span class="string">&#x27;/var/mobile/Containers/Data/Application/CC606C90-0A7C-4829-B31E-3027FFFCE2D7/Documents/ProtobufLite.410267128.fid&#x27;</span>, <span class="string">&#x27;path&#x27;</span>: <span class="string">&#x27;/private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/ProtobufLite.framework/ProtobufLite&#x27;</span>&#125;</span><br><span class="line">100%|████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 544k/544k [00:00&lt;00:00, 7.19MB/s]</span><br><span class="line">start dump /private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/MMRouter.framework/MMRouter</span><br><span class="line">0.00B [00:00, ?B/s]payload : &#123;<span class="string">&#x27;dump&#x27;</span>: <span class="string">&#x27;/var/mobile/Containers/Data/Application/CC606C90-0A7C-4829-B31E-3027FFFCE2D7/Documents/MMRouter.-2017767432.fid&#x27;</span>, <span class="string">&#x27;path&#x27;</span>: <span class="string">&#x27;/private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/MMRouter.framework/MMRouter&#x27;</span>&#125;</span><br><span class="line">100%|██████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 96.5k/96.5k [00:00&lt;00:00, 1.82MB/s]</span><br><span class="line">start dump /private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/Lottie.framework/Lottie</span><br><span class="line">0.00B [00:00, ?B/s]payload : &#123;<span class="string">&#x27;dump&#x27;</span>: <span class="string">&#x27;/var/mobile/Containers/Data/Application/CC606C90-0A7C-4829-B31E-3027FFFCE2D7/Documents/Lottie.1475886264.fid&#x27;</span>, <span class="string">&#x27;path&#x27;</span>: <span class="string">&#x27;/private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/Lottie.framework/Lottie&#x27;</span>&#125;</span><br><span class="line">100%|████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 488k/488k [00:00&lt;00:00, 9.93MB/s]</span><br><span class="line">start dump /private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/andromeda.framework/andromeda</span><br><span class="line">0.00B [00:00, ?B/s]payload : &#123;<span class="string">&#x27;dump&#x27;</span>: <span class="string">&#x27;/var/mobile/Containers/Data/Application/CC606C90-0A7C-4829-B31E-3027FFFCE2D7/Documents/andromeda.419211084.fid&#x27;</span>, <span class="string">&#x27;path&#x27;</span>: <span class="string">&#x27;/private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/andromeda.framework/andromeda&#x27;</span>&#125;</span><br><span class="line">100%|██████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 8.50M/8.50M [00:00&lt;00:00, 34.4MB/s]</span><br><span class="line">start dump /private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/openssl.framework/openssl</span><br><span class="line">0.00B [00:00, ?B/s]payload : &#123;<span class="string">&#x27;dump&#x27;</span>: <span class="string">&#x27;/var/mobile/Containers/Data/Application/CC606C90-0A7C-4829-B31E-3027FFFCE2D7/Documents/openssl.680017982.fid&#x27;</span>, <span class="string">&#x27;path&#x27;</span>: <span class="string">&#x27;/private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/openssl.framework/openssl&#x27;</span>&#125;</span><br><span class="line">100%|██████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 2.59M/2.59M [00:00&lt;00:00, 17.5MB/s]</span><br><span class="line">start dump /private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/matrixreport.framework/matrixreport</span><br><span class="line">0.00B [00:00, ?B/s]payload : &#123;<span class="string">&#x27;dump&#x27;</span>: <span class="string">&#x27;/var/mobile/Containers/Data/Application/CC606C90-0A7C-4829-B31E-3027FFFCE2D7/Documents/matrixreport.-1076983176.fid&#x27;</span>, <span class="string">&#x27;path&#x27;</span>: <span class="string">&#x27;/private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/matrixreport.framework/matrixreport&#x27;</span>&#125;</span><br><span class="line">100%|████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 469k/469k [00:00&lt;00:00, 8.20MB/s]</span><br><span class="line">start dump /private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/NewMessageRingUtil.framework/NewMessageRingUtil</span><br><span class="line">0.00B [00:00, ?B/s]payload : &#123;<span class="string">&#x27;dump&#x27;</span>: <span class="string">&#x27;/var/mobile/Containers/Data/Application/CC606C90-0A7C-4829-B31E-3027FFFCE2D7/Documents/NewMessageRingUtil.709267448.fid&#x27;</span>, <span class="string">&#x27;path&#x27;</span>: <span class="string">&#x27;/private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/NewMessageRingUtil.framework/NewMessageRingUtil&#x27;</span>&#125;</span><br><span class="line">100%|██████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 87.6k/87.6k [00:00&lt;00:00, 2.23MB/s]</span><br><span class="line">start dump /private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/App.framework/App</span><br><span class="line">0.00B [00:00, ?B/s]payload : &#123;<span class="string">&#x27;dump&#x27;</span>: <span class="string">&#x27;/var/mobile/Containers/Data/Application/CC606C90-0A7C-4829-B31E-3027FFFCE2D7/Documents/App.-760674948.fid&#x27;</span>, <span class="string">&#x27;path&#x27;</span>: <span class="string">&#x27;/private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/App.framework/App&#x27;</span>&#125;</span><br><span class="line">100%|██████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 50.6M/50.6M [00:01&lt;00:00, 38.5MB/s]</span><br><span class="line">0.00B [00:00, ?B/s]payload : &#123;<span class="string">&#x27;app&#x27;</span>: <span class="string">&#x27;/private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app&#x27;</span>&#125;</span><br><span class="line">/var/folders/rt/zkm8hst55kv45x396jh95v3h0000gn/T/Payload/</span><br><span class="line">666MB [00:25, 27.1MB/s]</span><br><span class="line">0.00B [00:00, ?B/s]payload : &#123;<span class="string">&#x27;done&#x27;</span>: <span class="string">&#x27;ok&#x27;</span>&#125;</span><br><span class="line">DONE!</span><br><span class="line">0.00B [00:00, ?B/s]</span><br><span class="line">Generating <span class="string">&quot;微信.ipa&quot;</span></span><br></pre></td></tr></table></figure>

<p>输入 la 查看当前目录下，多了一个 微信.ipa 文件。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(venv)  ~/frida-ios-dump/ [master*] la</span><br><span class="line">total 590168</span><br><span class="line">drwxr-xr-x@ 13 franky  staff   416B  9 26 18:46 .git</span><br><span class="line">-rw-r--r--@  1 franky  staff   1.0K  5 31 20:48 LICENSE</span><br><span class="line">-rw-r--r--@  1 franky  staff   804B  5 31 20:48 README.md</span><br><span class="line">-rwxr-xr-x@  1 franky  staff    25K  9 26 11:19 dump.py</span><br><span class="line">drwxr-xr-x@  3 franky  staff    96B  9 26 18:49 path</span><br><span class="line">-rw-r--r--@  1 franky  staff   2.0K  5 31 20:48 process.sh</span><br><span class="line">-rw-r--r--@  1 franky  staff    36B  9 26 18:53 requirements.txt</span><br><span class="line">-rw-r--r--@  1 franky  staff   276M  9 26 19:35 微信.ipa</span><br></pre></td></tr></table></figure>

<p>解压缩 ipa 之后，使用 <code>otool -l Payload/WeChat.app/WeChat | grep crypt</code> 查看 WeChat 是否脱壳成功，记得一定要检查，有时候会看起一切正常然而并没有脱壳成功。如何判断是否脱壳成功呢？检查 cryptid 后面的值，是 0 就代表脱壳成功了，非 0 表示脱壳失败，该二进制文件依旧有壳。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> ~/frida-ios-dump/ [master*] otool -l Payload/WeChat.app/WeChat | grep crypt</span><br><span class="line">     cryptoff 138072064</span><br><span class="line">    cryptsize 4096</span><br><span class="line">      cryptid 0</span><br></pre></td></tr></table></figure>

<p>至此，你就得到了一个脱壳成功的 ipa 了。有了它之后才可以进行后面的分析。</p>
<h1 id="安装-Theos-创建抢红包-tweak-项目"><a href="#安装-Theos-创建抢红包-tweak-项目" class="headerlink" title="安装 Theos 创建抢红包 tweak 项目"></a>安装 Theos 创建抢红包 tweak 项目</h1><p>在 iOS 越狱环境中，”tweak” 通常指的是对系统或应用进行修改的小程序或插件。这些修改可以改变应用的外观、功能或行为。Tweaks 通常通过 Cydia、Sileo 等包管理器安装，允许用户自定义他们的设备。例如，有些 tweak 可以添加新的功能到现有的应用，或者移除一些系统限制。</p>
<p>编写 tweak 需要用到 Theos，Theos 最初是一个名为 “iphone-framework” 的项目，旨在简化命令行下的代码构建，主要用于越狱的 iOS 设备。后来，它经历了重大改进，成为 Theos —— 一个基于 Make 的灵活构建系统，专注于越狱软件开发，同时也支持为其他多个平台构建项目。安装 Theos 需要安装 Xcode 和 Homebrew。具体的安装方法可以查看 <a href="https://theos.dev/docs/installation-macos">官方文档</a></p>
<p>Theos 安装好之后，打开终端输入以下命令 <code>nic.pl</code> 创建 tweak 项目，然后按照提示输入相关信息：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> ~/ nic.pl</span><br><span class="line">NIC 2.0 - New Instance Creator</span><br><span class="line">------------------------------</span><br><span class="line">  [1.] iphone/activator_event</span><br><span class="line">  [2.] iphone/activator_listener</span><br><span class="line">  [3.] iphone/application</span><br><span class="line">  [4.] iphone/application_swift</span><br><span class="line">  [5.] iphone/application_swiftui</span><br><span class="line">  [6.] iphone/control_center_module-11up</span><br><span class="line">  [7.] iphone/cydget</span><br><span class="line">  [8.] iphone/flipswitch_switch</span><br><span class="line">  [9.] iphone/framework</span><br><span class="line">  [10.] iphone/library</span><br><span class="line">  [11.] iphone/notification_center_widget</span><br><span class="line">  [12.] iphone/notification_center_widget-7up</span><br><span class="line">  [13.] iphone/null</span><br><span class="line">  [14.] iphone/preference_bundle</span><br><span class="line">  [15.] iphone/preference_bundle_swift</span><br><span class="line">  [16.] iphone/theme</span><br><span class="line">  [17.] iphone/tool</span><br><span class="line">  [18.] iphone/tool_swift</span><br><span class="line">  [19.] iphone/tweak</span><br><span class="line">  [20.] iphone/tweak_swift</span><br><span class="line">  [21.] iphone/tweak_with_simple_preferences</span><br><span class="line">  [22.] iphone/xpc_service</span><br><span class="line">  [23.] iphone/xpc_service_modern</span><br><span class="line">Choose a Template (required): 19</span><br><span class="line">Project Name (required): redEnveloper</span><br><span class="line">Package Name [com.yourcompany.redenveloper]:</span><br><span class="line">Author/Maintainer Name [franky]:</span><br><span class="line">[iphone/tweak] MobileSubstrate Bundle filter [com.apple.springboard]: com.tencent.xin</span><br><span class="line">[iphone/tweak] List of applications to terminate upon installation (space-separated, <span class="string">&#x27;-&#x27;</span> <span class="keyword">for</span> none) [SpringBoard]: WeChat</span><br><span class="line">Instantiating iphone/tweak <span class="keyword">in</span> redEnveloper/...</span><br><span class="line">Done.</span><br></pre></td></tr></table></figure>

<p>这里我们填写了工程名为 redEnveloper</p>
<p>然后在 <code>[iphone/tweak] MobileSubstrate Bundle filter [com.apple.springboard]:</code> 这一栏输入的 <code>com.tencent.xin</code> 是微信的唯一标识，也就是 CFBundleIdentifier，至于如何知道微信的 CFBundleIdentifier 是这个的，其实有很多方法。。。</p>
<p>然后在 <code>[iphone/tweak] List of applications to terminate upon installation (space-separated, &#39;-&#39; for none) [SpringBoard]: </code> 这一栏输入 <code>WeChat</code> 这是微信的进程名。</p>
<p>其他项都可以直接回车使用默认值就行了。我们先认识一下 tweak 项目都有哪些文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> ~/redEnveloper/ tree</span><br><span class="line">.</span><br><span class="line">├── Makefile</span><br><span class="line">├── Tweak.xm</span><br><span class="line">├── control</span><br><span class="line">└── redEnveloper.plist</span><br><span class="line"></span><br><span class="line">1 directory, 4 files</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>tree</code> 命令默认是没有的，可以使用 <code>brew install tree</code> 安装。</p>
</blockquote>
<p>在 iOS Tweak 项目中，这些文件和文件夹的作用如下：</p>
<ol>
<li><p><strong>Makefile</strong>：用于编译和构建你的 tweak。它定义了如何将源代码（如 Tweak.x）编译成动态库，包括所需的编译器选项和依赖关系。</p>
</li>
<li><p><strong>Tweak.x</strong>：这是你的插件主要源代码文件，通常包含了你想要实现的功能的代码。你可以在这里编写用于修改系统行为或应用程序功能的代码。</p>
</li>
<li><p><strong>control</strong>：这个文件包含关于你的 tweak 的元数据，例如名称、版本、作者、依赖关系等。它通常用于生成一个可安装的包。</p>
</li>
<li><p><strong>packages</strong>：这个文件夹通常用于存放编译后的 deb 包，方便发布和安装。</p>
</li>
<li><p><strong>redEnveloper.plist</strong>：这是一个属性列表文件，这个部分用于定义哪些应用程序的行为会受到你的 tweak 影响。</p>
</li>
</ol>
<h1 id="实现抢红包插件的-UI-代码"><a href="#实现抢红包插件的-UI-代码" class="headerlink" title="实现抢红包插件的 UI 代码"></a>实现抢红包插件的 UI 代码</h1><p>实现微信自动抢红包功能可以完全不提供 UI 界面，这样每个红包消息过来的时候就自动拆开了。但这样不太好，而且实际的情况下不合适的红包自动抢了会很尴尬，另外从学习逆向开发的角度来说，多练习下也是不错的。但这个功能 UI 不是重点，所以我们还是尽可能的简单处理，只在微信的设置页面添加一个 cell 左边显示自动抢红包功能，右边显示一个开关用来控制该功能。</p>
<p>现在很多人可能会好奇，Tweak.x 编写什么代码呢？.x 文件里面写 Logos 语法的代码。Logos 是一个基于 Perl 语言的正则表达式的预处理器，它通过优雅的类似 Objective-C 的语法简化了为 Objective-C 方法和 C 函数创建 hook 所需的模板代码。如果熟悉 Objective-C 的 runtime 的话，就可以理解为 Logos 语法将平时我们自己通过 runtime 编写的 hook 代码简化了。Logos 语法也没有很多，官方文档在<a href="https://theos.dev/docs/logos-syntax">这里</a>。</p>
<p>了解或熟悉 Logos 语法之后，接下来就是考虑对哪些类，哪些方法进行 hook 了，至于什么是 hook，<a href="hook/hook.md">这篇文章</a> 有介绍。按照刚刚所说的 UI 需求的话，就需要分析微信的设置界面所用的类，和实现的逻辑了。这里会用到界面分析工具 <a href="%E8%BF%99%E9%87%8C%E5%86%99%E8%BF%87%E6%96%87%E7%AB%A0">Reveal</a> 或者 Lookin 等类似工具用于查看设置界面的控制器类，也可以用 <a href="%E8%BF%99%E9%87%8C%E5%86%99%E8%BF%87%E6%96%87%E7%AB%A0">cycript</a>，<a href="%E8%BF%99%E9%87%8C%E4%B9%9F%E6%9C%89%E6%96%87%E7%AB%A0%E4%BA%86">lldb</a> 等命令行工具查看。知道了是哪个控制器类之后，就可以使用 <a href="%E9%9C%80%E8%A6%81%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0">class-dump</a> 工具对前面脱壳过的微信可执行文件导出所有的头文件，阅读对应的控制器类的头文件了。再结合正向开发的经验，分析应该 hook 哪些类的哪些方法。</p>
<p>这里我们以 Reveal 为例，作者使用的是 Reveal46，因为 Reveal47 要求 iOS13 以上了，老版本可以在<a href="https://revealapp.com/updates/46/">官网下载</a>。</p>
<p>在手机上的 Cydia 搜索安装 Reveal2Loader 并安装。安装成功之后还需要再去设置中，找到 Reveal 项，进入 Enabled Applications 打开微信的右侧开关，这样才会在启动微信的时候注入 Reveal 服务。Reveal2Loader 自带的 RevealServer.framework 很古老了，大概率和你 Mac 上的 Reveal 是不匹配的，但是不用担心，可以将 Mac 上 Reveal 的 RevealServer.framework 复制到越狱设备的 &#x2F;Library&#x2F;Frameworks 文件夹下。可以使用任何你熟悉的方式，如：使用 iFunBox，使用 scp 命令。这里以 scp 命令为例子：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> ~/ scp -r -P 2222 /Applications/Reveal.app/Contents/SharedSupport/iOS-Libraries/RevealServer.framework root@localhost:/Library/Frameworks</span><br><span class="line">CodeResources                                                                                                                                                100% 2754     1.1MB/s   00:00</span><br><span class="line">RevealServer.h                                                                                                                                               100%  309   197.0KB/s   00:00</span><br><span class="line">RevealServer                                                                                                                                                 100%   12MB  38.1MB/s   00:00</span><br><span class="line">copy_and_codesign_revealserver.sh                                                                                                                            100% 1399   700.3KB/s   00:00</span><br><span class="line">module.modulemap                                                                                                                                             100%  105    59.6KB/s   00:00</span><br><span class="line">Info.plist</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：需要提前进行端口转发 iproxy 2222:22</p>
</blockquote>
<p>RevealServer.framework 的路径可以通过下图中的方式找到</p>
<p><img src="Xnip2024-10-13_00-59-11.jpg"></p>
<p>如果你使用的是较新的 iOS 版本，可能 Reveal2Loader 或者 LookinLoader 都无法正常使用了，没关系，作者都已经发布了适配 rootless 越狱的和较新版本的 <a href="https://github.com/masterKing/RevealLoader2">RevealLoader2</a> 和 <a href="https://github.com/masterKing/LookinLoader2">LookinLoader2</a>。</p>
<p>最终，越狱设备打开微信进入到设置页面并且 Mac 打开 Reveal，就可以在 Reveal 中看到微信 APP 了。我们选择带有 USB 图标的微信，这是通过 USB 进行数据传输的方式，另一个是通过 WiFi 传输数据，在网络不好的情况下会比较慢。</p>
<p>Reveal 的显示如下图：</p>
<p><img src="Xnip2024-10-13_13-09-41.jpg"></p>
<p>如果 <code>WCTableView</code> 对象的数据源就是 <code>NewSettingViewController</code> 对象那就可以直接对 <code>NewSettingViewController</code> 进行 hook 了。但如果不是的话，就没有必要对 <code>NewSettingViewController</code> 进行 hook 了没有意义。Reveal 无法进行命令交互，给我们提供更多的信息，这一点 Lookin 做的更好。这时，可以使用 cycript 或 lldb 进行验证。这里以 cycript 为例：</p>
<p>在越狱设备上进入 Cydia，搜索 Cycript 并安装，之后我们远程登录到越狱设备就可以使用 Cycript 了。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> ~/ ssh root@localhost -p 2222</span><br><span class="line">iPhone5s:~ root# cycript -p WeChat</span><br><span class="line">cy# <span class="comment">#0x117f56e00</span></span><br><span class="line"><span class="comment">#&quot;&lt;WCTableView: 0x117f56e00; baseClass = UITableView; frame = (0 0; 320 568); clipsToBounds = YES; gestureRecognizers = &lt;NSArray: 0x286cee370&gt;; layer = &lt;CALayer: 0x2827e89e0&gt;; contentOffset: &#123;0, -64&#125;; contentSize: &#123;320, 942&#125;; adjustedContentInset: &#123;64, 0, 0, 0&#125;&gt;&quot;</span></span><br><span class="line">cy# <span class="comment">#0x117f56e00.dataSource</span></span><br><span class="line"><span class="comment">#&quot;&lt;WCTableViewManager: 0x286cef9f0&gt;&quot;</span></span><br><span class="line">cy#</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示：0x117f56e00 这个内存地址是从 Reveal 中获取的</p>
</blockquote>
<p>结果发现 <code>WCTableView</code> 对象 0x117f56e00 的 <code>dataSource</code> 并不是控制器 <code>NewSettingViewController</code> 而是一个 <code>WCTableViewManager</code> 类的对象。那么接下来就是对 <code>WCTableViewManager</code> 类的头文件进行分析了。其实知道了 <code>WCTableView</code> 的数据源是 <code>WCTableViewManager</code> 之后也可以不用再分析下去了，<code>WCTableViewManager</code> 一定会实现 <code>UITableView</code> 的数据源方法的。但是为了方便后面编写 tweak 代码，我们这里还是要介绍一下 class-dump。</p>
<p><a href="https://github.com/nygard/class-dump">class-dump</a> 是一个用于从 macOS 和 iOS 应用的 Mach-O 可执行文件中提取 Objective-C 类、协议和方法声明的工具。它不进行完整的反汇编或反编译，而是专注于提取头文件（.h 文件）中的结构信息，从而帮助开发者和逆向工程师了解应用的类结构和接口。</p>
<p>使用 class-dump 提取微信的头文件的命令如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> ~/frida-ios-dump/ [master*] class-dump -H Payload/WeChat.app/WeChat -o WeChatHeaders</span><br><span class="line">2024-10-06 20:38:38.536 class-dump[80038:3372682] Unknown load <span class="built_in">command</span>: 0x00000032</span><br><span class="line">2024-10-06 20:38:52.655 class-dump[80038:3372682] Warning: Parsing instance variable <span class="built_in">type</span> failed, ready_</span><br><span class="line">2024-10-06 20:38:58.673 class-dump[80038:3372682] Warning: Parsing instance variable <span class="built_in">type</span> failed, scheme</span><br><span class="line">2024-10-06 20:38:58.673 class-dump[80038:3372682] Warning: Parsing instance variable <span class="built_in">type</span> failed, queue</span><br><span class="line">2024-10-06 20:38:58.676 class-dump[80038:3372682] Warning: Parsing instance variable <span class="built_in">type</span> failed, svrID</span><br><span class="line">...</span><br><span class="line">省略很多打印</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这里我们需要用到刚刚砸壳成功的微信，否则是无法成功提取头文件的。使用 <code>la</code> 查看当前文件夹下的内容，可以看到多了一个 WeChatHeaders 的文件，里面有接近3万个的头文件。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> ~/frida-ios-dump/ [master*] la</span><br><span class="line">total 526064</span><br><span class="line">-rw-r--r--@     1 Franky  staff   6.0K Jul  2 16:39 .DS_Store</span><br><span class="line">drwxr-xr-x     13 Franky  staff   416B Oct  6 18:57 .git</span><br><span class="line">-rw-r--r--      1 Franky  staff    30B May  4  2023 .gitignore</span><br><span class="line">-rw-r--r--      1 Franky  staff   1.0K May  4  2023 LICENSE</span><br><span class="line">drwxr-xr-x      3 Franky  staff    96B Oct  6 20:29 Payload</span><br><span class="line">-rw-r--r--@     1 Franky  staff   3.2K May  4  2023 README.md</span><br><span class="line">drwxr-xr-x  29607 Franky  staff   925K Oct  6 20:39 WeChatHeaders</span><br><span class="line">-rw-r--r--      1 Franky  staff    11K May  4  2023 dump.js</span><br><span class="line">-rwxr-xr-x@     1 Franky  staff    11K Apr  2  2024 dump.py</span><br><span class="line">-rwxr-xr-x      1 Franky  staff   2.0K May  4  2023 process.sh</span><br><span class="line">-rw-r--r--@     1 Franky  staff   157B May  4  2023 requirements.txt</span><br><span class="line">-rw-r--r--      1 Franky  staff   255M Oct  6 20:30 微信.ipa</span><br></pre></td></tr></table></figure>

<p>使用 Sublime Text 打开这个 WeChatHeaders 文件夹，Sublime 是一个编辑器，对于这种上万份的头文件不推荐用 Xcode 打开，会很卡顿。当然也可以用你熟悉的其他编辑器打开。搜索 <code>WCTableViewManager</code> 就可以看到对应的头文件内容了。</p>
<p><img src="Xnip2024-10-06_20-49-33.png"></p>
<p>有了这个头文件之后，我们在编写 tweak 的时候，就可以方便的进行复制粘贴了，而不是每一行每一句代码，如这里的 <code>UITableView</code> 的数据源方法都自己敲一遍。</p>
<p>最后同样是使用 Sublime 打开我们之前创建 tweak 项目，选择 Tweak.x 文件删掉默认生成的代码进行编辑，代码如下：</p>
<figure class="highlight objective-c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"><span class="comment">// 界面代码</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WCTableViewManager</span></span></span><br><span class="line">- (<span class="type">long</span> <span class="type">long</span>)numberOfSectionsInTableView:(<span class="type">id</span>)arg1;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">%hook WCTableViewManager</span><br><span class="line"></span><br><span class="line">- (<span class="type">double</span>)tableView:(<span class="built_in">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class="type">id</span>)indexPath&#123;</span><br><span class="line">    <span class="keyword">if</span>([tableView.nextResponder.nextResponder isKindOfClass:%c(NewSettingViewController)]</span><br><span class="line">       &amp;&amp;([indexPath section] == [<span class="keyword">self</span> numberOfSectionsInTableView:tableView] - <span class="number">1</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">44</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> %orig;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">id</span>)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="type">id</span>)indexPath&#123;</span><br><span class="line">    <span class="keyword">if</span>([tableView.nextResponder.nextResponder isKindOfClass:%c(NewSettingViewController)]</span><br><span class="line">       &amp;&amp;([indexPath section] == [<span class="keyword">self</span> numberOfSectionsInTableView:tableView] - <span class="number">1</span>))&#123;</span><br><span class="line">        <span class="built_in">UITableViewCell</span> * cell = [[<span class="built_in">UITableViewCell</span> alloc] initWithStyle:(<span class="built_in">UITableViewCellStyleDefault</span>) reuseIdentifier:<span class="literal">nil</span>];</span><br><span class="line">        cell.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">        <span class="keyword">if</span>([indexPath row] == <span class="number">0</span>)&#123;</span><br><span class="line">            cell.textLabel.text = <span class="string">@&quot;自动抢红包&quot;</span>;</span><br><span class="line">            <span class="built_in">UISwitch</span> * switchView = [[<span class="built_in">UISwitch</span> alloc] init];</span><br><span class="line">            switchView.on = [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] boolForKey:<span class="string">@&quot;RESWITCHKEY&quot;</span>];</span><br><span class="line">            [switchView addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(switchChang:) forControlEvents:(<span class="built_in">UIControlEventValueChanged</span>)];</span><br><span class="line">            cell.accessoryView = switchView;</span><br><span class="line">            <span class="built_in">NSBundle</span> *bundle = [<span class="built_in">NSBundle</span> bundleWithPath:<span class="string">@&quot;/Library/MobileSubstrate/DynamicLibraries/redEnveloper.bundle/&quot;</span>];</span><br><span class="line">            <span class="built_in">NSString</span> *imageName = ([[<span class="built_in">NSUserDefaults</span> standardUserDefaults] boolForKey:<span class="string">@&quot;RESWITCHKEY&quot;</span>] == <span class="number">1</span>) ? <span class="string">@&quot;locked.png&quot;</span> : <span class="string">@&quot;unlocked.png&quot;</span>;</span><br><span class="line">            <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:imageName inBundle:bundle compatibleWithTraitCollection:<span class="literal">nil</span>];</span><br><span class="line">            cell.imageView.image = image;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cell;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> %orig;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">long</span> <span class="type">long</span>)tableView:(<span class="built_in">UITableView</span> *)tableView numberOfRowsInSection:(<span class="type">long</span> <span class="type">long</span>)section&#123;</span><br><span class="line">    <span class="keyword">if</span>([tableView.nextResponder.nextResponder isKindOfClass:%c(NewSettingViewController)]</span><br><span class="line">       &amp;&amp;(section == [<span class="keyword">self</span> numberOfSectionsInTableView:tableView] - <span class="number">1</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> %orig;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">long</span> <span class="type">long</span>)numberOfSectionsInTableView:(<span class="built_in">UITableView</span> *)tableView&#123;</span><br><span class="line">    <span class="keyword">if</span>([tableView.nextResponder.nextResponder isKindOfClass:%c(NewSettingViewController)])&#123;</span><br><span class="line">        <span class="keyword">return</span> %orig+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> %orig;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">%new</span><br><span class="line">-(<span class="type">void</span>)switchChang:(<span class="built_in">UISwitch</span> *)switchView&#123;</span><br><span class="line">    [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] setBool:switchView.isOn forKey:<span class="string">@&quot;RESWITCHKEY&quot;</span>];</span><br><span class="line">    [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] synchronize];</span><br><span class="line">    [MSHookIvar&lt;<span class="built_in">UITableView</span> *&gt;(<span class="keyword">self</span>,<span class="string">&quot;_tableView&quot;</span>) reloadData];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">%end</span><br></pre></td></tr></table></figure>

<p>这段代码对于有经验的 iOS 应用开发者来说，即很熟悉又有点陌生，陌生的是一些 Logos 语法，而熟悉的是这代码基本就像是 Objective-C。这段代码中的<code>[MSHookIvar&lt;UITableView *&gt;(self,&quot;_tableView&quot;) reloadData];</code>用到了 Objective-C++ 的语法，直接编译会不通过。需要将 tweak.x 改为 tweak.xm，同时修改 Makefile 中的 <code>redEnveloper_FILES = Tweak.x</code> 为 <code>redEnveloper_FILES = Tweak.xm</code>。这样才能通过编译。同时我们使用了两张图片作为开关的状态显示。最终项目的结构如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> ~/redEnveloper/ tree</span><br><span class="line">.</span><br><span class="line">├── Makefile</span><br><span class="line">├── Tweak.xm</span><br><span class="line">├── control</span><br><span class="line">├── layout</span><br><span class="line">│   └── Library</span><br><span class="line">│       └── MobileSubstrate</span><br><span class="line">│           └── DynamicLibraries</span><br><span class="line">│               └── redEnveloper.bundle</span><br><span class="line">│                   ├── locked.png</span><br><span class="line">│                   └── unlocked.png</span><br><span class="line">└── redEnveloper.plist</span><br><span class="line"></span><br><span class="line">6 directories, 6 files</span><br></pre></td></tr></table></figure>

<p>其中 layout 及下面的子文件夹是我们自己创建的，在编译的时候，Thoes 会将这个文件夹下面的内容移动到越狱设备的对应文件路径下。意思就是在编译安装之后，越狱设备的 <code>/Library/MobileSubstrate/DynamicLibraries/redEnveloper.bundle</code> 路径下放了两张图片。这个 layout 文件夹相当于 iOS 文件系统的根目录一样。</p>
<p>这样界面相关的代码就全部完成了。我们编译打包安装看看效果：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> ~/iOSREProject/redEnveloper/ make clean &amp;&amp; make package &amp;&amp; make install</span><br><span class="line">==&gt; Cleaning…</span><br><span class="line">&gt; Making all <span class="keyword">for</span> tweak redEnveloper…</span><br><span class="line">==&gt; Preprocessing Tweak.xm…</span><br><span class="line">==&gt; Preprocessing Tweak.xm…</span><br><span class="line">==&gt; Compiling Tweak.xm (arm64)…</span><br><span class="line">==&gt; Compiling Tweak.xm (arm64e)…</span><br><span class="line">==&gt; Linking tweak redEnveloper (arm64)…</span><br><span class="line">ld: warning: -multiply_defined is obsolete</span><br><span class="line">==&gt; Generating debug symbols <span class="keyword">for</span> redEnveloper…</span><br><span class="line">==&gt; Linking tweak redEnveloper (arm64e)…</span><br><span class="line">ld: warning: -multiply_defined is obsolete</span><br><span class="line">==&gt; Generating debug symbols <span class="keyword">for</span> redEnveloper…</span><br><span class="line">==&gt; Merging tweak redEnveloper…</span><br><span class="line">==&gt; Signing redEnveloper…</span><br><span class="line">&gt; Making stage <span class="keyword">for</span> tweak redEnveloper…</span><br><span class="line">dm.pl: building package `com.yourcompany.redenveloper:iphoneos-arm<span class="string">&#x27; in `./packages/com.yourcompany.redenveloper_0.0.1-15+debug_iphoneos-arm.deb&#x27;</span></span><br><span class="line">==&gt; Installing…</span><br><span class="line">(Reading database ... 7856 files and directories currently installed.)</span><br><span class="line">Preparing to unpack /tmp/_theos_install.deb ...</span><br><span class="line">Unpacking com.yourcompany.redenveloper (0.0.1-15+debug) over (0.0.1-14+debug) ...</span><br><span class="line">Setting up com.yourcompany.redenveloper (0.0.1-15+debug) ...</span><br><span class="line">Processing triggers <span class="keyword">for</span> org.coolstar.sileo (2.5) ...</span><br><span class="line">Not running <span class="keyword">in</span> Sileo. Trigger UICache</span><br><span class="line">==&gt; Unloading WeChat…</span><br></pre></td></tr></table></figure>

<p>这里使用了 <code>&amp;&amp;</code> 符号将多个命令合并一起执行了。命令运行时，手机上的微信会被杀死。命令完成后我们打开微信，进入设置页面，滑倒最底部就会看到新增的界面了。 </p>
<img src="IMG_0002.PNG" alt="IMG_0002.PNG" width="50%">



<h1 id="实现抢红包插件的功能代码"><a href="#实现抢红包插件的功能代码" class="headerlink" title="实现抢红包插件的功能代码"></a>实现抢红包插件的功能代码</h1><p>实现自动抢红包功能的思路就是，在我们收到消息的时候，判断是红包消息，就调用打开红包的代码。完整的分析流程会十分耗时耗力，这里只大概的讲述一下。实际完成抢红包功能之后就会发现，实际所写的代码并不多，但是分析出如何写才是真正耗费时间精力的地方。</p>
<h2 id="1-定位收到微信消息的方法"><a href="#1-定位收到微信消息的方法" class="headerlink" title="1.定位收到微信消息的方法"></a>1.定位收到微信消息的方法</h2><p>为了定位收到微信消息的方法，我们可以从聊天页面出发，hook 聊天页面的所有方法，然后让对方发送消息过来，从而发现接收消息时调用了哪些方法。</p>
<p>Theos 附带了一个 logify.pl 命令行程序，它将 Objective-C 头文件（或任何包含 @interface 和方法定义的文件）转换为 Logos 输入文件，以便记录和打印所有函数调用。先使用 Reveal 查看微信聊天页面，可以知道是 <code>BaseMsgContentViewController</code> 类。然后将使用 logify.pl 将这个类的头文件转成 xm 文件并添加到我们抢红包的 tweak 工程中。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> ~/frida-ios-dump/ [master*] <span class="built_in">cd</span> ~/redEnveloper</span><br><span class="line"> ~/redEnveloper/ logify.pl ~/frida-ios-dump/WeChatHeaders/BaseMsgContentViewController.h &gt; ./BaseMsgContentViewController.xm</span><br><span class="line"> ~/redEnveloper/ <span class="built_in">ls</span></span><br><span class="line">BaseMsgContentViewController.xm Tweak.xm                        layout                          redEnveloper.plist</span><br><span class="line">Makefile                        control                         packages</span><br></pre></td></tr></table></figure>

<p>可以看到使用 logify.pl 之后多出了一个 <code>BaseMsgContentViewController.xm</code> 文件。还需要在 Makefile 文件中添加这个文件，Theos 才会在编译时处理这个文件。makefile 文件内容如下所示:</p>
<figure class="highlight objective-c++"><table><tr><td class="code"><pre><span class="line">TARGET := iphone:clang:latest:<span class="number">7.0</span></span><br><span class="line">INSTALL_TARGET_PROCESSES = WeChat</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">include $(THEOS)/makefiles/common.mk</span><br><span class="line"></span><br><span class="line">TWEAK_NAME = redEnveloper</span><br><span class="line"></span><br><span class="line">redEnveloper_FILES = Tweak.xm BaseMsgContentViewController.xm</span><br><span class="line">redEnveloper_CFLAGS = -fobjc-arc</span><br><span class="line"></span><br><span class="line">include $(THEOS_MAKE_PATH)/tweak.mk</span><br></pre></td></tr></table></figure>

<p>这个时候<code>make package</code>会报很多错误，主要是 logify.pl 生成的文件并不能直接使用，我们一起解决:</p>
<ul>
<li>添加 <code>UIKit</code> 头文件</li>
<li>声明用到的类和协议</li>
<li>移除 <code>- (void).cxx_destruct &#123; %log; %orig; &#125;</code> 方法</li>
<li>将 <code>CDUnknownBlockType</code> 改为 id</li>
<li>删掉 <code>inout</code> </li>
<li>Makefile 中给 redEnveloper_CFLAGS &#x3D; -fobjc-arc 后面添加 -Wno-ignored-qualifiers 编译器标记</li>
</ul>
<p>再次<code>make package</code>就可以成功编译了。之后<code>make install</code>安装到越狱设备上。我们在微信的聊天页面等待接收消息，然后打开 Mac 的控制台程序，选择我们的越狱设备，右侧搜索框输入 WeChat 过滤其他不关心的打印信息。接下来就可以给我们的越狱设备发生微信消息了，查看控制器台的打印信息，可以发现每次收到新消息的时候，都会调用以下这些方法，而高亮选中的方法带有一个 <code>addMessageNode:</code> 参数令人感到兴奋。</p>
<p><img src="Xnip2024-10-13_15-09-33.jpg"></p>
<p>尝试对这个方法下断点，打印它的调用堆栈，看能否看到有用的信息。这里运用到了 lldb+debugserver 远程调试</p>
<p>debugserver 和 lldb 是可以通过无线网络进行连接的，但是为了速度考虑，我们还是通过 USB 进行连接会更好，所以我们先进行端口映射，将越狱设备的 3333 端口和 Mac 电脑的 3333 端口关联。然后都通过访问本机的 3333 端口就可以通过 USB 建立连接了。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> ~/ iproxy 3333:3333</span><br><span class="line">Creating listening port 3333 <span class="keyword">for</span> device port 3333</span><br><span class="line">waiting <span class="keyword">for</span> connection</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>越狱设备打开包管理器 Sileo 或 Cydia 搜索 debugserver 并安装。安装好之后，我们就可以在 iOS 上运行 debugserver 了。远程登录到越狱设备，然后运行 debugserver 程序附加到微信进程。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> ~/ ssh root@localhost -p 2222</span><br><span class="line">iPhone5s:~ root# debugserver-10 localhost:3333 --attach=WeChat</span><br><span class="line">debugserver-@(#)PROGRAM:LLDB  PROJECT:lldb-10.0.0</span><br><span class="line"> <span class="keyword">for</span> arm64.</span><br><span class="line">Attaching to process WeChat...</span><br><span class="line">Listening to port 3333 <span class="keyword">for</span> a connection from localhost...</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>然后再新建一个终端窗口，进入 lldb 交互，进行连接：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> ~/ lldb</span><br><span class="line">(lldb) process connect connect://localhost:3333</span><br><span class="line">Process 11908 stopped</span><br><span class="line">* thread <span class="comment">#1, queue = &#x27;com.apple.main-thread&#x27;, stop reason = signal SIGSTOP</span></span><br><span class="line">    frame <span class="comment">#0: 0x000000018b5840f4 libsystem_kernel.dylib`mach_msg_trap + 8</span></span><br><span class="line">libsystem_kernel.dylib`mach_msg_trap:</span><br><span class="line">-&gt;  0x18b5840f4 &lt;+8&gt;: ret</span><br><span class="line"></span><br><span class="line">libsystem_kernel.dylib`mach_msg_overwrite_trap:</span><br><span class="line">    0x18b5840f8 &lt;+0&gt;: mov    x16, <span class="comment">#-0x20</span></span><br><span class="line">    0x18b5840fc &lt;+4&gt;: svc    <span class="comment">#0x80</span></span><br><span class="line">    0x18b584100 &lt;+8&gt;: ret</span><br><span class="line">Target 0: (WeChat) stopped.</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure>

<p>此时，我们就可以像在 Xcode 控制台里 po 一样调试微信了。从上面控制台的打印中或者 Reveal 里面，我们可以得到 <code>BaseMsgContentViewController</code> 的内存地址。调用对象的一个隐藏私有方法 <code>__methodDescriptionForClass:</code> 来获取它所有的方法。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(lldb) po [0x117dad600 __methodDescriptionForClass:(<span class="built_in">id</span>)[0x117dad600 class]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> BaseMsgContentViewController:</span><br><span class="line">	Class Methods:</span><br><span class="line">		+ (void) reload:(<span class="built_in">id</span>)arg1 sections:(<span class="built_in">id</span>)arg2 withRowAnimation:(long)arg3; (0x118372ef4)</span><br><span class="line">	Properties:</span><br><span class="line">		@property (weak, nonatomic) MMPageSheetAdapter* pageSheetAdapter;</span><br><span class="line">		@property (<span class="built_in">readonly</span>) unsigned long <span class="built_in">hash</span>;</span><br><span class="line">		@property (<span class="built_in">readonly</span>) Class superclass;</span><br><span class="line">		@property (<span class="built_in">readonly</span>, copy) NSString* description;</span><br><span class="line">		@property (<span class="built_in">readonly</span>, copy) NSString* debugDescription;</span><br><span class="line">		@property (<span class="built_in">readonly</span>) unsigned long <span class="built_in">hash</span>;</span><br><span class="line">		@property (<span class="built_in">readonly</span>) Class superclass;</span><br><span class="line">		@property (<span class="built_in">readonly</span>, copy) NSString* description;</span><br><span class="line">		@property (<span class="built_in">readonly</span>, copy) NSString* debugDescription;</span><br><span class="line">		@property (retain, nonatomic) MMMsgContentNavBar* tipsNavBar;  (@synthesize tipsNavBar = _tipsNavBar;)</span><br><span class="line">		@property (retain, nonatomic) MMNewMsgContentNavBar* tipsNewNavBar;  (@synthesize tipsNewNavBar = _tipsNewNavBar;)</span><br><span class="line">		@property (retain, nonatomic) MessageTipView* messageTipView;  (@synthesize messageTipView = _messageTipView;)</span><br><span class="line">		@property (retain, nonatomic) UIScreenEdgePanGestureRecognizer* popBackInteractivePopGesture;  (@synthesize popBackInteractivePopGesture = _popBackInteractivePopGesture;)</span><br><span class="line">		@property (retain, nonatomic) UIColor* chatroomBkgColor;  (@synthesize chatroomBkgColor = _chatroomBkgColor;)</span><br><span class="line">		@property (retain, nonatomic) CMessageWrap* locateMsg;  (@synthesize locateMsg = _locateMsg;)</span><br><span class="line">		@property (weak, nonatomic) &lt;BaseMsgContentDelgate&gt;* m_delegate;  (@synthesize m_delegate = m_delegate;)</span><br><span class="line">		@property (weak, nonatomic) &lt;BaseMsgContentInBackgroundThreadDelgate&gt;* m_backgroundThreadDelegate;  (@synthesize m_backgroundThreadDelegate = m_backgroundThreadDelegate;)</span><br><span class="line">		@property (retain, nonatomic) MMInputToolView* toolView;  (@synthesize toolView = _inputToolView;)</span><br><span class="line">		@property (retain, nonatomic) MMTimer* m_LockerTimer;  (@synthesize m_LockerTimer = m_LockerTimer;)</span><br><span class="line">		@property (retain, nonatomic) UIView* m_msgReceivingTipsView;  (@synthesize m_msgReceivingTipsView = m_msgReceivingTipsView;)</span><br><span class="line">		@property (retain, nonatomic) NSMutableArray* m_shareContacts;  (@synthesize m_shareContacts = m_shareContacts;)</span><br><span class="line">		@property (nonatomic) BOOL m_bIsInMainFrame;  (@synthesize m_bIsInMainFrame = _m_bIsInMainFrame;)</span><br><span class="line">		@property (nonatomic) unsigned long m_searchScene;  (@synthesize m_searchScene = m_searchScene;)</span><br><span class="line">		@property (retain, nonatomic) BadRoomLogicController* m_badRoomLogicController;  (@synthesize m_badRoomLogicController = _m_badRoomLogicController;)</span><br><span class="line">		@property (retain, nonatomic) MMRichTextCoverView* richTextCoverView;  (@synthesize richTextCoverView = _richTextCoverView;)</span><br><span class="line">		@property (retain, nonatomic) RichTextView* richTextView;  (@synthesize richTextView = _richTextView;)</span><br><span class="line">		@property (weak, nonatomic) MMInputMsgReferView* msgReferView;  (@synthesize msgReferView = _msgReferView;)</span><br><span class="line">		@property (nonatomic) unsigned int uiMultiSelectMaxCount;  (@synthesize uiMultiSelectMaxCount = _uiMultiSelectMaxCount;)</span><br><span class="line">		@property (nonatomic) unsigned int uiMultiSelectMaxMegaBytes;  (@synthesize uiMultiSelectMaxMegaBytes = _uiMultiSelectMaxMegaBytes;)</span><br><span class="line">		@property (retain, nonatomic) ChatRoomHistoryShareStat* oRoomHistoryStat;  (@synthesize oRoomHistoryStat = _oRoomHistoryStat;)</span><br><span class="line">		@property (retain, nonatomic) UIView* chatRoomDismissedView;  (@synthesize chatRoomDismissedView = _chatRoomDismissedView;)</span><br><span class="line">		@property (nonatomic) BOOL dismissWithoutReset;  (@synthesize dismissWithoutReset = _dismissWithoutReset;)</span><br><span class="line">		@property (<span class="built_in">readonly</span>) unsigned long <span class="built_in">hash</span>;</span><br><span class="line">		@property (<span class="built_in">readonly</span>) Class superclass;</span><br><span class="line">		@property (<span class="built_in">readonly</span>, copy) NSString* description;</span><br><span class="line">		@property (<span class="built_in">readonly</span>, copy) NSString* debugDescription;</span><br><span class="line">	Instance Methods:</span><br><span class="line">		- (Class) superclass; (0x11838d270)</span><br><span class="line">		- (unsigned long) <span class="built_in">hash</span>; (0x11838d204)</span><br><span class="line">		- (<span class="built_in">id</span>) description; (0x11838d144)</span><br><span class="line">		- (<span class="built_in">id</span>) debugDescription; (0x11838d084)</span><br><span class="line">		...</span><br><span class="line">		...</span><br><span class="line">		方法太多，后续都省略了</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用搜索功能，找到我们需要的方法 addMessageNode ：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">		- (void) MoreMsgBtnUpdate:(unsigned int)arg1 unReadCount:(unsigned int)arg2; (0x118382ec0)</span><br><span class="line">		- (void) setM_searchScene:(unsigned long)arg1; (0x1183744a0)</span><br><span class="line">		- (void) addNoMoreMessageNode:(<span class="built_in">id</span>)arg1 addMoreMsg:(BOOL)arg2; (0x1183837f4)</span><br><span class="line">		- (void) addMessageNode:(<span class="built_in">id</span>)arg1 layout:(BOOL)arg2 addMoreMsg:(BOOL)arg3; (0x11838347c)</span><br><span class="line">		- (void) updateBanner; (0x11837a644)</span><br><span class="line">		- (long) getTextViewMarkedLength; (0x118385bb8)</span><br><span class="line">		- (void) CancelRecording; (0x11837f898)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>后面的地址就是方法实现的内存地址。对它下断点，然后让程序继续运行</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(lldb) breakpoint <span class="built_in">set</span> --address 0x11838347c</span><br><span class="line">Breakpoint 1: <span class="built_in">where</span> = redEnveloper.dylib`_logos_method$_ungrouped$BaseMsgContentViewController$addMessageNode$layout$addMoreMsg$(BaseMsgContentViewController*, objc_selector*, objc_object*, bool, bool) at BaseMsgContentViewController.xm:491, address = 0x000000011838347c</span><br><span class="line">(lldb) c</span><br><span class="line">Process 12265 resuming</span><br></pre></td></tr></table></figure>

<p>再次发送一条新的消息过来，就可以看到断点被命中了：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Process 12265 stopped</span><br><span class="line">* thread <span class="comment">#1, queue = &#x27;com.apple.main-thread&#x27;, stop reason = breakpoint 1.1</span></span><br><span class="line">    frame <span class="comment">#0: 0x000000011838347c redEnveloper.dylib` _logos_method$_ungrouped$BaseMsgContentViewController$addMessageNode$layout$addMoreMsg$(self=0x0000000128322860, _cmd=&quot;\xa7\xb4\xba\U00000012\xa1%&quot;, arg1=0x000000010f1a96fa, arg2=false, arg3=false)  at BaseMsgContentViewController.xm:491</span></span><br><span class="line">   488 	- (void)onLoadMoreMessage &#123; %<span class="built_in">log</span>; %orig; &#125;</span><br><span class="line">   489 	- (void)initHistroyMessageNodeData &#123; %<span class="built_in">log</span>; %orig; &#125;</span><br><span class="line">   490 	- (void)replaceMessageNode:(<span class="built_in">id</span>)arg1 withMessageNodeList:(<span class="built_in">id</span>)arg2 &#123; %<span class="built_in">log</span>; %orig; &#125;</span><br><span class="line">-&gt; 491 	- (void)addMessageNode:(<span class="built_in">id</span>)arg1 layout:(_Bool)arg2 addMoreMsg:(_Bool)arg3 &#123; %<span class="built_in">log</span>; %orig; &#125;</span><br><span class="line">   492 	- (void)addChatViewModel:(<span class="built_in">id</span>)arg1 addMoreMsg:(_Bool)arg2 &#123; %<span class="built_in">log</span>; %orig; &#125;</span><br><span class="line">   493 	- (void)tryAddTipsNodeForInviteHistory:(<span class="built_in">id</span>)arg1 addMoreMsg:(_Bool)arg2 &#123; %<span class="built_in">log</span>; %orig; &#125;</span><br><span class="line">   494 	- (unsigned int)getNeedAddTimeWithMsgWrap:(<span class="built_in">id</span>)arg1 time:(unsigned int)arg2 &#123; %<span class="built_in">log</span>; unsigned int r = %orig; NSLog(@<span class="string">&quot; = %u&quot;</span>, r); <span class="built_in">return</span> r; &#125;</span><br><span class="line">Target 0: (WeChat) stopped.</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure>

<p>奇怪的是，断点怎么跑到了 redEnveloper.dylib 的 _logos_method… 中去了，其实这就是 Theos 的原理，它将我们写的代码制作成一个 dylib 文件，然后在启动目标进程的时候，注入到目标进程中去，所以我们在 tweak 中写的代码才会被执行。而断点断在这里的原因是 BaseMsgContentViewController.xm 中对 BaseMsgContentViewController 的所有方法进行了 hook 。</p>
<p>断点命中后，接下来使用 bt 命令查看调用堆栈信息：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(lldb) bt</span><br><span class="line">* thread <span class="comment">#1, queue = &#x27;com.apple.main-thread&#x27;, stop reason = breakpoint 1.1</span></span><br><span class="line">  * frame <span class="comment">#0: 0x000000011838347c redEnveloper.dylib` _logos_method$_ungrouped$BaseMsgContentViewController$addMessageNode$layout$addMoreMsg$(self=0x0000000128322860, _cmd=&quot;\xa7\xb4\xba\U00000012\xa1%&quot;, arg1=0x000000010f1a96fa, arg2=false, arg3=false)  at BaseMsgContentViewController.xm:491</span></span><br><span class="line">    frame <span class="comment">#1: 0x0000000100f83ac8 WeChat` ___lldb_unnamed_symbol12406  + 800</span></span><br><span class="line">    frame <span class="comment">#2: 0x000000010374b558 WeChat` ___lldb_unnamed_symbol184229  + 64</span></span><br><span class="line">    frame <span class="comment">#3: 0x0000000100f62ee4 WeChat` ___lldb_unnamed_symbol12051  + 624</span></span><br><span class="line">    frame <span class="comment">#4: 0x000000010df9bb70 WeChat` ___lldb_unnamed_symbol875987  + 244</span></span><br><span class="line">    frame <span class="comment">#5: 0x000000010df31348 WeChat` ___lldb_unnamed_symbol874420  + 168</span></span><br><span class="line">    frame <span class="comment">#6: 0x00000001030a7ea8 WeChat` ___lldb_unnamed_symbol157924  + 648</span></span><br><span class="line">    frame <span class="comment">#7: 0x000000010df52fd4 WeChat` ___lldb_unnamed_symbol874880  + 180</span></span><br><span class="line">    frame <span class="comment">#8: 0x000000018c47a690 Foundation` __NSThreadPerformPerform  + 336</span></span><br><span class="line">    frame <span class="comment">#9: 0x000000018b984f1c CoreFoundation` __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__  + 24</span></span><br><span class="line">    frame <span class="comment">#10: 0x000000018b984e9c CoreFoundation` __CFRunLoopDoSource0  + 88</span></span><br><span class="line">    frame <span class="comment">#11: 0x000000018b984784 CoreFoundation` __CFRunLoopDoSources0  + 176</span></span><br><span class="line">    frame <span class="comment">#12: 0x000000018b97f6c0 CoreFoundation` __CFRunLoopRun  + 1004</span></span><br><span class="line">    frame <span class="comment">#13: 0x000000018b97efb4 CoreFoundation` CFRunLoopRunSpecific  + 436</span></span><br><span class="line">    frame <span class="comment">#14: 0x000000018db8179c GraphicsServices` GSEventRunModal  + 104</span></span><br><span class="line">    frame <span class="comment">#15: 0x00000001b8211c38 UIKitCore` UIApplicationMain  + 212</span></span><br><span class="line">    frame <span class="comment">#16: 0x0000000106bc8968 WeChat` ___lldb_unnamed_symbol399385  + 956</span></span><br><span class="line">    frame <span class="comment">#17: 0x000000018b4428e0 libdyld.dylib` start  + 4</span></span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure>

<p>堆栈中出现了很多 ___lldb_unnamed_symbol 未命名的符号，导致我们无法知道具体的调用关系。有几种方式都可以让我们得到想要的信息。</p>
<ul>
<li><p>第一种：使用调用栈帧中的地址减去当前可执行文件在内存中的地址，就得到了这段代码在 MachO 文件中的位置，然后通过反汇编工具，Hopper，ida，ghidra 等就可以找到这段代码所属的方法是什么了。</p>
</li>
<li><p>第二种：使用 sbt，如果一次 sbt 的结果没有成功，那么多试几次，总会有些成功的。sbt 是这个 LLDB <a href="https://github.com/DerekSelander/LLDB">插件</a>中添加的，按照提示安装之后就有了。</p>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(lldb) sbt</span><br><span class="line">frame <span class="comment">#0 : 0x11838347c redEnveloper.dylib`_logos_method$_ungrouped$BaseMsgContentViewController$addMessageNode$layout$addMoreMsg$(BaseMsgContentViewController*, objc_selector*, objc_object*, bool, bool)</span></span><br><span class="line">frame <span class="comment">#1 : 0x100f83ac8 WeChat`-[BaseMsgContentLogicController DidAddMsg:] + 800</span></span><br><span class="line">frame <span class="comment">#2 : 0x10374b558 WeChat`-[RoomContentLogicController DidAddMsg:] + 64</span></span><br><span class="line">frame <span class="comment">#3 : 0x100f62ee4 WeChat`-[BaseMsgContentLogicController OnAddMsg:MsgWrap:] + 624</span></span><br><span class="line">frame <span class="comment">#4 : 0x10df9bb70 WeChat`-[MMExtensionCenter callExtension:selector:block:] + 244</span></span><br><span class="line">frame <span class="comment">#5 : 0x10df31348 WeChat`-[MMContext callExtension:selector:block:] + 168</span></span><br><span class="line">frame <span class="comment">#6 : 0x1030a7ea8 WeChat`-[CMessageMgr MainThreadNotifyToExt:] + 648</span></span><br><span class="line">frame <span class="comment">#7 : 0x10df52fd4 WeChat`___lldb_unnamed_symbol874880 ... unresolved womp womp + 180</span></span><br><span class="line">frame <span class="comment">#8 : 0x18c47a690 Foundation`__NSThreadPerformPerform + 336</span></span><br><span class="line">frame <span class="comment">#9 : 0x18b984f1c CoreFoundation`__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 24</span></span><br><span class="line">frame <span class="comment">#10: 0x18b984e9c CoreFoundation`__CFRunLoopDoSource0 + 88</span></span><br><span class="line">frame <span class="comment">#11: 0x18b984784 CoreFoundation`__CFRunLoopDoSources0 + 176</span></span><br><span class="line">frame <span class="comment">#12: 0x18b97f6c0 CoreFoundation`__CFRunLoopRun + 1004</span></span><br><span class="line">frame <span class="comment">#13: 0x18b97efb4 CoreFoundation`CFRunLoopRunSpecific + 436</span></span><br><span class="line">frame <span class="comment">#14: 0x18db8179c GraphicsServices`GSEventRunModal + 104</span></span><br><span class="line">frame <span class="comment">#15: 0x1b8211c38 UIKitCore`UIApplicationMain + 212</span></span><br><span class="line">frame <span class="comment">#16: 0x106bc8968 WeChat`___lldb_unnamed_symbol399385 ... unresolved womp womp + 956</span></span><br><span class="line">frame <span class="comment">#17: 0x18b4428e0 libdyld.dylib`start + 4</span></span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure>

<p>从调用堆栈中，看到了一个 <code>CMessageMgr</code> 类。从名称来看它叫消息管理者，一定可以从中得到更多信息。继续使用 logify.pl 将 <code>CMessageMgr</code> 类的全部方法进行 hook 并查看打印。会发现消息发送过来的时候，很多方法会执行，但是以下这个方法是比较合适的，因为能拿到消息参数。</p>
<p><img src="Xnip2024-10-13_15-21-40.jpg"></p>
<p>最终找到 -[CMessageMgr onNewSyncAddMessage:] 方法。当然不是一定要这个方法，其他任何合适的方法都可以进行抢红包的。定位到收到微信消息的方法之后，自然就是分析如何开红包了，其实从正向开发的经验可以猜测，一定是点击红包的按钮之后，发生网络请求打开红包了。</p>
<h2 id="2-定位打开红包的方法"><a href="#2-定位打开红包的方法" class="headerlink" title="2.定位打开红包的方法"></a>2.定位打开红包的方法</h2><p>这个相对来说简单一点，从 UI 入手。越狱设备点开一个红包，使用 Reveal 查看开按钮，复制按钮的内存地址，如下图:</p>
<p><img src="Xnip2024-10-10_10-30-57.png"><br><img src="Xnip2024-10-13_15-34-23.jpg"></p>
<p>我发现新版本的 Reveal 还没有老版本的好用呢，明明老版本的 Reveal 可以显示到具体的拆红包按钮，新版本却只能显示一个整体。</p>
<p>然后使用 lldb+debugserver 进行远程调试：</p>
<p>先远程登录越狱设备，使用 debugserver 附加到微信进程：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> ~/ ssh root@localhost -p 2222</span><br><span class="line">iPhone5s:~ root# debugserver-10 localhost:3333 --attach=WeChat</span><br><span class="line">debugserver-@(#)PROGRAM:LLDB  PROJECT:lldb-10.0.0</span><br><span class="line"> <span class="keyword">for</span> arm64.</span><br><span class="line">Attaching to process WeChat...</span><br><span class="line">Listening to port 3333 <span class="keyword">for</span> a connection from localhost...</span><br><span class="line">Waiting <span class="keyword">for</span> debugger instructions <span class="keyword">for</span> process 0.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示：这里进行了两个端口转发，一个 2222:22，另一个是 3333:3333，所以才能正常运行。<code>iproxy 2222:22 3333:3333</code></p>
</blockquote>
<p>然后进入 lldb 并调试这个按钮的 target 和 action ：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> ~/ lldb</span><br><span class="line">(lldb) process connect connect://localhost:3333</span><br><span class="line">Process 12437 stopped</span><br><span class="line">* thread <span class="comment">#1, queue = &#x27;com.apple.main-thread&#x27;, stop reason = signal SIGSTOP</span></span><br><span class="line">    frame <span class="comment">#0: 0x000000018b5840f4 libsystem_kernel.dylib` mach_msg_trap  + 8</span></span><br><span class="line">libsystem_kernel.dylib`mach_msg_trap:</span><br><span class="line">-&gt;  0x18b5840f4 &lt;+8&gt;: ret</span><br><span class="line">libsystem_kernel.dylib<span class="string">&#x27;mach_msg_overwrite_trap:    0x18b5840f8 &lt;+0&gt;: mov    x16, #-0x20</span></span><br><span class="line"><span class="string">    0x18b5840fc &lt;+4&gt;: svc    #0x80</span></span><br><span class="line"><span class="string">    0x18b584100 &lt;+8&gt;: ret</span></span><br><span class="line"><span class="string">libsystem_kernel.dylib&#x27;</span>semaphore_signal_trap:    0x18b584104 &lt;+0&gt;: mov    x16, <span class="comment">#-0x21</span></span><br><span class="line">    0x18b584108 &lt;+4&gt;: svc    <span class="comment">#0x80</span></span><br><span class="line">    0x18b58410c &lt;+8&gt;: ret</span><br><span class="line">libsystem_kernel.dylib<span class="string">&#x27;semaphore_signal_all_trap:    0x18b584110 &lt;+0&gt;: mov    x16, #-0x22</span></span><br><span class="line"><span class="string">Target 0: (WeChat) stopped.</span></span><br><span class="line"><span class="string">(lldb) po [0x1476a1000 allTargets]</span></span><br><span class="line"><span class="string">&#123;(</span></span><br><span class="line"><span class="string">    &lt;WCRedEnvelopesReceiveHomeView: 0x147693670; frame = (0 0; 320 568); clipsToBounds = YES; autoresize = W+H; layer = &lt;CALayer: 0x2829f1480&gt;&gt;</span></span><br><span class="line"><span class="string">)&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">(lldb) po [0x1476a1000 actionsForTarget:0x147693670 forControlEvent:64]</span></span><br><span class="line"><span class="string">&lt;__NSArrayM 0x286397990&gt;(</span></span><br><span class="line"><span class="string">OnOpenRedEnvelopes</span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">(lldb)</span></span><br></pre></td></tr></table></figure>

<p>找到了 <code>-[WCRedEnvelopesReceiveHomeView OnOpenRedEnvelopes]</code> 方法。找到这个方法就能成功实现抢红包功能了吗？当然没有那么简单。我们在收到微信消息的时候，很可能连聊天页面都没有进入，更不可能存在 <code>WCRedEnvelopesReceiveHomeView</code> 对象了，所以无法调用这个方法。有人会想，我自己创建一个 <code>WCRedEnvelopesReceiveHomeView</code> 对象调用 <code>OnOpenRedEnvelopes</code> 方法能不能行呢。前提是你得知道 <code>WCRedEnvelopesReceiveHomeView</code> 正确的初始化方法啊。微信开发人员在创建 <code>WCRedEnvelopesReceiveHomeView</code> 对象的时候肯定给了其他的参数，你不能认为调用一个 <code>initWithFrame:</code> 方法创建一个 <code>WCRedEnvelopesReceiveHomeView</code> 对象之后就万事大吉了。所以还得继续分析开红包的具体代码。这就需要静态分析反汇编代码了，从汇编代码尝试还原出源码。关于 iOS 的 arm64 汇编的文章，也在准备当中。。。敬请期待</p>
<h2 id="3-静态分析开红包的方法"><a href="#3-静态分析开红包的方法" class="headerlink" title="3.静态分析开红包的方法"></a>3.静态分析开红包的方法</h2><p>定位到开红包的方法之后，需要反编译分析这个方法，看看是如何打开红包的，这就需要用到常见的反编译工具如：IDA Pro，Ghidra，Hopper Disassembler 等。这里以 Hopper 为例:</p>
<p><img src="Xnip2024-10-10_13-16-08.png"></p>
<p><code>OnOpenRedEnvelopes</code> 方法的倒数第三个 bl 跳转指令，后面指向的是 objc_msgSend 函数，如果知道了它的参数是什么，也就知道了方法最后的走向是什么。所以我们给它下一个断点，但是这个地址 0x10556c8ac 只是在 MachO 文件中的地址，实际内存中的地址，还需要加上 MachO 文件在内存中的首地址，可以使用 <code>image list -o -f WeChat</code> 来获取。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(lldb) image list -o -f WeChat</span><br><span class="line">[  0] 0x000000000093c000 /var/containers/Bundle/Application/E51AA5D1-C65C-4E5B-A4AB-34C88E760D49/WeChat.app/WeChat(0x000000010093c000)</span><br></pre></td></tr></table></figure>

<p>接下来将两者相加，就可以用来下内存断点了</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(lldb) p/x 0x10556c8ac+0x000000000093c000</span><br><span class="line">(long) 0x0000000105ea88ac</span><br><span class="line">(lldb) breakpoint <span class="built_in">set</span> --address 0x0000000105ea88ac</span><br><span class="line">Breakpoint 1: <span class="built_in">where</span> = WeChat`___lldb_unnamed_symbol363752 + 304, address = 0x0000000105ea88ac</span><br><span class="line">(lldb) c</span><br><span class="line">Process 12437 resuming</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure>

<p>断点下好之后，c 让程序继续执行，然后我们点击开红包按钮，此时断点命中，我们读取寄存器的内容：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Process 12437 stopped</span><br><span class="line">* thread <span class="comment">#1, queue = &#x27;com.apple.main-thread&#x27;, stop reason = breakpoint 1.1</span></span><br><span class="line">    frame <span class="comment">#0: 0x0000000105ea88ac WeChat` ___lldb_unnamed_symbol363752  + 304</span></span><br><span class="line">WeChat`___lldb_unnamed_symbol363752:</span><br><span class="line">-&gt;  0x105ea88ac &lt;+304&gt;: bl     0x10853ffe4               ; ___lldb_unnamed_symbol518292</span><br><span class="line">    0x105ea88b0 &lt;+308&gt;: mov    x0, x19</span><br><span class="line">    0x105ea88b4 &lt;+312&gt;: bl     0x10853ffcc               ; ___lldb_unnamed_symbol518286</span><br><span class="line">    0x105ea88b8 &lt;+316&gt;: mov    x0, x20</span><br><span class="line">    0x105ea88bc &lt;+320&gt;: ldp    x29, x30, [sp, <span class="comment">#0x60]</span></span><br><span class="line">    0x105ea88c0 &lt;+324&gt;: ldp    x20, x19, [sp, <span class="comment">#0x50]</span></span><br><span class="line">    0x105ea88c4 &lt;+328&gt;: ldp    x22, x21, [sp, <span class="comment">#0x40]</span></span><br><span class="line">    0x105ea88c8 &lt;+332&gt;: ldp    x24, x23, [sp, <span class="comment">#0x30]</span></span><br><span class="line">Target 0: (WeChat) stopped.</span><br><span class="line">(lldb) register <span class="built_in">read</span> x0</span><br><span class="line">      x0 = 0x0000000281d49a40</span><br><span class="line">(lldb) po 0x0000000281d49a40</span><br><span class="line">&lt;WCRedEnvelopesReceiveControlLogic: 0x281d49a40&gt;</span><br><span class="line"></span><br><span class="line">(lldb) register <span class="built_in">read</span> x1</span><br><span class="line">      x1 = 0x000000010f1c6cc5  <span class="string">&quot;WCRedEnvelopesReceiveHomeViewOpenRedEnvelopes&quot;</span></span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure>

<p>通过对寄存器的读取，我们得知此时，调用了 <code>-[WCRedEnvelopesReceiveControlLogic WCRedEnvelopesReceiveHomeViewOpenRedEnvelopes]</code> 方法。终于来到了真正开红包的地方了！以及红包相关的逻辑处理的类 <code>WCRedEnvelopesReceiveControlLogic</code>。</p>
<p>继续查看反汇编之后的代码，可以看出这个方法中，拼接了一个字典参数，然后通过调用 <code>OpenRedEnvelopesRequest:</code> 方法发送了请求。</p>
<p>使用 logify.pl 将 <code>WCRedEnvelopesReceiveControlLogic</code> 的所有方法进行 hook，这下我们可以清晰的看到开红包的过程了。在聊天界面点击红包的时候，首先会调用查红包的接口 <code>ReceiverQueryRedEnvelopesRequest:</code> 它返回了一个重要的参数 <code>timingIdentifier</code>，之后显示了开红包的界面，点击开按钮才是开红包的请求 <code>OpenRedEnvelopesRequest:</code>，用到了这个参数。</p>
<h2 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h2><p>此时，我们的需要做的就是将逻辑完善。在收到微信消息的时候，判断是红包消息就发送一个查红包的请求，在它的响应回来的时候，判断是否开了自动抢红包，开了就调用开红包的请求。这就是自动抢红包的完整逻辑了。还有判断是否是红包消息，是否是未拆开的红包等判断逻辑也不用我们自己去猜，微信肯定有它自己的判断，我们只需要找到对应的代码拿过来用就行了，但这都是些小细节了就不再深入了。</p>
<p>最终的完整代码下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WCTableViewManager</span></span></span><br><span class="line">- (<span class="type">long</span> <span class="type">long</span>)numberOfSectionsInTableView:(<span class="type">id</span>)arg1;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSMutableDictionary</span> (<span class="title">safeSetObject</span>)</span></span><br><span class="line">- (<span class="type">void</span>)safeSetObject:(<span class="type">id</span>)arg1 forKey:(<span class="type">id</span>)arg2;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WCBizUtil</span></span></span><br><span class="line">+ (<span class="type">id</span>)dictionaryWithDecodedComponets:(<span class="type">id</span>)arg1 separator:(<span class="type">id</span>)arg2;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SKBuiltinBuffer_t</span></span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">retain</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSData</span> *buffer; <span class="comment">// @dynamic buffer;</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="type">unsigned</span> <span class="type">int</span> iLen; <span class="comment">// @dynamic iLen;</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">BaseRequest</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">HongBaoReq</span></span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">retain</span>, <span class="keyword">nonatomic</span>) BaseRequest *baseRequest; <span class="comment">// @dynamic baseRequest;</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="type">unsigned</span> <span class="type">int</span> cgiCmd; <span class="comment">// @dynamic cgiCmd;</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="type">unsigned</span> <span class="type">int</span> outPutType; <span class="comment">// @dynamic outPutType;</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">retain</span>, <span class="keyword">nonatomic</span>) <span class="built_in">SKBuiltinBuffer_t</span> *reqText; <span class="comment">// @dynamic reqText;</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">HongBaoRes</span></span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="type">int</span> cgiCmdid; <span class="comment">// @dynamic cgiCmdid;</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">retain</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *errorMsg; <span class="comment">// @dynamic errorMsg;</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="type">int</span> errorType; <span class="comment">// @dynamic errorType;</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">retain</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *platMsg; <span class="comment">// @dynamic platMsg;</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="type">int</span> platRet; <span class="comment">// @dynamic platRet;</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">retain</span>, <span class="keyword">nonatomic</span>) <span class="built_in">SKBuiltinBuffer_t</span> *retText; <span class="comment">// @dynamic retText;</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CContact</span></span></span><br><span class="line">- (<span class="type">id</span>)getContactDisplayName;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">retain</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *m_nsHeadImgUrl;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CContactMgr</span></span></span><br><span class="line">- (<span class="type">id</span>)getSelfContact;</span><br><span class="line">- (<span class="type">id</span>)getContactByNameFromCache:(<span class="type">id</span>)cache;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WCRedEnvelopesLogicMgr</span></span></span><br><span class="line">- (<span class="type">void</span>)ReceiverQueryRedEnvelopesRequest:(<span class="type">id</span>)arg1;</span><br><span class="line">- (<span class="type">void</span>)OpenRedEnvelopesRequest:(<span class="type">id</span>)arg1;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MMContext</span></span></span><br><span class="line">+ (<span class="type">id</span>)currentContext;</span><br><span class="line">- (<span class="type">id</span>)getService:(Class)arg1;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MMMsgLogicManager</span></span></span><br><span class="line">- (<span class="built_in">UIViewController</span> *)GetCurrentLogicController;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WCPayInfoItem</span></span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">retain</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *m_c2cNativeUrl;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CMessageWrap</span></span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">retain</span>, <span class="keyword">nonatomic</span>) WCPayInfoItem *m_oWCPayInfoItem;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">retain</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *m_nsRealChatUsr;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">retain</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *m_nsFromUsr;</span><br><span class="line">- (<span class="type">void</span>)parseWCPayInfoItemIfNeed;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WCPayC2CMessageViewModel</span></span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">retain</span>, <span class="keyword">nonatomic</span>) <span class="built_in">CMessageWrap</span> *messageWrap;</span><br><span class="line">+ (<span class="type">BOOL</span>)canCreateMessageViewModelWithMessageWrap:(<span class="type">id</span>)wrap;</span><br><span class="line">+ (<span class="type">id</span>)createMessageViewModelWithMessageWrap:(<span class="type">id</span>)arg1 contact:(<span class="type">id</span>)arg2 chatContact:(<span class="type">id</span>)arg3;</span><br><span class="line">- (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)bubbleType;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 界面代码</span></span><br><span class="line">%hook WCTableViewManager</span><br><span class="line">- (<span class="type">double</span>)tableView:(<span class="built_in">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class="type">id</span>)indexPath&#123;</span><br><span class="line">    <span class="keyword">if</span>([tableView.nextResponder.nextResponder isKindOfClass:%c(NewSettingViewController)]</span><br><span class="line">       &amp;&amp;([indexPath section] == [<span class="keyword">self</span> numberOfSectionsInTableView:tableView] - <span class="number">1</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">44</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> %orig;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">id</span>)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="type">id</span>)indexPath&#123;</span><br><span class="line">    <span class="keyword">if</span>([tableView.nextResponder.nextResponder isKindOfClass:%c(NewSettingViewController)]</span><br><span class="line">       &amp;&amp;([indexPath section] == [<span class="keyword">self</span> numberOfSectionsInTableView:tableView] - <span class="number">1</span>))&#123;</span><br><span class="line">        <span class="built_in">UITableViewCell</span> * cell = [[<span class="built_in">UITableViewCell</span> alloc] initWithStyle:(<span class="built_in">UITableViewCellStyleDefault</span>) reuseIdentifier:<span class="literal">nil</span>];</span><br><span class="line">        cell.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">        <span class="keyword">if</span>([indexPath row] == <span class="number">0</span>)&#123;</span><br><span class="line">            cell.textLabel.text = <span class="string">@&quot;自动抢红包&quot;</span>;</span><br><span class="line">            <span class="built_in">UISwitch</span> * switchView = [[<span class="built_in">UISwitch</span> alloc] init];</span><br><span class="line">            switchView.on = [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] boolForKey:<span class="string">@&quot;RESWITCHKEY&quot;</span>];</span><br><span class="line">            [switchView addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(switchChang:) forControlEvents:(<span class="built_in">UIControlEventValueChanged</span>)];</span><br><span class="line">            cell.accessoryView = switchView;</span><br><span class="line">            <span class="built_in">NSBundle</span> *bundle = [<span class="built_in">NSBundle</span> bundleWithPath:<span class="string">@&quot;/Library/MobileSubstrate/DynamicLibraries/redEnveloper.bundle/&quot;</span>];</span><br><span class="line">            <span class="built_in">NSString</span> *imageName = ([[<span class="built_in">NSUserDefaults</span> standardUserDefaults] boolForKey:<span class="string">@&quot;RESWITCHKEY&quot;</span>] == <span class="number">1</span>) ? <span class="string">@&quot;locked.png&quot;</span> : <span class="string">@&quot;unlocked.png&quot;</span>;</span><br><span class="line">            <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:imageName inBundle:bundle compatibleWithTraitCollection:<span class="literal">nil</span>];</span><br><span class="line">            cell.imageView.image = image;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cell;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> %orig;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">long</span> <span class="type">long</span>)tableView:(<span class="built_in">UITableView</span> *)tableView numberOfRowsInSection:(<span class="type">long</span> <span class="type">long</span>)section&#123;</span><br><span class="line">    <span class="keyword">if</span>([tableView.nextResponder.nextResponder isKindOfClass:%c(NewSettingViewController)]</span><br><span class="line">       &amp;&amp;(section == [<span class="keyword">self</span> numberOfSectionsInTableView:tableView] - <span class="number">1</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> %orig;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">long</span> <span class="type">long</span>)numberOfSectionsInTableView:(<span class="built_in">UITableView</span> *)tableView&#123;</span><br><span class="line">    <span class="keyword">if</span>([tableView.nextResponder.nextResponder isKindOfClass:%c(NewSettingViewController)])&#123;</span><br><span class="line">        <span class="keyword">return</span> %orig+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> %orig;</span><br><span class="line">&#125;</span><br><span class="line">%new</span><br><span class="line">-(<span class="type">void</span>)switchChang:(<span class="built_in">UISwitch</span> *)switchView&#123;</span><br><span class="line">    [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] setBool:switchView.isOn forKey:<span class="string">@&quot;RESWITCHKEY&quot;</span>];</span><br><span class="line">    [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] synchronize];</span><br><span class="line">    [MSHookIvar&lt;<span class="built_in">UITableView</span> *&gt;(<span class="keyword">self</span>,<span class="string">&quot;_tableView&quot;</span>) reloadData];</span><br><span class="line">&#125;</span><br><span class="line">%end</span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能实现代码</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AutoGrabRedEnvelopeMgr</span> : <span class="title">NSObject</span></span>&#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *_array;<span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)shared;</span><br><span class="line">- (<span class="type">BOOL</span>)isEmpty;</span><br><span class="line">- (<span class="type">void</span>)enqueueDictionary:(<span class="built_in">NSDictionary</span> *)parameter;</span><br><span class="line">- (<span class="built_in">NSDictionary</span> *)dequeueDictionary;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AutoGrabRedEnvelopeMgr</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)shared&#123;</span><br><span class="line">    <span class="keyword">static</span> AutoGrabRedEnvelopeMgr *mgr = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        mgr = [[[<span class="keyword">self</span> <span class="keyword">class</span>] alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> mgr;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">instancetype</span>)init&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="variable language_">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _array = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">BOOL</span>)isEmpty &#123;</span><br><span class="line">    <span class="keyword">return</span> _array.count == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)enqueueDictionary:(<span class="built_in">NSDictionary</span> *)parameter &#123;</span><br><span class="line">    [_array addObject:parameter];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">NSDictionary</span> *)dequeueDictionary &#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> isEmpty]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSDictionary</span> *dict = [_array firstObject];</span><br><span class="line">        [_array removeObjectAtIndex:<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> dict;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初步分析每次收到消息的时候,都会调用到这个方法,那么就可以在这个方法里面进行抢红包;</span></span><br><span class="line">%hook <span class="built_in">CMessageMgr</span></span><br><span class="line">- (<span class="type">void</span>)onNewSyncAddMessage:(<span class="type">id</span>)arg1 &#123; <span class="comment">//CMessageWrap</span></span><br><span class="line">    <span class="comment">// 需要判断一下是否是红包消息,不然每次一有消息过来就去拆红包开红包不合理</span></span><br><span class="line">    <span class="keyword">if</span> ([%c(WCPayC2CMessageViewModel) canCreateMessageViewModelWithMessageWrap:arg1]) &#123; <span class="comment">// 这里确定是红包消息</span></span><br><span class="line">        WCPayC2CMessageViewModel *model = [%c(WCPayC2CMessageViewModel) createMessageViewModelWithMessageWrap:arg1 contact:<span class="literal">nil</span> chatContact:<span class="literal">nil</span>];</span><br><span class="line">        [model.messageWrap parseWCPayInfoItemIfNeed];</span><br><span class="line">        <span class="keyword">if</span> (model.bubbleType == <span class="number">4</span>) &#123; <span class="comment">// 未打开的红包</span></span><br><span class="line">            <span class="keyword">if</span> ([[<span class="built_in">NSUserDefaults</span> standardUserDefaults] boolForKey:<span class="string">@&quot;RESWITCHKEY&quot;</span>]) &#123; <span class="comment">// 打开了自动抢红包</span></span><br><span class="line">                <span class="built_in">NSString</span> *m_c2cNativeUrl = model.messageWrap.m_oWCPayInfoItem.m_c2cNativeUrl;</span><br><span class="line">                <span class="built_in">NSUInteger</span> len = [<span class="string">@&quot;wxpay://c2cbizmessagehandler/hongbao/receivehongbao?&quot;</span> length];</span><br><span class="line">                <span class="built_in">NSString</span> * substring = [m_c2cNativeUrl substringFromIndex:len];</span><br><span class="line">                <span class="built_in">NSDictionary</span> * dict = [%c(WCBizUtil) dictionaryWithDecodedComponets:substring separator:<span class="string">@&quot;&amp;&quot;</span>];</span><br><span class="line">                <span class="built_in">NSMutableDictionary</span> * parameter = [%c(<span class="built_in">NSMutableDictionary</span>) dictionary];</span><br><span class="line">                [parameter safeSetObject:<span class="string">@&quot;1&quot;</span> forKey:<span class="string">@&quot;msgType&quot;</span>];</span><br><span class="line">                [parameter safeSetObject:[dict objectForKey:<span class="string">@&quot;sendid&quot;</span>] forKey:<span class="string">@&quot;sendId&quot;</span>];</span><br><span class="line">                [parameter safeSetObject:[dict objectForKey:<span class="string">@&quot;channelid&quot;</span>] forKey:<span class="string">@&quot;channelId&quot;</span>];</span><br><span class="line">                [parameter safeSetObject:m_c2cNativeUrl forKey:<span class="string">@&quot;nativeUrl&quot;</span>];</span><br><span class="line">                MMMsgLogicManager *msgLogicMgr = [[%c(MMContext) currentContext] getService:[%c(MMMsgLogicManager) <span class="keyword">class</span>]];</span><br><span class="line">                <span class="built_in">UIViewController</span> * vc = [msgLogicMgr GetCurrentLogicController];</span><br><span class="line">                <span class="built_in">NSString</span> *inWay;</span><br><span class="line">                <span class="keyword">if</span> (vc == <span class="literal">nil</span> || [vc valueForKey:<span class="string">@&quot;m_contact&quot;</span>] == <span class="literal">nil</span> || ![[vc valueForKey:<span class="string">@&quot;m_contact.isChatroom&quot;</span>] boolValue]) &#123;</span><br><span class="line">                    inWay = <span class="string">@&quot;1&quot;</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    inWay = <span class="string">@&quot;0&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                [parameter safeSetObject:inWay forKey:<span class="string">@&quot;inWay&quot;</span>];</span><br><span class="line">                [parameter safeSetObject:<span class="string">@&quot;0&quot;</span> forKey:<span class="string">@&quot;agreeDuty&quot;</span>];</span><br><span class="line">                WCRedEnvelopesLogicMgr *mgr = [[%c(MMContext) currentContext] getService:[%c(WCRedEnvelopesLogicMgr) <span class="keyword">class</span>]];</span><br><span class="line">                [mgr ReceiverQueryRedEnvelopesRequest:[parameter <span class="keyword">copy</span>]];</span><br><span class="line">                [parameter safeSetObject:model.messageWrap.m_nsFromUsr forKey:<span class="string">@&quot;sessionUserName&quot;</span>];</span><br><span class="line">                [AutoGrabRedEnvelopeMgr.shared enqueueDictionary:parameter];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    %orig;</span><br><span class="line">&#125;</span><br><span class="line">%end</span><br><span class="line"></span><br><span class="line">%hook WCRedEnvelopesLogicMgr</span><br><span class="line">- (<span class="type">void</span>)OnWCToHongbaoCommonResponse:(HongBaoRes *)arg1 Request:(HongBaoReq *)arg2&#123;</span><br><span class="line">    %orig;</span><br><span class="line">    <span class="built_in">NSError</span> *error;</span><br><span class="line">    <span class="built_in">NSDictionary</span> *response = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:arg1.retText.buffer options:<span class="built_in">NSJSONReadingMutableContainers</span> error:&amp;error];</span><br><span class="line">    <span class="keyword">if</span> (arg1.cgiCmdid == <span class="number">3</span>) &#123; <span class="comment">// 表示拆红包,开红包的前一个步骤</span></span><br><span class="line">        <span class="keyword">if</span> (![AutoGrabRedEnvelopeMgr.shared isEmpty] &amp;&amp; [response[<span class="string">@&quot;timingIdentifier&quot;</span>] length] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">NSMutableDictionary</span> *dic = [AutoGrabRedEnvelopeMgr.shared dequeueDictionary].mutableCopy;</span><br><span class="line">            dic[<span class="string">@&quot;timingIdentifier&quot;</span>] = response[<span class="string">@&quot;timingIdentifier&quot;</span>];</span><br><span class="line">            MMContext *context = [%c(MMContext) currentContext];</span><br><span class="line">            CContactMgr *contactMgr = [context getService:[%c(CContactMgr) <span class="keyword">class</span>]];</span><br><span class="line">            CContact *contact = [contactMgr getSelfContact];</span><br><span class="line">            <span class="built_in">NSString</span> *displayName = [contact getContactDisplayName];</span><br><span class="line">            [dic setObject:displayName forKey:<span class="string">@&quot;nickName&quot;</span>];</span><br><span class="line">            <span class="built_in">NSString</span> *headImgUrl = [contact m_nsHeadImgUrl];</span><br><span class="line">            [dic setObject:headImgUrl forKey:<span class="string">@&quot;headImg&quot;</span>];</span><br><span class="line">            <span class="keyword">if</span> ([dic objectForKey:<span class="string">@&quot;agreeDuty&quot;</span>]) [dic removeObjectForKey:<span class="string">@&quot;agreeDuty&quot;</span>];</span><br><span class="line">            <span class="keyword">if</span> ([dic objectForKey:<span class="string">@&quot;inWay&quot;</span>]) [dic removeObjectForKey:<span class="string">@&quot;inWay&quot;</span>];</span><br><span class="line">            dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">0.5</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                [<span class="keyword">self</span> OpenRedEnvelopesRequest:dic]; </span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">%end</span><br></pre></td></tr></table></figure>

<p>代码完成之后，我们进入终端，cd 到项目的文件夹下，编译打包安装之后，再次进入微信，找到自动抢红包的开关，打开之后，给这个微信账号发送一个红包试试有没有成功！</p>
<p>可以看到实现自动抢红包的 UI 和功能的代码并不是很多，仅仅 200 多行，但是这 200 多行的代码要能自己写出来也是真的挺不容易的。</p>
]]></content>
      <categories>
        <category>iOS 逆向与安全</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>逆向</tag>
        <tag>微信</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title>解决git clone速度慢的问题</title>
    <url>/2018/10/26/%E8%A7%A3%E5%86%B3git-clone%E9%80%9F%E5%BA%A6%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>之前一直以为是公司对网络的封锁,导致git clone速度慢,后来网上查找这个问题的时候得知不能怪公司,是因为咱们在这个局域网内…<br>扯多了,回到正题,解决问题,由于我的是Mac电脑,我说的只针对Mac电脑</p>
<h5 id="1-进入终端命令行模式-输入"><a href="#1-进入终端命令行模式-输入" class="headerlink" title="1. 进入终端命令行模式,输入"></a>1. 进入终端命令行模式,输入</h5><p><code>sudo vim /etc/hosts</code></p>
<h5 id="2-输入i进入编辑模式-移动到最后一行准备输入"><a href="#2-输入i进入编辑模式-移动到最后一行准备输入" class="headerlink" title="2. 输入i进入编辑模式,移动到最后一行准备输入"></a>2. 输入i进入编辑模式,移动到最后一行准备输入</h5><h5 id="3-用浏览器访问-http-tool-chinaz-com-使用-IP查询-工具获得github-com和github-global-ssl-fastly-net的ip地址"><a href="#3-用浏览器访问-http-tool-chinaz-com-使用-IP查询-工具获得github-com和github-global-ssl-fastly-net的ip地址" class="headerlink" title="3. 用浏览器访问 http://tool.chinaz.com 使用 IP查询 工具获得github.com和github.global.ssl.fastly.net的ip地址"></a>3. 用浏览器访问 <a href="http://tool.chinaz.com/">http://tool.chinaz.com</a> 使用 IP查询 工具获得github.com和github.global.ssl.fastly.net的ip地址</h5><h5 id="4-回到第2步中按如下格式输入"><a href="#4-回到第2步中按如下格式输入" class="headerlink" title="4. 回到第2步中按如下格式输入:"></a>4. 回到第2步中按如下格式输入:</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">192.30.253.112 github.com</span><br><span class="line">151.101.44.249 github.global.ssl.fastly.net</span><br></pre></td></tr></table></figure>
<h5 id="5-按-esc-键-然后输入-wq-保存文件并退出vim编辑模式-到此hosts文件修改结束"><a href="#5-按-esc-键-然后输入-wq-保存文件并退出vim编辑模式-到此hosts文件修改结束" class="headerlink" title="5. 按 esc 键,然后输入 :wq 保存文件并退出vim编辑模式,到此hosts文件修改结束"></a>5. 按 esc 键,然后输入 :wq 保存文件并退出vim编辑模式,到此hosts文件修改结束</h5><h5 id="6-更新DNS缓存-输入"><a href="#6-更新DNS缓存-输入" class="headerlink" title="6. 更新DNS缓存,输入"></a>6. 更新DNS缓存,输入</h5><p><code>sudo dscacheutil -flushcache </code></p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>揭开神秘的iOS布局</title>
    <url>/2018/03/26/%E6%8F%AD%E7%A7%98iOS%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<p>翻译自: <a href="http://tech.gc.com/demystifying-ios-layout/">Demystifying iOS Layout</a></p>
<p>在你刚开始开发iOS应用时,最难避免或者说最难调试的是处理视图的布局和内容;通常这些事情的发生是因为对 <strong>视图更新</strong> 真实发生存在误解;了解 <strong>视图更新</strong> 的方式和时间需要更深入地了解iOS应用程序的主运行循环,以及它如何与<code>UIView</code>提供的某些方法关联;这篇博文将解释这些互动,希望澄清如何使用<code>UIView</code>的方法来获得你想要的行为;</p>
<h2 id="iOS应用程序的主运行循环"><a href="#iOS应用程序的主运行循环" class="headerlink" title="iOS应用程序的主运行循环"></a>iOS应用程序的主运行循环</h2><p>iOS应用程序的主运行循环用来处理所有用户输入事件并在您的应用程序中触发适当的响应;任何与应用程序的用户交互都会被添加到事件队列中;应用程序对象(如下图所示)将事件队列中的事件取出,并将它们分派给应用程序中的其他对象;<strong>它本质上是通过解释来自用户的输入事件并在应用程序的核心对象中为该输入调用相应的处理程序来执行运行循环</strong>;这些处理程序调用应用程序开发人员编写的代码;一旦这些方法调用返回,控制回到主运行循环并且开始更新周期;更新周期负责布局和重绘视图(在下一节中介绍);下面是应用程序如何与设备进行通信并处理用户输入的插图</p>
<p><img src="http://tech.gc.com/images/demystifying-ios-layout/main_event_loop.jpg" alt="Main Event Loop"></p>
<p><em><a href="https://developer.apple.com/library/content/documentation/General/Conceptual/Devpedia-CocoaApp/MainEventLoop.html">https://developer.apple.com/library/content/documentation/General/Conceptual/Devpedia-CocoaApp/MainEventLoop.html</a></em></p>
<h2 id="更新周期-Update-Cycle"><a href="#更新周期-Update-Cycle" class="headerlink" title="更新周期(Update Cycle)"></a>更新周期(Update Cycle)</h2><p>更新周期是应用程序完成运行所有事件处理代码后,控制权返回到主运行循环的点;就是在这个点,系统开始更新布局,显示和约束;如果您要求改变视图而它正在执行事件处理程序,系统会将此视图标记为需要重绘;在下一次更新周期,系统将执行这些视图上所有的变化;用户交互和布局更新之间的时间间隔对用户来说应该是感觉不到的;iOS应用程序通常以60fps动画,这意味着一个刷新周期只需要1&#x2F;60秒;由于这种情况发生的速度很快,用户不会注意到她与设备上的应用程序进行交互和看到内容和布局更新之间的UI的滞后;但是,由于事件被执行的时间和相应视图的重绘时间之间存在时间间隔,所以在运行循环过程中,视图可能不会按照您希望的方式更新;如果您有任何计算依赖视图最新的内容或布局,您有可能操作的是该视图的旧的内容或布局而不是最新的;了解运行循环,更新周期和某些的<code>UIView</code>方法能够帮助避免或者调试这类问题;</p>
<p>您可以在下图中看到更新周期在运行循环结束时如何发生<br><img src="http://tech.gc.com/images/demystifying-ios-layout/tech-blog-loop.png" alt="Update Cycle"></p>
<h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>视图的布局指的是它在屏幕上的大小和位置;每一个视图都有一个<code>frame</code>属性来描述它在父视图坐标系统中的位置以及它的大小;<code>UIView</code>提供了一些方法,可以让你通知系统一个视图的布局已经改变,同时为你提供了可以重写的方法,以便在重新计算视图的布局后定义要执行的操作</p>
<h3 id="layoutSubviews"><a href="#layoutSubviews" class="headerlink" title="layoutSubviews()"></a>layoutSubviews()</h3><p>这个<code>UIView</code>方法调整视图及其所有子视图的大小和位置;它给出当前视图和每个子视图的位置和大小;此方法很昂贵,因为它对视图的所有子视图起作用并调用其相应的<code>layoutSubviews</code>方法;系统会在任何需要重新计算视图的 frame 属性时调用此方法,因此当您想要设置 frame 属性指定视图位置和大小的时候您应该重写此方法;但是,当您的视图层次结构需要布局刷新时,您绝不应该显示的调用它;相反,在运行循环期间,您可以使用多种机制在不同点触发<code>layoutSubviews</code>调用,这比直接调用<code>layoutSubviews</code>方法要便宜的多;</p>
<p>当<code>layoutSubviews</code>方法完成时,将在拥有该视图的视图控制器中触发对<code>viewDidLayoutSubviews</code>的调用;<strong>由于<code>layoutSubviews</code>是更新视图布局后可靠调用的唯一方法,因此应该将任何取决于布局和大小的逻辑代码方法<code>viewDidLayoutSubviews</code>中,而不是放在<code>viewDidLoad</code>或<code>viewDidAppear</code>中</strong>;这是避免使用过时的布局或者位置变量的唯一方法。</p>
<h2 id="自动刷新触发器"><a href="#自动刷新触发器" class="headerlink" title="自动刷新触发器"></a>自动刷新触发器</h2><p>有多个事件会自动地将视图标记为布局已经改变,所以该视图的<code>layoutSubviews</code>方法将在下一次更新周期时被系统调用,不需要开发人员手动执行这个方法;</p>
<p>这些自动将视图标记为布局已经改变的方式有以下几种:</p>
<ul>
<li>改变视图的大小</li>
<li>添加子视图</li>
<li>用户滚动<code>UIScrollView</code>(<code>layoutSubviews</code>方法会被<code>UIScrollView</code>以及它的父视图调用)</li>
<li>用户旋转设备</li>
<li>更新视图的约束</li>
</ul>
<p>以上这些方式都告诉系统,视图的位置需要重新计算并且会自动导致最终的<code>layoutSubviews</code>方法的调用;当然,也有直接触发<code>layoutSubviews</code>方法调用的办法;</p>
<h3 id="setNeedsLayout"><a href="#setNeedsLayout" class="headerlink" title="setNeedsLayout()"></a>setNeedsLayout()</h3><p>触发<code>layoutSubviews</code>调用最省资源的方式就是在您的视图上调用<code>setNeedsLayout</code>方法;这将指示系统这个视图的布局需要重新计算;<code>setNeedsLayout</code>执行并立即返回,并且在返回之前并不实际更新视图;相反,视图将会在下一个更新周期(系统调用这些视图以及后续所有子视图的<code>layoutSubviews</code>方法)实际更新视图的布局;即使从<code>setNeedsLayout</code>返回后到视图被重新绘制布局之间有一段任意的时间间隔,但是这个延迟不会对用户造成影响,因为永远不会长到对界面造成卡顿;</p>
<h3 id="layoutIfNeeded"><a href="#layoutIfNeeded" class="headerlink" title="layoutIfNeeded()"></a>layoutIfNeeded()</h3><p><code>layoutIfNeeded</code>是<code>UIView</code>的另一个将会在不久后触发<code>layoutSubviews</code>调用的方法;与<code>setNeedsLayout</code>会让视图在下一个周期调用<code>layoutSubviews</code>更新视图不同,<code>layoutIfNeeded</code>会立即触发<code>layoutSubviews</code>方法调用,如果视图需要布局更新的话;如果你在调用<code>setNeedsLayout</code>方法或者触发上面描述的自动刷新触发器之后调用了<code>layoutIfNeeded</code>方法,<code>layoutSubviews</code>将会在视图上被调用;然而,如果你调用<code>layoutIfNeeded</code>之后没有动作指示系统视图需要重新刷新视图,那么<code>layoutSubviews</code>方法将不会被调用;<br>在一次运行循环中,两次调用视图的<code>layoutIfNeeded</code>方法之间,视图的布局并没有变化的话,那么第二次调用将不会触发<code>layoutSubviews</code>的调用;</p>
<p>与<code>setNeedsLayout</code>方法不同,使用<code>layoutIfNeeded</code>方法,布局和重绘会在函数返回之前立即发生改变(除非有正在运行中的动画);这个方法在你需要依赖新的布局而又无法等待视图的下次更新周期到来的时候特别有用;然而,除了这种情况外,你还是应该调用<code>setNeedsLayout</code>然后等待下次更新周期的到来,这样在每次运行循环中都只会更新一次布局;</p>
<p>动画更改约束时,此方法特别有用;您应该在动画的 block 开始之前调用一次<code>layoutIfNeeded</code>,以确保在动画开始之前通知所有的布局更新;配置新的约束,然后在动画 block 内,再次调用<code>layoutIfNeeded</code>以动画到最新的状态;</p>
<h2 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h2><p>视图的显示包含颜色,文本,图片和Core Graphics绘制等视图属性,但不包含它和它的子视图的大小和位置;和布局的方法类似,显示也有触发更新的方法,它们由系统在检测到更新时被自动调用,或者我们可以手动调用直接触发更新;</p>
<h3 id="draw"><a href="#draw" class="headerlink" title="draw(_:)"></a>draw(_:)</h3><p><code>UIView</code>的<code>draw</code>方法(Objective-C中的<code>drawRect</code>)对视图的显示内容的作用	就像 <code>layoutSubviews</code>方法对视图的位置和尺寸的作用;同<code>layoutSubviews</code>一样,你不应该在代码中直接调用<code>draw</code>方法,而应该在运行循环的不同点调用能触发<code>draw</code>方法调用的方法;然而,与<code>layoutSubviews</code>方法不同的是,<code>draw</code>方法不会触发后续子视图的调用;</p>
<h3 id="setNeedsDisplay"><a href="#setNeedsDisplay" class="headerlink" title="setNeedsDisplay()"></a>setNeedsDisplay()</h3><p>这个方法类似布局中的<code>setNeedsLayout</code>;它会给有显示内容更新的视图设置一个内部的标记之后返回,并不会真正的视图重绘;而是在接下来的更新周期中,系统会遍历所有已被标记的视图,调用它们的<code>draw</code>方法;如果你只想在下次更新时重绘部分的视图,你可以调用<code>setNeedsDisplay(_:)</code>(Objective-C中的<code>setNeedsDisplayInRect:</code>)方法,并把希望重绘的矩形部分传入参数;</p>
<p>大部分时候,在视图中更新任何 UI 组件都会通过自动设置内部的”显示内容更新”标记将视图标记为”dirty”的;导致在下一次更新周期中视图的内容就会重绘而不需要直接显示调用<code>setNeedsDisplay</code>;然而如果你有一个属性没有绑定到UI控件,但需要在属性值每次更新重绘视图,那么你可以实现该属性的<code>didSet</code>方法,并在里面调用<code>setNeedsDisplay</code>方法来触发视图的更新;</p>
<p>有时设置一个属性要求自定义绘制,这种情况下你需要重写<code>draw</code>方法;在下面的例子中,设置<code>numberOfPoints</code>会触发系统根据具体点数绘制不同的视图;在这个例子中,你需要在<code>draw</code>方法中实现自定义绘制,并在<code>numberOfPoints</code>的property observer里调用<code>setNeedsDisplay</code>;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class MyView: UIView &#123;</span><br><span class="line">	var numberOfPoints = 0 &#123;</span><br><span class="line">		didSet &#123;</span><br><span class="line">			setNeedsDisplay()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	override func draw(_ rect: CGRect) &#123;</span><br><span class="line">		switch numberOfPoints &#123;</span><br><span class="line">		case 0: </span><br><span class="line">			return</span><br><span class="line">		case 1: </span><br><span class="line">			drawPoint(rect)</span><br><span class="line">		case 2:</span><br><span class="line">			drawLine(rect)</span><br><span class="line">		case 3: </span><br><span class="line">			drawTriangle(rect)</span><br><span class="line">		case 4:</span><br><span class="line">			drawRectangle(rect)</span><br><span class="line">		case 5: </span><br><span class="line">			drawPentagon(rect)</span><br><span class="line">		default:</span><br><span class="line">			drawEllipse(rect)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>视图的显示方法里没有类似布局中的<code>layoutIfNeeded</code>这样可以触发立即更新的方法;通常情况下等到下一个更新周期再重新绘制视图也无所谓;</p>
<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>在自动布局技术中布局和重绘视图有三个步骤;第一步是更新约束,系统计算并设置视图上所有必需的约束条件;第二步是布局阶段,布局引擎计算视图和子视图的 frame 并且将它们布局;最后一步完成这一循环的是显示阶段;第三步完成此次循环的是显示阶段,如果有必要,那么通过调用视图的<code>draw</code>方法重绘视图的内容;</p>
<h3 id="updateConstraints"><a href="#updateConstraints" class="headerlink" title="updateConstraints()"></a>updateConstraints()</h3><p>这个方法用在自动布局中动态的改变视图的约束;和布局中的<code>layoutSubviews</code>方法和显示内容中的<code>draw</code>方法类似,<code>updateConstraints</code>只应该被重写,而不应该在你的代码中直接调用;一般来说,您应该在<code>updateConstraints</code>方法中仅仅实现必须要更新的约束;静态的约束应该设置在interface builder,视图的初始化方法(initializer)或者控制器的<code>viewDidLoad</code>中;</p>
<p>通常情况下,开启或者关闭约束,更改约束的优先级或者常量值,或者从视图层级中移除一个视图时都会设置一个内部的标记,这个标记将会在下一次更新周期触发<code>updateConstraints</code>方法调用;当然啦,也有手动的给视图打上需要更新约束的标记的方法,如下:</p>
<h3 id="setNeedsUpdateConstraints"><a href="#setNeedsUpdateConstraints" class="headerlink" title="setNeedsUpdateConstraints()"></a>setNeedsUpdateConstraints()</h3><p>调用<code>setNeedsUpdateConstraints</code>会保证在下一次的更新周期中更新约束;它通过标记视图的约束已更新来触发<code>updateConstraints</code>调用;这个方法和<code>setNeedsDisplay</code>,<code>setNeedsLayout</code>方法的工作机制类似;</p>
<h3 id="updateConstraintsIfNeeded"><a href="#updateConstraintsIfNeeded" class="headerlink" title="updateConstraintsIfNeeded()"></a>updateConstraintsIfNeeded()</h3><p>这个方法就等同于使用了自动布局的视图中的<code>layoutIfNeeded</code>方法;它会检查视图约束是否更新的标记(能够被自动设置,或者通过<code>setNeedsUpdateConstraints</code>设置,或者通过<code>invalidateInstrinsicContentSize</code>设置),如果它表明约束需要更新,它将立刻触发<code>updateConstraints</code>方法的调用而不需要等到运行循环的结束;</p>
<h3 id="invalidateIntrinsicContentSize"><a href="#invalidateIntrinsicContentSize" class="headerlink" title="invalidateIntrinsicContentSize()"></a>invalidateIntrinsicContentSize()</h3><p>一些使用自动布局的视图中会有一个<code>intrinsicContentSize</code>的属性,这是视图根据它的内容得到的自然尺寸;一个视图的<code>intrinsicContentSize</code>属性通常由所包含的元素的约束来决定,但是也可以通过重写来提供自定义的行为;调用<code>invalidateIntrinsicContentSize</code>会设置一个标记表示这个视图的<code>intrinsicContentSize</code>已经过期,需要在下一个布局阶段重新计算;</p>
<h2 id="它们是如何连接的"><a href="#它们是如何连接的" class="headerlink" title="它们是如何连接的"></a>它们是如何连接的</h2><p>视图的布局,显示以及约束都遵循着相似的模式,例如它们更新的方式以及如何在运行循环的不同点上强制更新;任意组件都有一个实际去更新的方法(<code>layoutSubviews</code>,<code>draw</code>,以及<code>updateConstraints</code>),你可以重写来手动操作视图,但是任何情况下都不要在你的代码中直接调用;这些方法仅仅在视图有标记,告诉系统视图的某些组件需要更新了,在主运行循环的后面被调用;有些操作会自动设置这个标志,也有一些方法能够让您手动的设置它;对于布局和约束的更新,如果您无法等到更新周期的到来(因为有些操作依赖最新的布局),有这么一些方法可以让你立即更新,并保证布局需要更新标记被正确标记;下面的表格列出了任意组件会怎样更新及其对应方法;</p>
<table>
<thead>
<tr>
<th>Method purposes</th>
<th>Layout</th>
<th>Display</th>
<th>Constraints</th>
</tr>
</thead>
<tbody><tr>
<td>Implement updates(override,don’t call explicitly)</td>
<td><code>layoutSubviews</code></td>
<td><code>draw</code></td>
<td><code>updateConstraints</code></td>
</tr>
<tr>
<td>Explicitly mark view as needing update on next update cycle</td>
<td><code>setNeedsLayout</code></td>
<td><code>setNeedsDisplay</code></td>
<td><code>setNeedsUpdateConstraints</code> <code>invalidateIntrinsicContentSize</code></td>
</tr>
<tr>
<td>Update iimmediately if view is marked as ‘dirty’</td>
<td><code>layoutIfNeeded</code></td>
<td></td>
<td><code>updateConstraintsIfNeeded</code></td>
</tr>
<tr>
<td>Actions that implicitly cause views to be updated</td>
<td><code>addSubview</code><br> Resizing视图,通过<code>setFrame</code>改变视图的<code>bounds</code>(不只是translation)<br>用户滑动UIScrollView<br>用户旋转设备</td>
<td>改变视图的<code>bounds</code></td>
<td>激活&#x2F;禁用约束<br>更改约束的值或者优先级<br>从视图层次结构中移除视图</td>
</tr>
</tbody></table>
<p>下面的流程图总结了<strong>更新周期</strong>和<strong>事件循环</strong>之间的交互,并指出了上文提到的方法在<strong>运行循环</strong>期间的位置;你可以在运行循环中的任意一点直接的调用<code>layoutIfNeeded</code>或者<code>updateConstraintsIfNeeded</code>,需要记住,这开销会很大;在循环的主运行循环的后面是更新周期,如果视图被设置特定的”需要更新约束”,”需要更新布局”或者”需要更新显示”的标记,在这个节点会进行更新约束,更新布局以及更新显示内容;一旦这些更新结束,主运行循环会重新开始;</p>
<p><img src="http://tech.gc.com/images/demystifying-ios-layout/update_cycle.png" alt="Update Cycle"><em><a href="https://i.stack.imgur.com/i9YuN.png">https://i.stack.imgur.com/i9YuN.png</a></em></p>
]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一个pod install失败的解决方法</title>
    <url>/2018/04/16/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%AApod-install%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>今天在网络看到一个demo,想把它clone下来运行一下看看效果,大家都知道一般clone下来的项目需要使用<code>pod install</code>命令安装一下第三方库的,这个demo也不例外;问题在于这个demo的cocoapods版本太低了(0.39.0)以至于Podfile中有些语法现如今都无法识别…以下截图是执行<code>pod install</code>命令之后给出了的错误提示:<br><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/master/Snip20180416_21.png"></p>
<p>项目的Podfile如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source &#x27;https://github.com/CocoaPods/Specs.git&#x27;</span><br><span class="line">use_frameworks!</span><br><span class="line"></span><br><span class="line">target &#x27;RTPagedCollectionViewLayout_Example&#x27;, :exclusive =&gt; true do</span><br><span class="line">  pod &#x27;RTPagedCollectionViewLayout&#x27;, :path =&gt; &#x27;../&#x27;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">target &#x27;RTPagedCollectionViewLayout_Tests&#x27;, :exclusive =&gt; true do</span><br><span class="line">  pod &#x27;RTPagedCollectionViewLayout&#x27;, :path =&gt; &#x27;../&#x27;</span><br><span class="line">  </span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>大概的意思就是不支持 :exclusive &#x3D;&gt; true语法，在cocoaPods 1.0之后exclusive语法已经被移除了</p>
<p><a href="https://github.com/CocoaPods/CocoaPods/issues/4705">这里是Stack Overflow上的解答</a></p>
<p>将相关的代码删除之后,注意<code>,</code>号也要删除;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source &#x27;https://github.com/CocoaPods/Specs.git&#x27;</span><br><span class="line">use_frameworks!</span><br><span class="line"></span><br><span class="line">target &#x27;RTPagedCollectionViewLayout_Example&#x27; do</span><br><span class="line">  pod &#x27;RTPagedCollectionViewLayout&#x27;, :path =&gt; &#x27;../&#x27;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">target &#x27;RTPagedCollectionViewLayout_Tests&#x27; do</span><br><span class="line">  pod &#x27;RTPagedCollectionViewLayout&#x27;, :path =&gt; &#x27;../&#x27;</span><br><span class="line">  </span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>再次执行<code>pod install</code>命令,结果如下<br><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/master/Snip20180416_22.png"><br>已经安装成功了,给了两个警告⚠️,你可以不用管它,有强迫症的同学可以在target前加上<code>platform :ios, &#39;7.1&#39;</code>,这个7.1是你的项目的Deployment Target…</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source &#x27;https://github.com/CocoaPods/Specs.git&#x27;</span><br><span class="line">use_frameworks!</span><br><span class="line"></span><br><span class="line">platform :ios, &#x27;7.1&#x27;</span><br><span class="line"></span><br><span class="line">target &#x27;RTPagedCollectionViewLayout_Example&#x27; do</span><br><span class="line">  pod &#x27;RTPagedCollectionViewLayout&#x27;, :path =&gt; &#x27;../&#x27;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">target &#x27;RTPagedCollectionViewLayout_Tests&#x27; do</span><br><span class="line">  pod &#x27;RTPagedCollectionViewLayout&#x27;, :path =&gt; &#x27;../&#x27;</span><br><span class="line">  </span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>再次运行<code>pod install</code>完美</p>
<p><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/master/Snip20180416_23.png"></p>
]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
</search>
