<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>设计模式</title>
    <url>/2019/04/04/2019-04-04-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>#关于设计模式</p>
<table>
<thead>
<tr>
<th>*</th>
<th>*</th>
<th align="left">创建型</th>
<th align="left">结构型</th>
<th align="left">行为型</th>
</tr>
</thead>
<tbody><tr>
<td>范围</td>
<td>类</td>
<td align="left">Factory Method</td>
<td align="left">Adapter(类)</td>
<td align="left">Interpreter<br>Template Method</td>
</tr>
<tr>
<td>*</td>
<td>对象</td>
<td align="left">Abstract Factory<br>Builder<br>Prototype<br>Singleton</td>
<td align="left">Adapter(对象)<br>Bridge<br>Composite<br>Decorator<br>Facade<br>Flyweight<br>Proxy<br></td>
<td align="left">Chain of Responsibility<br>Command<br>Iterator<br>Mediator<br>Memento<br>Observer<br>State<br>Stragegy<br>Visitor</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>OC与iOS混编</title>
    <url>/2019/04/12/2019-04-12-OC%E4%B8%8EiOS%E6%B7%B7%E7%BC%96/</url>
    <content><![CDATA[<h1 id="记录一下-OC和Swift混编的问题"><a href="#记录一下-OC和Swift混编的问题" class="headerlink" title="记录一下,OC和Swift混编的问题"></a>记录一下,OC和Swift混编的问题</h1><p>在OC项目中,需要使用Swift的时候,一般情况下,在你的OC项目中新建一个Swift文件的时候,系统会自动提示你是否需要配置一个Objective-C桥接头文件,如下图:<img src="https://github.com/masterKing/markDownPictures/blob/master/Snip20190412_4.png?raw=true"><br>点击最右侧的创建桥接头文件,系统就会帮你配置创建并配置好一个桥接头文件…这个桥接头文件的作用是,让你可以在Swift代码中使用OC中的类;只需要将你需要在Swift代码中使用的类的头文件在桥接头文件中导入一下就可以使用了;如果一不小心点击了Don’t Create按钮,那就需要你自己再手动创建一个头文件,将它配置成桥接头文件,才可以使用.配置步骤如下:</p>
<ol>
<li>创建一个头文件<br> <img src="https://github.com/masterKing/markDownPictures/blob/master/Snip20190412_5.png?raw=true"><br> <img src="https://github.com/masterKing/markDownPictures/blob/master/Snip20190412_6.png?raw=true"></li>
<li>配置成为OC桥接头文件<br> <img src="https://github.com/masterKing/markDownPictures/blob/master/Snip20190412_7.png?raw=true"><br>在里面导入OC的头文件,就可以在Swift代码中使用了</li>
</ol>
<p>如果是想要在OC的代码中使用Swift的类的话,这个就更加简单了,只需要导入一个系统自动生成的头文件就可以访问了,这个头文件在项目目录中看不到;但是在上图标记③的框框下面你可以看到它的名字,直接导入这个头文件就可以使用了,需要注意的是系统并不会自动补全这个头文件…没有提示,需要你自己一个一个字母敲进去</p>
<hr>

<p>再来说一下,在Swift项目中,想要使用OC代码;跟上面的步骤是一样的,第一次在Swift项目中创建OC类的时候,系统就会提示你是否创建Objective-C桥接头文件;这个头文件的作用跟上是一样的,让你可以在Swift代码中使用OC的类,只需在这个头文件导入OC类就行了…在OC代码中想要使用Swift类也跟上面一样,导入系统自动生成的那个头文件就可以使用了</p>
]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一个报错</title>
    <url>/2019/04/25/2019-04-25-%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%AA%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<h1 id="Undefined-symbols-for-architecture-arm64"><a href="#Undefined-symbols-for-architecture-arm64" class="headerlink" title="Undefined symbols for architecture arm64"></a>Undefined symbols for architecture arm64</h1><p><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/master/Snip20190425_23.png">上面这个报错经常会遇到…但是一直不知道是为啥出现的…今天碰巧知道了出现的原因</p>
<p>错误出现的步骤是这样的</p>
<ul>
<li><ol>
<li>首先我新建了Director和ConcreteBuild两个类</li>
</ol>
</li>
<li><ol start="2">
<li>在viewController.m中我使用这两个类写了一些代码</li>
</ol>
</li>
<li><ol start="3">
<li>这个时候我觉得这两个类写的不好不想要了,于是全部删除了…</li>
</ol>
</li>
</ul>
<p>但此时在viewController.m中的代码还没有移除掉;再次编译运行的时候就会报<br>Undefined symbols for architecture arm64:<br>“_OBJC_CLASS_$_Director”, referenced from:<br>objc-class-ref in ViewController.o<br>知道了错误产生的原因之后,再解决问题就很容易了…去viewController.m文件中把相关的代码全删了就好了…<br>只是有点儿疑惑为什么xcode不报找不到头文件Director或ConcreteBuild错误,而报这个Undefined symbols for architecture arm64:错误…一脸懵</p>
]]></content>
  </entry>
  <entry>
    <title>MBProgressHUD源码解析</title>
    <url>/2020/06/24/2020-06-24-MBProgressHUD%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="MBProgressHUD"><a href="#MBProgressHUD" class="headerlink" title="MBProgressHUD"></a>MBProgressHUD</h1><p>从入行以来,就经常听说,学习编程进步最快的方式,就是阅读优秀作品的源码…</p>
<p>那么,今天我来阅读一下MBProgressHUD这个库的源码…</p>
<p>查看一下文件,非常简单的俩个MBProgressHUD.h和MBProgressHUD.m文件</p>
<p>没什么说的,从MBProgressHUD.h文件开始看吧;</p>
<p>头文件首先声明了一个自定义的类 <code>MBBackgroundView</code> 和 一个协议 <code>MBProgressHUDDelegate</code>,自定义类放在这里声明一下,应该是因为<code>MBProgressHUD</code>里面使用到了<code>MBBackgroundView</code>类,且<code>MBProgressHUD</code>的声明与实现都放在了<code>MBBackgroundView</code>的前面,将<code>MBBackgroundView</code>的位置挪到比<code>MBProgressHUD</code>靠前的地方就不需要提前声明了,这个很简单,不需要多说了吧;而代理协议<code>MBProgressHUDDelegate</code>,对于做过iOS的开发人来说,应该说是再熟悉不过了…</p>
<p>接下来声明了一个供外部使用的变量<code>extern CGFloat const MBProgressMaxOffset;</code>,使用<code>extern</code>修饰了的变量能够在其他文件也可以访问到;往下查看头文件的时候,发现是为了给属性<code>offset</code>使用的,注释里面写到可以使用CGPointMake(0.f, MBProgressMaxOffset)来使HUD的位置处于底部边缘的中心位置</p>
<p>然后是4个自定义类型,<code>MBProgressHUDMode``MBProgressHUDAnimation``MBProgressHUDBackgroundStyle``MBProgressHUDCompletionBlock</code>;这四个类型也都比较简单,见名字大概就知道是什么意思了,简单提一下;<br><code>MBProgressHUDMode</code>mode翻译过来叫(设备的)模式,方式,风格,样式…在这里取风格或者样式应该更加恰当;它有6种不同的样式:</p>
<ul>
<li><code>MBProgressHUDModeIndeterminate </code>	&#x2F;&#x2F;iOS系统原生的UIActivityIndicatorView</li>
<li><code>MBProgressHUDModeDeterminate </code>	&#x2F;&#x2F;一个圆形的饼状进度视图样式</li>
<li><code>MBProgressHUDModeDeterminateHorizontalBar </code>	&#x2F;&#x2F;一个水平的条状进度视图样式</li>
<li><code>MBProgressHUDModeAnnularDeterminate </code>	&#x2F;&#x2F;圆环形的进度视图样式</li>
<li><code>MBProgressHUDModeCustomView </code>	&#x2F;&#x2F;自定义视图样式</li>
<li><code>MBProgressHUDModeText </code> &#x2F;&#x2F;纯文字样式</li>
</ul>
<p><code>MBProgressHUDAnimation</code>动画类型</p>
<ul>
<li><code>MBProgressHUDAnimationFade</code> &#x2F;&#x2F;淡入淡出</li>
<li><code>MBProgressHUDAnimationZoom</code> &#x2F;&#x2F;出现时放大,消失时缩小</li>
<li><code>MBProgressHUDAnimationZoomOut</code> &#x2F;&#x2F;缩小</li>
<li><code>MBProgressHUDAnimationZoomIn</code> &#x2F;&#x2F;放大</li>
</ul>
<p><code>MBProgressHUDBackgroundStyle</code>背景风格</p>
<ul>
<li><code>MBProgressHUDBackgroundStyleSolidColor</code> &#x2F;&#x2F;纯色</li>
<li><code>MBProgressHUDBackgroundStyleBlur</code> &#x2F;&#x2F;模糊,毛玻璃效果</li>
</ul>
<p><code>MBProgressHUDCompletionBlock</code>是一个无返回值无参数的block</p>
<p>接来下是<code>MBProgressHUD</code>的正式声明了<br>首先是7个方法声明</p>
<p>前三个为类方法:</p>
<p><code>+ (instancetype)showHUDAddedTo:(UIView *)view animated:(BOOL)animated;</code></p>
<p><code>+ (BOOL)hideHUDForView:(UIView *)view animated:(BOOL)animated;</code></p>
<p><code>+ (nullable MBProgressHUD *)HUDForView:(UIView *)view;</code></p>
<p>后面为对象方法:</p>
<p><code>- (instancetype)initWithView:(UIView *)view;</code></p>
<p><code>- (void)showAnimated:(BOOL)animated;</code></p>
<p><code>- (void)hideAnimated:(BOOL)animated;</code></p>
<p><code>- (void)hideAnimated:(BOOL)animated afterDelay:(NSTimeInterval)delay;</code></p>
<p>每个方法的注释都很详细,不需要多介绍什么的,接下来看看属性</p>
<p><code>@property (weak, nonatomic) id&lt;MBProgressHUDDelegate&gt; delegate;</code><br><code>@property (copy, nullable) MBProgressHUDCompletionBlock completionBlock;</code><br>这两个属性都是用来回传HUD消失事件的,代理协议里面也只有一个HUD已经隐藏的方法</p>
<p><code>@property (assign, nonatomic) NSTimeInterval graceTime;</code>这个属性很有意思,一开始我理解成下面那个属性<code>minShowTime</code>了,往下看到<code>minShowTime</code>之后,我才发现理解错了;这个属性的意思是:如果有graceTime,那么HUD在graceTime之后才显示.作用就是不让时间非常短的任务显示HUD(嗯,用处好像不是很大,我看了下我们项目,没有一个地方使用…)举个例子:我们一般会在网络请求发起之前显示HUD,在网络请求返回时隐藏HUD,在不考虑下面<code>minShowTime</code>属性的情况下,如果这个时间间隔非常短,就会出现显示了HUD瞬间就消失了的尴尬情况,那么这个时候,设置一个graceTime,对于那些时间非常短的异步任务就根本不会显示也没有必要显示HUD了</p>
<p><code>@property (assign, nonatomic) NSTimeInterval minShowTime;</code>这个属性的作用就容易理解多了,最小显示时间;同样也是为了解决时间间隔很短的异步任务问题,你还察觉不到就结束了,那么这个HUD压根就看不见…所以加上这么一个时间</p>
<p><code>@property (assign, nonatomic) BOOL removeFromSuperViewOnHide;</code>这个也是非常好理解,隐藏的时候是否从父视图移除</p>
<h6 id="下面的属性时跟外观-Appearance-相关的"><a href="#下面的属性时跟外观-Appearance-相关的" class="headerlink" title="下面的属性时跟外观(Appearance)相关的"></a>下面的属性时跟外观(Appearance)相关的</h6><p><code>@property (assign, nonatomic) MBProgressHUDMode mode;</code> 样式<br><code>@property (strong, nonatomic, nullable) UIColor *contentColor</code> 内容颜色<br><code>@property (assign, nonatomic) MBProgressHUDAnimation animationType</code> 显示或隐藏时的动画类型<br><code>@property (assign, nonatomic) CGPoint offset</code> 相对于视图中心的边框偏移量<br><code>@property (assign, nonatomic) CGFloat margin</code> HUD边缘和HUD元素之间的间距<br><code>@property (assign, nonatomic) CGSize minSize</code> HUD边框的最小尺寸<br><code>@property (assign, nonatomic, getter = isSquare) BOOL square</code> 如果可能的话，强制HUD尺寸相等。<br><code>@property (assign, nonatomic, getter=areDefaultMotionEffectsEnabled) BOOL defaultMotionEffectsEnabled</code> 当启用时，bezel center会受到设备加速计数据的轻微影响</p>
<h6 id="进度相关属性-Progress"><a href="#进度相关属性-Progress" class="headerlink" title="进度相关属性(Progress)"></a>进度相关属性(Progress)</h6><p><code>@property (assign, nonatomic) float progress;</code> 进度指示器的进度,取值0.0~1.0,默认为0.0</p>
<h6 id="进度对象相关属性-ProgressObject"><a href="#进度对象相关属性-ProgressObject" class="headerlink" title="进度对象相关属性(ProgressObject)"></a>进度对象相关属性(ProgressObject)</h6><p><code>@property (strong, nonatomic, nullable) NSProgress *progressObject;</code> 不是太明白干什么的</p>
<h6 id="视图相关属性-Views"><a href="#视图相关属性-Views" class="headerlink" title="视图相关属性(Views)"></a>视图相关属性(Views)</h6><p><code>@property (strong, nonatomic, readonly) MBBackgroundView *bezelView;</code> 包含文本标签和指示器(或者自定义视图)的边框视图<br><code>@property (strong, nonatomic, readonly) MBBackgroundView *backgroundView;</code> 覆盖整个HUD区域，放置在bezelView后面的视图<br><code>@property (strong, nonatomic, nullable) UIView *customView;</code> 当HUD样式为MBProgressHUDModeCustomView的时候,显示的视图;视图应该实现intrinsicContentSize方法已显示正确的大小,为了得到最好的效果,建议使用37x37像素<br><code>@property (strong, nonatomic, readonly) UILabel *label;</code> 显示在活动指示器下方的文本标签,HUD会自动调整大小以适应整个文本<br><code>@property (strong, nonatomic, readonly) UILabel *detailsLabel;</code> 一个标签，其中包含一个可选的详细信息消息，显示在labelText消息下面。细节文本可以跨越多行。<br><code>@property (strong, nonatomic, readonly) UIButton *button;</code> 放在标签下面的按钮。只有在添加target和action后才可见。</p>
<p>好了,MBProgressHUD的方法属性就这些了…<br>接下来看看MBProgressHUD头文件里,其他的类的声明;</p>
<p>首先是<code>MBRoundProgressView</code>这个应该是饼图样式时使用到的视图,只有4个属性<br><code>@property (nonatomic, assign) float progress;</code> 进度<br><code>@property (nonatomic, strong) UIColor *progressTintColor;</code> 指示器进度的颜色<br><code>@property (nonatomic, strong) UIColor *backgroundTintColor;</code> 指示器背景色<br><code>@property (nonatomic, assign, getter = isAnnular) BOOL annular;</code> 是否环形,不是很清楚什么效果…</p>
<p>然后是<code>MBBarProgressView</code>,这个应该是一个扁平的进度条视图<br><code>@property (nonatomic, assign) float progress;</code> 进度<br><code>@property (nonatomic, strong) UIColor *lineColor;</code> 条状边框线颜色<br><code>@property (nonatomic, strong) UIColor *progressRemainingColor;</code> 条状背景色<br><code>@property (nonatomic, strong) UIColor *progressColor;</code> 条状进度颜色</p>
<p>最后是<code>MBBackgroundView</code>,这个是背景视图<br><code>@property (nonatomic) MBProgressHUDBackgroundStyle style;</code> 背景样式,毛玻璃或者纯色,iOS7和它之后都是毛玻璃效果,之前是纯色<br><code>@property (nonatomic) UIBlurEffectStyle blurEffectStyle;</code> 模糊效果样式<br><code>@property (nonatomic, strong) UIColor *color;</code> 背景色</p>
<p>以上就是MBProgressHUD.h文件的全部内容了,其实还有一部分,是遗弃的旧版本的代码就不看了</p>
<p>下面,我来看看.m文件源码,这才是重点啊</p>
]]></content>
  </entry>
  <entry>
    <title>2023年10月了黑苹果还香吗？性价比超高黑苹果台式机搭配&amp;黑苹果安装教程</title>
    <url>/2023/10/19/2023-10-19-2023%E5%B9%B410%E6%9C%88%E4%BA%86%E9%BB%91%E8%8B%B9%E6%9E%9C%E8%BF%98%E9%A6%99%E5%90%97%EF%BC%9F%E6%80%A7%E4%BB%B7%E6%AF%94%E8%B6%85%E9%AB%98%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%8F%B0%E5%BC%8F%E6%9C%BA%E6%90%AD%E9%85%8D-%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h1><p>最近一段时间对 iOS 逆向开发进行了一定的研究，之前也更新过一段时间的相关文章（后续由于搬家，不幸感染病毒🦠等一些原因断更了个把月），在学习和探索过程中，非常明显的感受到逆向分析对电脑的性能要求很高尤其是 CPU，在使用逆向分析工具 ghidra，hopper 等程序对 MachO 文件进行分析的时候，常常一分析就要等上大几个小时，而且我使用了 n 年的 MacBook Pro 在分析过程中 CPU 温度总是会飙升到 90 度以上，同时 CPU 散热风扇转速也高达 4500 转以上，甚至经常满转速 6000 转运行，噪音可想而知。等待的时间，加上风扇的噪音真的会让人失去耐性，忍无可忍之下决定购买一台性能强劲的，性价比超高的 Mac 电脑。</p>
<p>翻到苹果官网查看，动辄 3 万，5 万，甚至高达 10 万+ 的 iMac，Mac Pro，随随便便几千元的选配，让人直呼**，好奇是什么配置居然敢卖到如此价格，研究一番配置才发现价格真的是太离谱了。。。呃，苹果产品从来就不是主打一个性价比的啊。于是让人想到何不自己动手组装一台台式电脑，既能安装 windows 打打游戏娱乐放松，又能安装黑苹果日常学习工作使用。但是要注意安装黑苹果并不是一件简单，方便，快速，愉悦的事情。而且不建议在公司使用黑苹果，网上看到会收到 Apple 的律师函，尤其是一些大公司。个人作为兴趣爱学习交流使用倒也不必担心那么多。</p>
<p>对组装电脑配置和苹果 Mac 产品有些了解的人应该都知道，苹果的产品毫无性价比，尤其是台式电脑，同等配置的产品，苹果卖的贵很多，的确不可否认的是苹果的产品做的非常优秀，不论是电脑还是手机，从硬件，软件到外观设计，都属于一流的水平。笔记本电脑的确没有几家公司能做到像 MacBook 这样的水平，所以你不想要台式电脑，MacBook 还是可以推荐上车的，台式机是真的不推荐购买。但如果你是富哥想买台式机，有 MacOS 需求，对性能又没有特别高的要求，也不想折腾的，那还是直接去购买 iMac，Mac Pro 吧。但本人不是富哥，对性能还有一定的要求，还愿意折腾的选择自己组装台式机安装黑苹果就是最好的选择。</p>
<h1 id="黑苹果的现状与未来"><a href="#黑苹果的现状与未来" class="headerlink" title="黑苹果的现状与未来"></a>黑苹果的现状与未来</h1><p>最近这两年还能赶上黑苹果的末班车，再过个三五年，最多可能不超过 10 年，市面上所有 Intel + AMD 的白苹果被苹果公司抛弃，不再支持安装最新的 MacOS 系统的时候，应该就再也看不到黑苹果了。</p>
<p>今年 6 月 5 号，最后一代 Intel CPU （至强系列，属于服务器CPU） + AMD GPU 的 Mac Pro 停产了。而最后一代的家用桌面级 CPU 也就是 Intel 酷睿 10910 的 iMac （搭配的 GPU 是 RX 5700XT） 也已经早在 2022 年 3 月 8 号停产了。数据来源：<a href="https://everymac.com/">everymac</a> 。经过网上对黑苹果的一番研究，特别是 GitHub 上的一个开源项目 <a href="https://dortania.github.io/OpenCore-Install-Guide/">OpenCore</a>，感谢开源，感谢hacker，国内的大部分教程其实都是对这个项目的中文翻译加自己的整理，建议想要安装黑苹果的不管英文行的不行的都先看看这个（网页有翻译工具，阅读起来也没那么困难）得出以下一些结论：</p>
<p>到写这篇文章为止，目前能安装黑苹果的最顶级搭配，应该是：</p>
<ul>
<li>CPU i9 13900KS + GPU RX 6950XT，最近刚出的 14 代酷睿还不确定能不能安装黑苹果。</li>
</ul>
<p>最后一代能最完美实现黑苹果的顶级搭配：</p>
<ul>
<li>CPU i9 10910 + GPU RX 5700XT，这个是苹果 iMac 最后一代桌面级 Intel CPU + AMD GPU 产品，已于 2022 年 3 月 8 号停产，之后的 iMac 都是搭配苹果自研的 M 芯片了。购买跟这个同样的配置完全不担心黑苹果安装的问题，完美适配的问题。2022 年 3 月的机型配置，这个配置用个三五年也完全不成问题。</li>
</ul>
<p>个人经过对价格，性能一番分析之后认为，目前最具性价比的黑苹果搭配是：</p>
<ul>
<li>CPU i9 11900KF + GPU RX 6600XT。</li>
</ul>
<h1 id="配件选择"><a href="#配件选择" class="headerlink" title="配件选择"></a>配件选择</h1><p>组装一台台式电脑所需的配件大概是以下 8 个部分。其中对安装黑苹果影响最大的就是 CPU，GPU 了，其次是硬盘，最后稍微可能有点影响的就是内存了，最新的 DDR5 内存频率太高的不太推荐，听说是会影响黑苹果系统的稳定性。其余的就跟能否安装黑苹果没有任何关系了。我将有影响的配件放在前面讲，后续没有影响的配件都简单带过。</p>
<h2 id="CPU-的选择"><a href="#CPU-的选择" class="headerlink" title="CPU 的选择"></a>CPU 的选择</h2><p>原本以为 10 代的 CPU 会比 11 代的 CPU 会更便宜，毕竟是电子产品，年代又更久远一些，万万没有想到 10 代酷睿不知道是有哪些魔力，居然卖的比 11 代酷睿更贵。目前，11900KF 不过 ¥1200 出头，RX 6600XT 如果接受矿卡的话，也只需要 ¥1100 上下，不接受矿卡的可以选择 RX 6650XT。而且性能功耗也比 iMac 最后一代的 RX 5700XT 更加优秀。这样 CPU + GPU 买下来也只需要 ¥2300 左右。而如果买 10910 或者 10900K&#x2F;KF 的话光一个 CPU 就差不多要这个价钱了。其中 </p>
<ul>
<li>10910 价格在 ¥2050 左右。</li>
<li>10900KF 价格在 ¥1950 左右。</li>
<li>10900K 的价格要 ¥2300 以上。</li>
</ul>
<p>这样光一个 CPU 的价格就赶上 11900KF + RX 6600XT 的组合了，性能却还不如这个组合。当然如果你没有 GPU 的需求，购买 10900K 使用它的核显也是可以的。10900K 的核显理论上也能搭配 4k 显示器日常使用。</p>
<p>12 代 i5 12600 及以上等级的 CPU 和 13 代的 i5 13490F 及以上等级的 CPU 单核性能理论上都比 i9 11900KF 强一些（<a href="https://www.mydrivers.com/zhuanti/tianti/cpu/index.html">CPU性能天梯图</a>），但是这几代产品不像魔幻的 10 代酷睿，都是一分钱一分货，都要比 11900KF 贵上一些。如果不追求很高的性价比，希望性能更强一些的，也可以选择这两款或以上的 CPU。</p>
<p><img src="/../images/11900KF.jpg" alt="11900KF"></p>
<h2 id="GPU-的选择"><a href="#GPU-的选择" class="headerlink" title="GPU 的选择"></a>GPU 的选择</h2><p>其实本来是打算照着苹果的最后一代 Intel iMac 的配置去搭配台式机的，这样不用担心能不能成功安装黑苹果，MacOS 系统能不能完美支持。也就是 10 代 i9 搭配 RX 5700XT。但是 10 代酷睿 i9 的价格让我放弃了这个想法，发现了更具性价比的 11 代 i9，于是想着既然 CPU 提升了一个等级，那么显卡要不也提升一下等级吧，RX 6600XT 性能略强于 RX 5700XT（<a href="https://www.mydrivers.com/zhuanti/tianti/gpu/index.html">显卡性能天梯图</a>），功耗却比 RX 5700XT 更低，价格也只贵了两三百元左右，这就是电子产品技术的进步吧，新出的产品性能比老产品强，功耗还要比老产品低。</p>
<p>至于为什么不选择更好的 RX 6800，RX 6800XT，RX 6900XT 的原因（6700系列目前不支持黑苹果），一个是由于价格原因，这几张显卡都不是 1k+ 能够拿得下来的。第二是由于本人对显卡的需求也不是那么高，RX 6600XT 在 1k 分辨率下也能无压力的运行。甚至在 2k 分辨率下也可以流畅运行满足大部分需求。搭配 4k，5k 显示器日常使用也完全没有问题，iMac 搭配的显卡 RX 5700XT 性能差不多就是配置的 5k 显示器，日常使用肯定没问题，当然如果你想要这张显卡搭配 4k 及以上分辨率显示器在 Windows 下愉快玩大型3A游戏，那可能还是有点强卡所难了，要么降低游戏的分辨率，要么直接上最顶级的 RX 6900XT&#x2F;6950XT。</p>
<h2 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h2><p>硬盘部分不是我这篇文章的重点，大部分硬盘都是没问题的，只有某些 nvme 硬盘无法安装，推荐看一下 <a href="https://hpglw.com/cdc6109c.html">这篇文章</a>。本人选择的前段时间性价比很高的宏碁掠夺者 GM7000 2T 带独立缓存，对于开发者来说应该是特别适合的。实测安装黑苹果没有问题。</p>
<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>本人选择的是金百达银爵 16g * 2 3200 Mhz DDR4。搭配后面的主板开启 XMP 之后轻轻松松上到 3600 Mhz。虽然我也不甚了解现在越来越高的内存频率有什么特别大的实际作用。。。</p>
<h2 id="主板"><a href="#主板" class="headerlink" title="主板"></a>主板</h2><p>已经上到 i9 处理器了，主板毫无疑问推荐 Z 系列主板。Intel CPU 和主板搭配有个规律，就是 CPU 代数和主板芯片组有一个 6 的差距，比如：</p>
<ul>
<li>10 代 i9，那么搭配的主板芯片组应该是 Z490，但其实大部分 Z490 芯片组更新 BIOS 之后也能安装 11 代 CPU。</li>
<li>11 代 i9，那么搭配的主板芯片组应该是 Z590，Z590 芯片组可以安装 10 代和 11 代的 CPU。</li>
<li>12 代 i9，推荐搭配的主板芯片组是 Z690，大部分 Z690 芯片组更新 BIOS 也能安装 13 代 CPU。</li>
<li>13 代 i9，推荐搭配的主板芯片组是 Z790</li>
</ul>
<p>大概这样理解是没有问题的，只是有一些主板的兼容性好一点，多兼容几代 CPU，其实关键的地方在于 CPU 的针脚是否发生变化。主板个人选择的是某爱国嘉的 Z590M GAMING X，选择 MATX 主板的原因是不想要那么大的机箱。但是目前这款主板已经不好买到了，二手市场也几乎见不到几块了，不在乎机箱尺寸的可以选择常规 ATX 大小主板 Z590 GAMING X，这款市面上还是有不少在售卖的。</p>
<h2 id="CPU散热器"><a href="#CPU散热器" class="headerlink" title="CPU散热器"></a>CPU散热器</h2><p>CPU散热器的选择大体上分为两种，风冷和水冷。本人并不喜欢和信任水冷所以优先考虑的是风冷，11900KF 这种 11 代顶级 CPU 在满载的时候的发热量巨大，原本考虑的是利民风冷之王 FC140 ，无奈在准备购买的时候听客服说，这款产品会挡住 Z590M GAMING X 这款主板的内存，无法考证客服的说法。但按客服的推荐，选择了一款新出的利民 PS120 综合比较下来散热不输 FC140 ，尺寸也较小一圈不挡内存。</p>
<p>遗憾的是，经过实测这款散热器即使换上了台达的 12cm 3000 转暴力风扇也无法让 11900KF 不降频通过烤机测试。不过这是在开启了 AVX512 指令集的情况下。实测关闭了 AVX512 指令集之后，可以不降频通过烤机测试，温度在 80 多度左右。说实话我也一直想尝试搞懂这个 AVX512 指令集的实际作用，奈何太专业了，没搞明白。所以如果你不介意的话，关闭它之后 PS120 完全可以压制住 11900KF 这个 CPU。</p>
<p>但如果你实在介意买了这颗 CPU ，还不能完全使用它的功能，还要关闭这个虽然不知道有什么实际用途的 AVX512 指令集。那么还是建议上顶级的 240 水冷，或者 360 水冷吧。由于我机箱的限制，最多只能上到 240 水冷。不过目前并没有换的打算，因为我实在想不到除了烤机测试，还有哪些场景下能够让 CPU 满载运行很长时间。实在有这个需求了，关掉 AVX512 指令集在 PS120 的压制下也能长期满载运行。</p>
<h2 id="电源"><a href="#电源" class="headerlink" title="电源"></a>电源</h2><p>电源的选择最重要的是功率。根据你的 CPU 和 GPU 的搭配选择适合的功率，不然你的电脑可能连开机都成问题。一开始本人并不是特别了解，随便看到几篇抖音说 RX 6600XT 显卡搭配 600W 电源就行了。于是一开始买了个 600W 的长城 V6 600W 金牌全模组电源，结果在装机的时候常常发生显示器点不亮的情况，有时候重新开机几次又能点亮，有时候开机多次也无法点亮。甚至一度怀疑是显卡，或者主板的问题去了。。。后来在 <a href="https://seasonic.com/wattage-calculator">SEASONIC<em>海韵电源</em></a> 和 <a href="https://www.msi.cn/power-supply-calculator">MSI 微星</a> 的官网找到了电源功率计算器这个工具，计算下来才发现，我的配置 i9 11900KF + RX 6600XT 最低要求的电源功率也要 650W ，推荐上 700W 及以上功率的电源更好，这样可以应对以后配件升级的情况。至于其他的什么电容啊，80PLUS认证，模组化啊，本人倒觉得不是那么必要，功率才是必须要选择对的。由于本人并没有后期升级的打算，于是就换成了长城的 V7 700W 金牌全模组电源。</p>
<h2 id="机箱"><a href="#机箱" class="headerlink" title="机箱"></a>机箱</h2><p>机箱之前说过，本人不喜欢特别大的机箱，电脑的发展历史，就是越做越小的一段历史。现在的商家为了把产品卖出更高的价格，往往高配置的电脑喜欢搭配巨大的机箱。。。本人真的是接受不了。所以选择了一块 mATX 主板，那么机箱自然也是选择搭配 mATX 主板的小机箱。本人选择的是旅行者，机箱上方附带一个把手，可以很方便的一只手提起来。机箱不自带风扇，本人额外购买了两把台达 12cm 3000转静音温控风扇，只要 ¥17 元人民币1把。真的是物美价廉，风量比太多所谓的品牌风扇大多了。</p>
<h1 id="安装-Hackintosh"><a href="#安装-Hackintosh" class="headerlink" title="安装 Hackintosh"></a>安装 Hackintosh</h1><p>硬件都选配好了，接下来就是安装系统了。如果你选择的是 10 代酷睿 CPU，那么按照 OpenCore 官方文档的步骤来进行黑苹果安装，会十分的顺利，因为 OpenCore 目前对 10 代及以内的 CPU 的文档都特别详细。10 代之后的 CPU 有一些官方文档没有明确写明的地方需要自己摸索。</p>
<p>安装黑苹果的步骤，概括的来说，跟安装 window 没有太大区别，多了一个自己配置 EFI 文件的步骤。</p>
<h2 id="1-将-U-盘制作成系统安装盘"><a href="#1-将-U-盘制作成系统安装盘" class="headerlink" title="1. 将 U 盘制作成系统安装盘"></a>1. 将 U 盘制作成系统安装盘</h2><p>制作 U 盘系统安装盘的方式多种多样，这里我只讲诉我自己的使用过的方式，就是在 MacOS 上制作。其他的方式自己参考 <a href="https://dortania.github.io/OpenCore-Install-Guide/installer-guide/">OpenCore文档</a>。</p>
<h3 id="1-1-下载-macOS-安装程序"><a href="#1-1-下载-macOS-安装程序" class="headerlink" title="1.1 下载 macOS 安装程序"></a>1.1 下载 macOS 安装程序</h3><p>使用 App Store 搜索你想要安装的 Mac OS 系统，下面以 macOS Ventura 为例。</p>
<p><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/4af03ee077ece3249a40d34b6003ff43c1809189/20231019/01.png" alt="image.png"></p>
<p>点击获取就可以等待下载完成了。。。下载完成之后可以在启动台中看到，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/4af03ee077ece3249a40d34b6003ff43c1809189/20231019/02.png" alt="Xnip2023-10-18_14-58-49.png"></p>
<p>在等待下载的过程中，可以先执行下一步格式化 U 盘。</p>
<h3 id="1-2-格式化-U-盘"><a href="#1-2-格式化-U-盘" class="headerlink" title="1.2 格式化 U 盘"></a>1.2 格式化 U 盘</h3><p>U 盘大小建议至少是 16G 以上的。<br><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/4af03ee077ece3249a40d34b6003ff43c1809189/20231019/03.png" alt="image.png"></p>
<p>然后点击右上角的抹掉，之后按照下图的选择进行抹掉操作。</p>
<p><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/4af03ee077ece3249a40d34b6003ff43c1809189/20231019/04.png" alt="Xnip2023-10-18_16-52-01.png"></p>
<p>这里的名称一定要记住，后面还要用到的。我的建议是改成 OpenCoreUSB，当然这个无所谓，只要记得后面要用到就行。</p>
<h3 id="1-3-将-U-盘制作成系统安装盘"><a href="#1-3-将-U-盘制作成系统安装盘" class="headerlink" title="1.3 将 U 盘制作成系统安装盘"></a>1.3 将 U 盘制作成系统安装盘</h3><p>等到 macOS 安装程序下载好了之后，也即是在 1.1 中的第二张图片那样，在启动台中能看到安装 macOS Ventura 了。打开系统自带的终端app，输入以下指令（友情提示，太长的指令可以输入前几个字母之后按 TAB 键自动补全）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo /Applications/Install\ macOS\ Ventura.app/Contents/Resources/createinstallmedia --volume /Volumes/OpenCoreUSB</span><br></pre></td></tr></table></figure>
<p>输入电脑开机密码之后，再输入 y 按回车确认。安装时间有点慢，取决于你的 U 盘读写速度。如下图所示</p>
<p><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/4af03ee077ece3249a40d34b6003ff43c1809189/20231019/05.png" alt="Xnip2023-10-18_17-33-34.png"></p>
<p>跟上面结果一样就表示你的U盘系统安装盘制作好了</p>
<h2 id="2-配置-EFI-文件夹"><a href="#2-配置-EFI-文件夹" class="headerlink" title="2. 配置 EFI 文件夹"></a>2. 配置 EFI 文件夹</h2><p>安装黑苹果的步骤当中，最麻烦的就是这一步了。很多人会去网上搜索跟自己配置相同的人分享出来的 EFI 文件。但是实际上往往很难搜到完全相同的配置，或者即使是完全相同的配置依然是无法成功安装黑苹果。所以还是推荐照着 OpenCore 官方文档的步骤一步步自己动手配置 EFI 文件最靠谱。我这里会大概讲一下我自己配置的过程，具体的很多细节可以查阅官方文档中。</p>
<h3 id="2-1-下载-OpenCore-最新的版本"><a href="#2-1-下载-OpenCore-最新的版本" class="headerlink" title="2.1 下载 OpenCore 最新的版本"></a>2.1 下载 OpenCore <a href="https://github.com/acidanthera/OpenCorePkg/releases/">最新的版本</a></h3><p>这里会有 Debug 和 Release 两个版本，虽然官方推荐第一次使用选择 Debug 版本，但是我个人的经验来看还是建议直接选择 Release 版本，因为只要是按照教程一步步来的，基本不会出现问题，而就算你使用 Debug 版本出现了报错，也基本上看不懂任何一点报错的代码。。。太抽象了，反正我的确是用过 Debug 版本也遇到无法安装的情况，结果就是完全看不懂一点报错信息，也搜不到任何相关的资料。反而是认认真真照着教程又重新配置了几遍，才成功安装上的，最后还要回过头将所有 Debug 版本文件替换为 Release 版本。</p>
<p>我们将要使用的 EFI 文件夹：</p>
<p><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/4af03ee077ece3249a40d34b6003ff43c1809189/20231019/06.png" alt="image.png"></p>
<h3 id="2-2-挂载-U-盘上的-EFI-分区"><a href="#2-2-挂载-U-盘上的-EFI-分区" class="headerlink" title="2.2 挂载 U 盘上的 EFI 分区"></a>2.2 挂载 U 盘上的 EFI 分区</h3><p>在前面格式化 U 盘的过程中，我们选择的格式化方案会在 U 盘上自动创建一个隐藏的没有挂载到系统的 EFI 分区，现在需要将这个分区挂载到系统上，以便我们操作这个分区。挂载的方式有很多种</p>
<ul>
<li>有通过终端纯命令行的方式 <a href="https://github.com/corpnewt/MountEFI">MountEFI</a>。</li>
<li>也有通过使用一个 app 的图形化的方式 <a href="https://mackie100projects.altervista.org/download-opencore-Configurator/">OpenCore Configurator</a>。</li>
</ul>
<p>以下是使用 OpenCore Configurator 的截图。</p>
<p><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/4af03ee077ece3249a40d34b6003ff43c1809189/20231019/07.png" alt="image.png"></p>
<p>挂载之后就可以看到 U 盘的隐藏 EFI 分区了。然后将上一步中下载的 EFI 文件夹复制到这个 EFI 分区中。注意 EFI 分区下有一个 EFI 文件夹不要搞糊涂了。</p>
<h3 id="2-3-添加文件到各个子文件中"><a href="#2-3-添加文件到各个子文件中" class="headerlink" title="2.3 添加文件到各个子文件中"></a>2.3 添加文件到各个子文件中</h3><p>从现在开始，要确保我们所有的操作都是对 U 盘 EFI 分区的 EFI 文件夹进行操作。现在，先简单认识一下 EFI 文件夹里的子文件夹：</p>
<p><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/4af03ee077ece3249a40d34b6003ff43c1809189/20231019/08.png" alt="image.png"></p>
<ul>
<li><p>ACPI：说实话，这个文件夹我一直没有完全搞明白，翻译的内容，英文的缩写太多了，只知道这里面的内容大概跟 CPU 架构和电源管理等内容相关，官方文档只讲到了 10 代酷睿，后面的 11，12，13 以及刚出的 14 代酷睿并不在官方文档中，但我从其他资料中看到，10 代之后的酷睿 CPU 都可以按照 10 代酷睿的那样配置。所以按照我的配置，我们需要以下三个文件：</p>
<p>  <img src="https://raw.githubusercontent.com/masterKing/markDownPictures/4af03ee077ece3249a40d34b6003ff43c1809189/20231019/09.png" alt="image.png"></p>
<ul>
<li><a href="https://github.com/dortania/Getting-Started-With-ACPI/blob/master/extra-files/compiled/SSDT-AWAC.aml">SSDT-AWAC.aml</a></li>
<li><a href="https://github.com/dortania/Getting-Started-With-ACPI/blob/master/extra-files/compiled/SSDT-EC-USBX-DESKTOP.aml">SSDT-EC-USBX-DESKTOP.aml</a> </li>
<li><a href="https://github.com/dortania/Getting-Started-With-ACPI/blob/master/extra-files/compiled/SSDT-PLUG-DRTNIA.aml">SSDT-PLUG-DRTNIA.aml</a></li>
</ul>
</li>
<li><p>Drivers：固件驱动程序是 OpenCore 在 UEFI 环境中使用的驱动程序。大部分情况下我们只需要两个文件</p>
<p>  <img src="https://raw.githubusercontent.com/masterKing/markDownPictures/4af03ee077ece3249a40d34b6003ff43c1809189/20231019/10.png" alt="image.png"></p>
<ul>
<li><a href="https://github.com/acidanthera/OcBinaryData/blob/master/Drivers/HfsPlus.efi">HfsPlus.efi</a></li>
<li><a href="https://github.com/acidanthera/OpenCorePkg/releases">OpenRuntime.efi</a></li>
</ul>
<p>  虽然下载的 OpenCore 自带的 Drivers 里面会有很多文件，其中也包括上面这些文件，但我个人还是建议删掉自带的所有 efi 文件，点击上面的链接自己下载。因为自带的文件有些名字都改了，搞的人不知道该怎么处理。</p>
</li>
<li><p>Kexts：kext 是一个内核扩展，您可以将其视为 macOS 的驱动程序。大多数 kext 都可以在 <a href="https://dortania.github.io/builds/">构建存储库</a> 中找到已编译好的。每次有新提交时都会编译此处的 Kext。对于我的配置，需要以下这些文件</p>
<p>  <img src="https://raw.githubusercontent.com/masterKing/markDownPictures/4af03ee077ece3249a40d34b6003ff43c1809189/20231019/11.png" alt="image.png"></p>
<ul>
<li><a href="https://dortania.github.io/builds/?product=Lilu&viewall=true">Lilu.kext</a> 用于修补许多处理器的补丁，也是很多其他内核扩展的基础。</li>
<li><a href="https://github.com/acidanthera/VirtualSMC/releaseshttps://github.com/acidanthera/VirtualSMC/releases">SMCProcessor.kext</a> 用于监控 Intel CPU 温度</li>
<li><a href="https://github.com/ChefKissInc/RadeonSensor/releases">SMCRadeonGPU.kext</a> 用于监控 GPU 温度</li>
<li><a href="https://github.com/ChefKissInc/RadeonSensor/releases">RadeonSensor.kext</a> 还有一个 RadeonGadget 是一个 app 用于在右上角显示 GPU 温度的，需要搭配当前内核扩展使用，所以并不需要放在 Kexts 下。</li>
<li><a href="https://github.com/acidanthera/VirtualSMC/releaseshttps://github.com/acidanthera/VirtualSMC/releases">SMCSuperIO.kext</a> 这个和 SMCProcessor.kext 在一块</li>
<li><a href="https://dortania.github.io/builds/?product=WhateverGreen&viewall=true">WhateverGreen.kext</a> 显卡驱动，可以从构建存储库中下载最新版本。</li>
<li><a href="https://dortania.github.io/builds/?product=AppleALC&viewall=true">AppleeAlc.kext</a> 声卡驱动，还需要在配置文件中添加一个配置。在官方文档上可以看到。</li>
<li><a href="https://www.insanelymac.com/forum/files/file/1004-lucyrtl8125ethernet/">LucyRTL8125Ethernet.kext</a> 有线网卡驱动</li>
<li><a href="https://github.com/USBToolBox/kext/releases">USBToolBox.kext</a> 用于修复 USB 端口连接的</li>
<li>UTBMap.kext 这个扩展需要借助这个<a href="https://github.com/USBToolBox/tool/releases">工具</a>自己制作自己的。</li>
<li><a href="https://github.com/acidanthera/NVMeFix/releases">NVMeFix.kext</a> 用于修复非 Apple NVMe 上的电源管理和初始化</li>
<li><a href="https://github.com/acidanthera/RestrictEvents/releases">RestrictEvents.kext</a> 这个对我来说主要是为了修复在模仿使用 MacPro7,1 机型的时候，右上角会弹出“内存模块配置错误”的问题的。<!--但是我使用了一段时间后才发现，右上角有一个小的矩形区域无法点击的bug，不知道是不是它导致的。其实不要这个扩展也没什么问题，要么换成 iMacPro1.1 机型就不会有这个提示，要么不在乎提示，每次启动后出现的时候点击关闭就好了。--></li>
</ul>
</li>
<li><p>Resources：这里主要是美化 OpenCore 启动时的外观界面的，如果不配置就使用纯字母的形式显示，配置了会有图标，好看一点，就像白苹果里那样显示。感兴趣的可以去官网搜索自行配置。不影响安装。</p>
</li>
<li><p>Tools：工具类的文件，可以放在这里，不过不懂如何使用的也没什么必要放了，毕竟也不影响安装。</p>
</li>
</ul>
<p>这里我并没有添加无线网卡蓝牙相关的驱动，因为我没有 macOS 上能驱动的无线网卡，如果有这个需要打算购置的话可以查看 <a href="https://dortania.github.io/Wireless-Buyers-Guide/">无线网卡购买指南</a>。</p>
<h3 id="2-4-配置-config-plist-文件"><a href="#2-4-配置-config-plist-文件" class="headerlink" title="2.4 配置 config.plist 文件"></a>2.4 配置 config.plist 文件</h3><p>plist 文件对于 iOS 开发者来说并不陌生，对其他开发者来说可以理解成一种特殊的 XML 文件。上一步添加需要的文件麻烦，这一步则可能是最麻烦的了。需要按照 <a href="https://dortania.github.io/OpenCore-Install-Guide/config.plist/comet-lake.html">官方文档</a> 仔细比对每个需要的键。先从下载的 OpenCore 文件夹中找到 Sample.plist 文件，然后复制到 U 上 EFI 分区的 OC 文件夹下并重命名为 config.plist。</p>
<p><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/4af03ee077ece3249a40d34b6003ff43c1809189/20231019/12.png" alt="image.png"></p>
<p>虽然可以直接通过 Xcode 对 config.plist 进行编辑，不过由于大多数人对这个文件的修改都不熟悉，不知道哪些能不能删，如何修改，所以还是建议使用一些专门的工具进行编辑，就比如我们之前挂载 EFI 分区使用到的 <a href="https://mackie100projects.altervista.org/download-opencore-Configurator/">OpenCore Configurator</a>。这个 plist 文件主要的工作其实就是对当前文件夹下的其他文件，建立一个关联，当然还有它本身自带一个配置需要修改。</p>
<p>绝大部分的配置，官方文档都写的很清楚了，我不再重复，只有以下几点，官方文档没有写明的：</p>
<ol>
<li><p>Kernel -&gt; Emulate<br> 也就是仿冒 CPU。 对于 10 代酷睿之后的 CPU 都需要配置这个键。其实这个配置可以在 OpenCore 下载的文档里可以找到。Rocket Lake 就是 11 代酷睿的 CPU 代号</p>
<p> <img src="https://raw.githubusercontent.com/masterKing/markDownPictures/4af03ee077ece3249a40d34b6003ff43c1809189/20231019/13.png" alt="image.png"></p>
<p> 在 OpenCore Configurator 中的设置如下：</p>
<p> <img src="https://raw.githubusercontent.com/masterKing/markDownPictures/4af03ee077ece3249a40d34b6003ff43c1809189/20231019/14.png" alt="image.png"></p>
</li>
<li><p>如何使用 OpenCore Configurator。用它打开你 OC 文件夹下的 config.plist 可能会有一些默认的配置，使用右下角的 - 号全部删除。点击快照&#x2F;浏览会自动添加对应的文件夹下的文件。修改完成后记得保存，最后可以用 Xcode 或预览查看刚刚的修改是否真的保存了。</p>
</li>
</ol>
<p>如果你有足够的耐心，照着官方的文档，一步步完成了所有应该的配置。那么恭喜🎉你可以进入下一步，安装系统了</p>
<h2 id="3-安装系统"><a href="#3-安装系统" class="headerlink" title="3. 安装系统"></a>3. 安装系统</h2><h3 id="3-1-调整主板-BIOS"><a href="#3-1-调整主板-BIOS" class="headerlink" title="3.1 调整主板 BIOS"></a>3.1 调整主板 BIOS</h3><p>在正式开始安装之前，还需要对主板的 BIOS 进行一些设置。<a href="https://dortania.github.io/OpenCore-Install-Guide/config.plist/comet-lake.html#cleaning-up">官网</a> 和 <a href="https://apple.sqlsec.com/3-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/3-1/">国光</a> 的教程都很全面了，我这里只讲一下自己的主板 z590m gaming x 有的一些设置。这里我已经将 BIOS 更新到最新的 F8 版本了，在技嘉官网下载并更新最新版本的 <a href="https://www.gigabyte.com/Motherboard/Z590M-GAMING-X-rev-10/support#support-dl-bios">BIOS</a> ，这一步可能不是必须的。因为即使是最新的版本，依然有很多设置没有出现在 BIOS 中。以下是我这个主板的一些 BIOS 设置。</p>
<h4 id="禁用"><a href="#禁用" class="headerlink" title="禁用"></a>禁用</h4><ul>
<li>Fast Boot 这个有，在 Boot 选项下</li>
<li>Secure Boot 这个有，在 Boot 选项下</li>
<li>Serial&#x2F;COM Port 有，在 Settings -&gt; IO Ports -&gt; Super IO Configuration 下</li>
<li>Parallel Port 没找到</li>
<li>VT-d 有，Favorites 下就有，同样出现在 Settings -&gt; Miscellaneous 下</li>
<li>Compatibility Support Module (CSM) 有，在 Boot 下</li>
<li>Thunderbolt 没找到</li>
<li>Intel SGX 没找到</li>
<li>Intel Platform Trust 有，在 Setting -&gt; Miscellaneous 下</li>
<li>CFG Lock (MSR 0xE2 write protection) 有，在 Boot 下</li>
</ul>
<h4 id="开启"><a href="#开启" class="headerlink" title="开启"></a>开启</h4><ul>
<li>VT-x 没找到</li>
<li>Above 4G Decoding 有，在 Settings -&gt; IO Ports 下</li>
<li>Hyper-Threading 有，在 Tweaker -&gt; Advanced CPU Setings 下</li>
<li>Execute Disable Bit 没找到</li>
<li>EHCI&#x2F;XHCI Hand-off 有，在 Settings -&gt; IO Ports -&gt; USB Configuration 下</li>
<li>OS type: Windows 8.1&#x2F;10 UEFI Mode (some motherboards may require “Other OS” instead) 没有一样的，但是将 Boot 下的 Windows 10 Features 设置为 Other OS 了</li>
<li>DVMT Pre-Allocated(iGPU Memory): 64MB or higher 没找到，对于11900KF不带核显的 CPU 应该是没有这个设置的。</li>
<li>SATA Mode: AHCI 有，在 Settings -&gt; IO Ports -&gt; SATA And RST Configuration 下</li>
</ul>
<h3 id="3-2-开始安装"><a href="#3-2-开始安装" class="headerlink" title="3.2 开始安装"></a>3.2 开始安装</h3><p>终于来到了这激动人心的安装步骤。确保 U 盘插入主板后面的 USB3 插口上，我试过插在机箱面板的插口上会有些问题，开机按 F12 选择 U 盘启动。就会进入到 OpenCore 的选择页面，选择 Install macOS Ventura (external) ，进入后先选择磁盘工具格式化硬盘，选择 APFS 格式和 GUID 分区图方案。完成之后，退出磁盘工具，选择安装 macOS Ventura 接下来的操作就是按照提示一步步操作了，中间会重启多次，直到进入选择语言界面，那么恭喜你，你做到了！</p>
<h1 id="实测"><a href="#实测" class="headerlink" title="实测"></a>实测</h1><p>安装完后看看关于本机，和 Geekbench 的信息</p>
<p><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/4af03ee077ece3249a40d34b6003ff43c1809189/20231019/15.png" alt="image.png"></p>
<p>先上一下 Geekbench 5 的跑分。</p>
<p><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/4af03ee077ece3249a40d34b6003ff43c1809189/20231019/16.png" alt="image.png"></p>
<p>可能很多人并不知道，这个跑分的水平在哪里。所以我找了几款 Mac 机型的跑分作为对比。</p>
<ol>
<li><p>同为 MacPro7,1 型号的白苹果，在今年 6 月 5 号刚停产。搭配的是 Intel Xeon 处理器。选用28核的这款作为对比。可以看到 11900KF 的单核性能远超这款配置。多核性能由于 11900KF 只有 8 个核心，的确比不上 28 核心的 Xeon，但也有一个不错的分数。但是考虑到这款配置的 MacPro 的售价 RMB 103,379 。这点多核心性能的差距简直不值一提。</p>
<p> <img src="https://raw.githubusercontent.com/masterKing/markDownPictures/4af03ee077ece3249a40d34b6003ff43c1809189/20231019/17.png" alt="image.png"></p>
<p> 如果选用同样是 8 个核心的 Xeon 处理器那款 MacPro7,1 则无论是单核性能还是多核性能都会被 11900KF 吊打。恐怖的是 8 核心的这款 MacPro 7,1 售价也高达 RMB 51,999。对比我自己配置的这台 5000 块都不到的 11900KF 真的是太香了。</p>
</li>
<li><p>最新款的 MacPro14,8 搭载的是 Apple 自研的 M2 Ultra 芯片。M2 芯片分为 M2，M2 Pro，M2 Max，M2 Ultra，性能依次上升。11900 KF 的性能介于 M2 和 M2 Pro 之间。再考虑到 M2 芯片的最便宜的机型 MacBookAir 最低也要 1w 以上。自己配的 11900KF 还是还是很香的，只是没有上面那么香😄罢了。M2 芯片作为 2022 年的产品的确还是要比 2021 年上市的 11900KF 性能强劲，而且功耗更低。当然，如果一定要用 Intel 来对比 M 芯片，可能依然是 13900KS 更加强劲。但用 13900KS 性价比就没有 11900KF 那么高了。</p>
<p> <img src="https://raw.githubusercontent.com/masterKing/markDownPictures/4af03ee077ece3249a40d34b6003ff43c1809189/20231019/18.png" alt="image.png"></p>
</li>
</ol>
<p>说完了跑分上面的测试，说说自己实际的体验吧。用 ghidra 分析同一份 MachO 文件的耗时，老电脑依旧是好几个小时以至于我都没有测完就放弃了，而新电脑也用了快 1 个小时。这可能是由于 ghidra 为了通用性跨多个平台都能使用，所以并没有完全利用每个平台的完整性能，导致都比较慢吧。</p>
<p>用 hopper 分析同一份 MachO 文件的耗时，hopper 在分析完之后会给出后台分析的耗时，新电脑只有 7 分钟左右，老电脑分析了接近 30 分钟，提升还是很明显的。免费的 hopper 每次只有 30 分钟的体验时间，以前每次分析完，就到时间了，多难受。。。</p>
<p>显卡方面的测试，由于我目前并没有剪辑，制图方面的需求，所以就没有测试了。。。</p>
<p>编译了一个以前非常耗时的 Xcode 项目对比，也快了许多。总的来说，性能提升非常的明显。自己组装台式电脑安装黑苹果真的是太香了，趁着现在黑苹果所剩不多的几年，有需要的人可以赶紧上车了。</p>
]]></content>
      <categories>
        <category>黑苹果</category>
      </categories>
      <tags>
        <tag>黑苹果</tag>
        <tag>Hackintosh</tag>
      </tags>
  </entry>
  <entry>
    <title>Error Domain=NSURLErrorDomain Code=-999 已取消</title>
    <url>/2018/04/03/Error-Domain-NSURLErrorDomain-Code-999-%E5%B7%B2%E5%8F%96%E6%B6%88/</url>
    <content><![CDATA[<p>今天遇到这么一个问题,在使用SDWebimage设置UIImageView的图片的时候,发现这个图片<br><code>http://img4.imgtn.bdimg.com/it/u=132600321,3123081067&amp;fm=27&amp;gp=0.jpg</code>怎么也设置不成功,后来调试一看发现<img src="https://raw.githubusercontent.com/masterKing/markDownPictures/master/Snip20180403_4.png">说是什么已取消,我是一脸懵逼啊,谁TM取消了啊???百思不得其解之后网上搜了一下;<br>嘿,还有人写了个总结<img src="https://raw.githubusercontent.com/masterKing/markDownPictures/master/Snip20180403_5.png"></p>
<p>然而看了上面的总结后发现貌似都没有关系…所以说这个总结也并不全面…后来想想用浏览器打开这个图片试试看,发现浏览器上能正常打开;这下我估计是请求图片的请求头有问题了;于是我将浏览器的请求头和从APP发出的请求头都列出来了;如下<br><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/master/Snip20180403_1.png"></p>
<p><em>浏览器上的请求头</em></p>
<p><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/master/Snip20180403_2.png"></p>
<p><em>使用Charles抓取APP发出的请求头</em></p>
<p>其实一下子也看不出什么东西出来,那就先从都有的请求头开始试吧,再将APP发出的请求头的User-Agent设置之后发现能够设置成功了…那么问题就可以这么解释了,这个图片所在的服务器会对请求的User-Agent进行判断,具体判断规则是怎样的那我就不得而知了;如果不符合它的规则那么就会请求失败,在上图Charles抓包的响应里面可以看到一段403 Forbidden的html代码,而在APP中,就是报的<code>Error Domain=NSURLErrorDomain Code=-999 &quot;已取消&quot;</code>的错误<br><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/master/Snip20180403_6.png"></p>
<p>其实吧,这个问题根本不重要,因为实际我根本不可能使用这个URL;重要的是解决问题的思路,你得学会一套方法去解决问题,而不是学会解决这个问题…</p>
]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Cycript</title>
    <url>/2024/10/27/Cycript/</url>
    <content><![CDATA[<h1 id="什么是-Cycript"><a href="#什么是-Cycript" class="headerlink" title="什么是 Cycript"></a>什么是 Cycript</h1><p>Cycript 是一种用于 iOS 操作系统的脚本语言，同时也是该语言的解释器（一般来说不需要编译的脚本语言都会提供它对应的解释器，比如 Python、JavaScript、Ruby、PHP 等），Cycript 是 JavaScript，Objective-C++ 等语言的混合物这意味着它能理解 JavaScript，Objective-C++ 甚至是 Objective-C 语法，但是需要注意的是 Cycript 主要支持 JavaScript 的语法，对前端开发人员比较友好，而由于 Swift 吸收了 JavaScript 等其他各种语言的优点，所以 Cycript 中也能看到 Swift 的影子，Cycript 对 Objective-C 语法并不是完全支持，比如 Objective-C 创建一个 UIView 的代码是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UIView *view = [[UIView alloc] init];</span><br></pre></td></tr></table></figure>

<p>而在 Cycript 中，&#x3D; 号后面的部分可以识别，而前面的部分不支持，需要使用 JavaScript 的语法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var view = [[UIView alloc] init]</span><br></pre></td></tr></table></figure>

<p>作者最初设计的目的好像就是希望通过 JavaScript 学习使用 Cocoa&#x2F;UIKit 。</p>
<p>Cycript 同时还是一个可交互的控制台工具。主要用于在运行时与 iOS 应用程序远程交互、调试和分析。它允许开发人员以一种动态的方式与 iOS 应用程序进行通信，甚至可以修改其行为。这一点对比 lldb 来说更加灵活，lldb 调试时总是需要中断当前调试的进程，当然 lldb 有它的优势是可以下断点调试，可以手动砸壳 APP，是苹果的亲儿子等等优势。</p>
<p>Cycript 在越狱设备上广泛使用，越狱 iOS 安装 cycript 工具之后可以在越狱 iOS 上直接调试大部分 APP。在非越狱的设备上也是可以使用的，虽然一般在非越狱开发都会使用苹果 Xcode 提供的 lldb 调试，cycript 提供了一个 cycript.framework 库可以用来集成到 APP 中实现非越狱环境下的远程（通过 IP 地址和端口号）调试，这一点就非常酷炫了，想想在非越狱环境下你在远程调试分析一个 APP。有些人认为 Cycript 只能用于界面分析。。。其实 Cycript 远比大多数人想象的要强大…</p>
<p>cycript 的源码位于 <a href="https://git.saurik.com/cycript.git">https://git.saurik.com/cycript.git</a> 感兴趣的同学们可以下载下来看看。</p>
<p>Cycript 的主要特点包括：</p>
<ol>
<li><p><strong>动态注入和交互：</strong> Cycript 可以将脚本注入到运行中的应用程序进程中，从而允许开发人员在应用程序的上下文中执行代码。这使得开发人员可以检查应用程序的内部状态、调用其方法并进行交互。</p>
</li>
<li><p><strong>访问对象和类：</strong> Cycript 允许开发人员直接访问运行中的对象和类的属性、方法和成员变量。这对于调试和分析应用程序非常有用，尤其是当源代码不可用或者难以访问时。</p>
</li>
<li><p><strong>修改应用程序行为：</strong> 使用 Cycript，开发人员可以在运行时修改应用程序的行为，例如重定义方法、改变变量值等。这使得开发人员可以实时测试和验证不同的应用程序行为。</p>
</li>
<li><p><strong>探索界面元素：</strong> Cycript 还可以用于查找和探索应用程序的界面元素（例如视图和控件），以便更好地了解应用程序的界面层次结构和布局。</p>
</li>
</ol>
<h1 id="非越狱环境使用-cycript"><a href="#非越狱环境使用-cycript" class="headerlink" title="非越狱环境使用 cycript"></a>非越狱环境使用 cycript</h1><p>在非越狱环境下使用有两个前提条件</p>
<ul>
<li>Cycript.framework 将这个框架集成到你的 iOS 项目中。</li>
<li>cycript 终端命令行工具。在 MacOS 的终端运行这个工具，加上 IP 地址和端口就能和 iOS 项目建立联系，实现调试探索 APP 了。</li>
</ul>
<h2 id="iOS-项目集成-Cycript-framework"><a href="#iOS-项目集成-Cycript-framework" class="headerlink" title="iOS 项目集成 Cycript.framework"></a>iOS 项目集成 Cycript.framework</h2><p>从官网 <a href="http://www.cycript.org/">http://www.cycript.org/</a> 下载最新版本的 cycript 可能无法直接使用，会报一些库找不到的错误，没关系我们一步步解决。本人使用的是 MacOS ventura 13.5 的系统，进入下载文件夹后解压刚刚下载好的 cycript_0.9.594.zip 压缩包后如下图所示：</p>
<p><img src="5d087a97d00a42d992bc0ee0082bf942~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"></p>
<p>其中 Cycript.ios 里面就有我们需要的 Cycript.framework 文件。黑色的 cycript 就是我们需要的终端命令行工具。先将 Cycript.framework 集成到我们的 iOS 项目中，我这里新建了一个 CycriptDemo 的空工程。</p>
<p><img src="d32b77ce2d2d43d797261dc7c2cfd036~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"></p>
<p>Cycript.framework 集成成功之后，我们在 APP 启动的时候添加一点代码，如下图：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;AppDelegate.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;Cycript/Cycript.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AppDelegate</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AppDelegate</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="type">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</span><br><span class="line">    <span class="comment">// Override point for customization after application launch.</span></span><br><span class="line">    CYListenServer(<span class="number">3335</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>这里填写的端口号，只要是可用的端口号就都可以。可用的端口范围取决于您的操作系统和网络设置。通常情况下，TCP&#x2F;IP 协议定义的端口号范围是从 0 到 65535。然而，其中一些端口已经被标准协议用于特定的服务（例如，端口 80 用于 HTTP，端口 443 用于 HTTPS 等），因此不是所有的端口都可以随意使用。</p>
<p>通常情况下，非特权用户（普通用户）可以使用的端口号范围是从 1024 到 49151，而特权用户（如管理员或超级用户）可以使用从 0 到 1023 的端口号。</p>
<p>现在，运行 CycriptDemo 将 APP 安装到未越狱的 iPhone 上。不出意外应该会遇到以下报错</p>
<p><img src="f3c93ab5caf7421eaf931148a2e1f7b2~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"></p>
<p>让人感到有点莫名其妙，不过开发过程中有报错并不可怕，按照报错的提示去解决就好了，可怕的是没有任何提示而又没有按照预期的运行这才是最可怕的，根本无从下手解决。在做安全防护的时候也是如此，不要给出任何明显的提示或者报错，这样会让攻击者更容易就找到破解的办法。</p>
<p>回到之前解压的 cycript_0.9.594 目录中，在 Cycript.lib 目录下存在 libcycript.db 文件，将它拖进项目中就可以解决。</p>
<p><img src="4a5430071b9d4819a57fc505b1728485~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"></p>
<p>到这里 iOS 端的准备工作就差不多做好了。。。</p>
<h2 id="解决-cycript-命令行工具依赖库问题"><a href="#解决-cycript-命令行工具依赖库问题" class="headerlink" title="解决 cycript 命令行工具依赖库问题"></a>解决 cycript 命令行工具依赖库问题</h2><p>下一步我们需要解决 cycript 终端命令行工具的依赖库找不到的问题，让 cycript 成功运行起来。首先打开终端进入到刚刚解压的 cycript_0.9.594 文件夹，输入 <code>./cycript</code> 执行在我的环境下给出如下报错：</p>
<p><img src="754d10ee59f64fd490c8d83144604021~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"></p>
<p>意思就是找不到 Python.framework 库，这是由于 MacOS 在版本 macOS 11.0（Big Sur）中正式移除了预装的 Python 2.7。cycript 在 2016 年之后就停止更新了，在无法更新 cycript 的依赖库的情况下（或许可以通过反汇编修改二进制，但目前看没有这个必要），我们只能想办法在上述指定位置安装 Python 库，也不一定要使用指定 Python2.7 版本，因为在软件开发领域新版本的程序一般都会向下兼容老版本的程序，就是说如果一个软件的依赖库找不到了，可以使用较新的版本的库直接替换，如果用更老的版本就可能出现问题，这个做开发的应该都知道但没想到。</p>
<p>所以我准备将我电脑上已经安装好的 Python3.11 版本的 Python.framework 复制到到上述路径并修改一下版本号就行了。如果你的电脑上本来就没有安装 Python 库，那就使用 <code>brew install python</code> 安装好了。安装好之后同样找到 Python.framework 复制到上述路径。</p>
<p>使用 <code>brew list python</code> 发现我的电脑已安装的 Python 版本</p>
<p><img src="17e012e78782425d8ff0fe2291f1946e~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="Xnip2023-08-18_21-53-47.png"></p>
<p>由于 MacOS 的 SIP 限制，&#x2F;System&#x2F;… 路径是只读的，在 MacOS 13.5 上即使禁用了 SIP 也依旧无法修改。也许有办法只是目前我还没有找到可以修改的方法。<br>好在给出的错误提示，指出了多个路径都找不到同一个库，于是猜测到这么多路径中只要有一个路径存在指定库就可以，其中最后一个路径 &#x2F;Library 目录是可以修改的，于是尝试将 Python3.11 版本的 Python.framework 复制到 &#x2F;Library&#x2F;Framework&#x2F; 目录下，并将 Versions 目录下的 3.11 重命名为 2.7 之后就解决了上面这个报错。最终结果就是按照上面报错的最后一个路径 <code>/Library/Frameworks/Python.framework/Versions/2.7/Python</code> 配置好一个 Python 可执行文件。</p>
<p>继续输入 <code>./cycript</code> 看是否能运行成功。没有那么顺利，在我的环境下，又报了以下错误：</p>
<p><img src="680174bfc5e94845a56322e7cb17577d~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"></p>
<p>解决方式跟刚刚类似，找到电脑上已安装的 libruby.dylib 库，将它复制到了 <code>/usr/local/lib/</code> 目录下，这个 <code>/usr/local/</code> 目录一般就是用来存放用户级别的库的。如果你的电脑上没有安装 ruby 库，那就先安装好，再复制到 <code>/usr/local/lib/</code> 目录下，并重命名为 <code>libruby.2.0.0.dylib</code>。</p>
<p>继续输入 <code>./cycript</code> 发现进入了交互环境了，表示依赖库都配置好了，如果你还有其他报错，继续按照刚刚的方法解决就行了。</p>
<p><img src="3f6beead8c5648efb1ce1d5d1e539a3c~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"></p>
<h2 id="开始远程调试"><a href="#开始远程调试" class="headerlink" title="开始远程调试"></a>开始远程调试</h2><p>接下来找到 iPhone 所在网络的 IP 地址，确认 iPhone 和 Mac 需要在同一局域网内。打开刚刚安装的 CycriptDemo ，然后在 Mac 终端输入 <code>./cycript -r IP:端口号</code> 如果不出意外（除非你新建的项目 bundleIdentifier 是之前使用过的，并且之前该 APP 已经成功安装运行并允许使用无线局域网），那么大概率是无法连接成功的，会报以下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*** _syscall(connect(socket_, info-&gt;ai_addr, info-&gt;ai_addrlen)):../Console.cpp(306):CYSocketRemote [errno=60]</span><br></pre></td></tr></table></figure>

<p>这是 socket 连接返回的错误码，错误码 “errno&#x3D;60” 对应的是 “ETIMEDOUT”，这是基于一般的网络编程经验和标准的错误码定义而来。这是因为我们新创建工程并没有获取到使用无线局域网络的用户授权，也就是很多 APP 第一次启动访问网络时会弹出的授权提示，如下图所示。所以在我们新创建的 CycriptDemo 工程中还需要添加一些访问网络的代码，让系统自动弹出这个授权弹窗并选择无线局域网与蜂窝网络、或者仅限无线局域网都可以。如果你不小心点击了不允许，可以在 iOS 的设置 APP 中找到你当前的 APP -&gt; 无线数据，重新选择。</p>
<p align="center"><img src="b82b620ff8304730881adfcb4796f159~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="IMG_0106.PNG" width="30%"></p>

<p>添加如下访问网络连接的代码再次启动时就会弹出上面的授权弹窗。如果你是集成到已经获取了授权的项目中，可以不用添加这行代码。获取到用户授权之后可以删除掉。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</span><br><span class="line">    <span class="comment">// Override point for customization after application launch.</span></span><br><span class="line">    [[[<span class="built_in">NSURLSession</span> sharedSession] dataTaskWithRequest:[<span class="built_in">NSURLRequest</span> requestWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@&quot;https://httpbin.org/get&quot;</span>]]] resume];</span><br><span class="line">    CYListenServer(<span class="number">3335</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成功获取使用无线局域网授权之后，我们再次尝试连接，应该可以看到以下结果：</p>
<p><img src="f0f3c160f2c44b3a80889a1592ec35a5~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"></p>
<p>有时候还有可能会遇到以下错误</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">*** _syscall(connect(socket_, info-&gt;ai_addr, info-&gt;ai_addrlen)):../Console.cpp(306):CYSocketRemote [errno=61]</span><br></pre></td></tr></table></figure>

<p>这个一般是 APP 还没有启动成功，服务还没开始运行，或者在后台被杀掉导致的。确保 APP 在前台并且启动完成之后再连接就好了。</p>
<p>连接成功进入交互环境后可以输入 <code>UIApp</code> 获取应用实例对象，这是 Cycript 对 iOS 中的 <code>[UIApplication sharedApplication]</code> 的包装，也可以直接输入 <code>[UIApplication sharedApplication]</code> 获取，就像在 lldb 调试那样。退出交互环境使用键盘快捷键 control + D ,或者输入 <code>?exit</code> 。</p>
<p><img src="d6407aa127834c71937f55b80ccef1ba~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"></p>
<h1 id="越狱环境下使用-cycript"><a href="#越狱环境下使用-cycript" class="headerlink" title="越狱环境下使用 cycript"></a>越狱环境下使用 cycript</h1><p>在越狱环境下使用 cycript 就没有那么麻烦了，只需要在 Cydia 或者 Sileo 中搜索并安装 Cycript 。安装好之后通过 ssh 远程连接到越狱 iPhone 之后，直接可以输入 <code>cycript -p pid或进程名称</code> 就可以开始调试了。可以使用 <code>ps -A | grep app</code> 获取到 pid 或者 进程名称。如果提示没有 <code>ps</code> 这个命令，需要安装 adv-cmds 工具，不过一般在安装 Cycript 的时候应该已经一并安装了。</p>
<p>关于如何通过 ssh 远程连接到越狱 iPhone 可以看我之前的文章 <a href="https://juejin.cn/post/7262982452768145465">从 Mac 远程登录到 iPhone</a>。</p>
<p>在越狱设备上输入 <code>ps -A | grep app</code> 获取 pid 或 进程名称的结果如下：</p>
<p><img src="177b4189f70b4a058ed8ac4b0743ebe6~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"></p>
<p>前面的数字就是 pid ，路径最后就是进程名称。我们以红框中的 SpringBoard APP 为例，附加到这个 APP 中。这个 APP 就是我们 iOS 用户最熟悉的陌生人了，天天看的最多，用的最多的手机桌面。输入以下代码会看到手机桌面显示出了弹窗</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">iPhone:~ root# cycript -p SpringBoard</span><br><span class="line">cy# var alertvc = [UIAlertController alertControllerWithTitle:@<span class="string">&quot;title&quot;</span> message:@<span class="string">&quot;message&quot;</span> preferredStyle:1]</span><br><span class="line"><span class="comment">#&quot;&lt;UIAlertController: 0x101b66a00&gt;&quot;</span></span><br><span class="line">cy# [alertvc addAction:[UIAlertAction actionWithTitle:@<span class="string">&quot;confirm&quot;</span> style:0 handler:nil]]</span><br><span class="line">cy# [alertvc addAction:[UIAlertAction actionWithTitle:@<span class="string">&quot;cancel&quot;</span> style:1 handler:nil]]</span><br><span class="line">cy# [UIApp.keyWindow.rootViewController presentViewController:alertvc animated:YES completion:nil]</span><br><span class="line">cy# </span><br></pre></td></tr></table></figure>

<p>iPhone 桌面显示如图：</p>
<p align="center"><img src="08b3e4241c4b40f08027510a234cfc8d~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="IMG_0004.PNG" width="50%"></p>

<h1 id="cycript-基础用法"><a href="#cycript-基础用法" class="headerlink" title="cycript 基础用法"></a>cycript 基础用法</h1><p>好了，到这里不论你是在非越狱环境还是在越狱环境应该都可以进入 Cycript 与 APP 的交互环境了。现在先了解一下 Cycript 提供的一些基础用法，就用刚刚在非越狱环境使用 Cycript 中创建的 CycriptDemo 进行演示。打开手机上的 CycriptDemo APP，然后打开终端 cd 进入 cycript_0.9.594 目录下并进行连接（有需要可以配置成环境变量方便全局使用），如下图：</p>
<p><img src="7d2dedd81252481882bf270369a201d7~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"></p>
<h2 id="创建最简单的-UIView-并添加到-keyWindow-上"><a href="#创建最简单的-UIView-并添加到-keyWindow-上" class="headerlink" title="创建最简单的 UIView 并添加到 keyWindow 上"></a>创建最简单的 UIView 并添加到 keyWindow 上</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cy# var rect = new (struct CGRect)</span><br><span class="line">&amp;&#123;origin:&#123;x:new Number&#123;&#125;,y:new Number&#123;&#125;&#125;,size:&#123;width:new Number&#123;&#125;,height:new Number&#123;&#125;&#125;&#125;</span><br><span class="line">cy# rect-&gt;origin.x = 50</span><br><span class="line">50</span><br><span class="line">cy# rect-&gt;origin.y = 100</span><br><span class="line">100</span><br><span class="line">cy# rect-&gt;size.width = 100</span><br><span class="line">100</span><br><span class="line">cy# rect-&gt;size.height = 60</span><br><span class="line">60</span><br><span class="line">cy# var greenView = [[UIView alloc] initWithFrame:*rect]</span><br><span class="line"><span class="comment">#&quot;&lt;UIView: 0x10450a690; frame = (50 100; 100 60); layer = &lt;CALayer: 0x282ddbcc0&gt;&gt;&quot;</span></span><br><span class="line">cy# greenView.backgroundColor = [UIColor greenColor]</span><br><span class="line"><span class="comment">#&quot;UIExtendedSRGBColorSpace 0 1 0 1&quot;</span></span><br><span class="line">cy# [UIApp.keyWindow addSubview:greenView]</span><br></pre></td></tr></table></figure>
<p>APP 的显示如图：</p>
<p align="center"><img src="dada50269c8546cfb5dfe1c6f5d6d672~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="IMG_0110.PNG" width="30%"></p>

<p>可以看到，Cycript 中的 CGRect 用起来并不是特别方便，而且默认也没有提供对 CGRectMake() 函数的支持，这一点我也不是太明白。不过我们可以定义自己的函数，实现同样的功能。代码如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cy# <span class="keyword">function</span> CGPointMake(x, y) &#123; <span class="built_in">return</span> &#123;0 : x, 1 : y&#125; &#125;</span><br><span class="line">cy# <span class="keyword">function</span> CGSizeMake(w, h) &#123; <span class="built_in">return</span> &#123;0 : w, 1 : h&#125; &#125;</span><br><span class="line">cy# <span class="keyword">function</span> CGRectMake(x, y, w, h) &#123; <span class="built_in">return</span> &#123;0 : CGPointMake(x, y), 1 : CGSizeMake(w, h) &#125; &#125;</span><br><span class="line">cy# var rect2 = CGRectMake(160, 100, 100, 60)</span><br><span class="line">&#123;0:&#123;0:160,1:100&#125;,1:&#123;0:100,1:60&#125;&#125;</span><br><span class="line">cy# var redView = [[UIView alloc] initWithFrame:rect2]</span><br><span class="line"><span class="comment">#&quot;&lt;UIView: 0x107610070; frame = (160 100; 100 60); layer = &lt;CALayer: 0x282de62e0&gt;&gt;&quot;</span></span><br><span class="line">cy# redView.backgroundColor = [UIColor redColor]</span><br><span class="line"><span class="comment">#&quot;UIExtendedSRGBColorSpace 1 0 0 1&quot;</span></span><br><span class="line">cy# [UIApp.keyWindow addSubview:redView]</span><br></pre></td></tr></table></figure>

<p>我们定义了 CGPointMake(),CGSizeMake(),CGRectMake() 三个函数实现了类似的功能。并使用 CGRectMake() 创建了一个新的红色视图 <code>redView</code> 并添加到了 <code>keyWindow</code> 上。</p>
<p>APP 显示如下：</p>
<p align="center"><img src="1dba7f979c874e118ab93d948e241b1f~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="IMG_0111.PNG" width="30%"></p>

<h2 id="内存地址"><a href="#内存地址" class="headerlink" title="#内存地址"></a>#内存地址</h2><p>使用 #内存地址 获取内存地址所在的对象。比如我们刚刚创建的 redView ，这是我们创建的变量所以可以直接使用 redView 变量获取对象，但是在平时调试过程中我们很少会创建变量，而是通过打印输出很多对象的内存地址，通过 # 符号获取这个对象。使用 #内存地址 修改我们刚刚创建的 redView 的大小的代码如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#0x107610070.backgroundColor = [UIColor orangeColor]</span></span><br></pre></td></tr></table></figure>

<p>可以看到我们的 redView 的背景色被修改为橙色了。</p>
<h2 id="对象"><a href="#对象" class="headerlink" title="*对象"></a>*对象</h2><p>使用 * 号加对象，会打印出对象的所有成员变量名和对应的值。以我们刚刚修改的 redView 为例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cy# *#0x107610070</span><br><span class="line">&#123;isa:UIView,_responderFlags:@error,_constraintsExceptingSubviewAutoresizingConstraints:null,_cachedTraitCollection:#<span class="string">&quot;&lt;UITraitCollection: 0x2814e8620; UserInterfaceIdiom = Phone, DisplayScale = 3, DisplayGamut = P3, HorizontalSizeClass = Compact, VerticalSizeClass = Regular, UserInterfaceStyle = Light, UserInterfaceLayoutDirection = LTR, ForceTouchCapability = Available, PreferredContentSizeCategory = XS, AccessibilityContrast = Normal, UserInterfaceLevel = Base&gt;&quot;</span>,_animationInfo:null,_layer:#<span class="string">&quot;&lt;CALayer: 0x282de62e0&gt;&quot;</span>,_layerRetained:null,_gestureRecognizers:null,_window:#<span class="string">&quot;&lt;UIWindow: 0x1045057e0; frame = (0 0; 414 896); gestureRecognizers = &lt;NSArray: 0x28238d770&gt;; layer = &lt;UIWindowLayer: 0x28238d860&gt;&gt;&quot;</span>,_subviewCache:@[],_viewDelegate:null,_cachedScreenScale:new Number&#123;&#125;,_layoutEngineWidth:new Number&#123;&#125;,_viewFlags:@error,_unsatisfiableConstraintsLoggingSuspensionCount:0,_pseudo_id:8,_retainCount:new Number&#123;&#125;,_draggingSourceDelegate:null,_tintAdjustmentDimmingCount:0,_layoutSubviewsCount:0,_imminentLayoutSubviewsCount:0,_countOfFocusedAncestorTrackingViewsInSubtree:0,_layoutMarginsGuide:null,_minXVariable:null,_minYVariable:null,_boundsWidthVariable:null,_boundsHeightVariable:null,_layoutEngine:null,_stashedLayoutVariableObservations:null,_internalConstraints:null,_safeAreaLayoutGuide:null,_keyboardLayoutGuide:null,_readableContentGuide:null,__preferedContentsFormat:new Number&#123;&#125;,__lastNotifiedTraitCollection:#<span class="string">&quot;&lt;UITraitCollection: 0x2814e41c0; UserInterfaceIdiom = Phone, DisplayScale = 3, DisplayGamut = P3, HorizontalSizeClass = Compact, VerticalSizeClass = Regular, UserInterfaceStyle = Light, UserInterfaceLayoutDirection = LTR, ForceTouchCapability = Available, PreferredContentSizeCategory = XS, AccessibilityContrast = Normal, UserInterfaceLevel = Base&gt;&quot;</span>,__alignmentRectOriginCache:null,_rawLayoutMargins:&#123;top:new Number&#123;&#125;,left:new Number&#123;&#125;,bottom:new Number&#123;&#125;,right:new Number&#123;&#125;&#125;,_inferredLayoutMargins:&#123;top:new Number&#123;&#125;,left:new Number&#123;&#125;,bottom:new Number&#123;&#125;,right:new Number&#123;&#125;&#125;,_safeAreaInsets:&#123;top:new Number&#123;&#125;,left:new Number&#123;&#125;,bottom:new Number&#123;&#125;,right:new Number&#123;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="递归打印层级结构"><a href="#递归打印层级结构" class="headerlink" title="递归打印层级结构"></a>递归打印层级结构</h2><h3 id="递归打印视图层级结构"><a href="#递归打印视图层级结构" class="headerlink" title="递归打印视图层级结构"></a>递归打印视图层级结构</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cy# UIApp.keyWindow.recursiveDescription()</span><br><span class="line">@<span class="string">&quot;&lt;UIWindow: 0x1045057e0; frame = (0 0; 414 896); gestureRecognizers = &lt;NSArray: 0x28238d770&gt;; layer = &lt;UIWindowLayer: 0x28238d860&gt;&gt;\n   | &lt;UITransitionView: 0x1076068d0; frame = (0 0; 414 896); autoresize = W+H; layer = &lt;CALayer: 0x282ddd500&gt;&gt;\n   |    | &lt;UIDropShadowView: 0x102e07170; frame = (0 0; 414 896); autoresize = W+H; layer = &lt;CALayer: 0x282dc4900&gt;&gt;\n   |    |    | &lt;UIView: 0x107607070; frame = (0 0; 414 896); autoresize = W+H; layer = &lt;CALayer: 0x282ddd480&gt;&gt;\n   | &lt;UIView: 0x10450a690; frame = (50 100; 100 60); layer = &lt;CALayer: 0x282ddbcc0&gt;&gt;\n   | &lt;UIView: 0x107610070; frame = (160 100; 100 60); layer = &lt;CALayer: 0x282de62e0&gt;&gt;&quot;</span></span><br></pre></td></tr></table></figure>

<p>会发现打印的字符串中有很多 \n 符号并没有真正的换行。可以使用 <code>toString()</code> 函数让 \n 真正的换行</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cy# UIApp.keyWindow.recursiveDescription().toString()</span><br><span class="line">`&lt;UIWindow: 0x1045057e0; frame = (0 0; 414 896); gestureRecognizers = &lt;NSArray: 0x28238d770&gt;; layer = &lt;UIWindowLayer: 0x28238d860&gt;&gt;</span><br><span class="line">   | &lt;UITransitionView: 0x1076068d0; frame = (0 0; 414 896); autoresize = W+H; layer = &lt;CALayer: 0x282ddd500&gt;&gt;</span><br><span class="line">   |    | &lt;UIDropShadowView: 0x102e07170; frame = (0 0; 414 896); autoresize = W+H; layer = &lt;CALayer: 0x282dc4900&gt;&gt;</span><br><span class="line">   |    |    | &lt;UIView: 0x107607070; frame = (0 0; 414 896); autoresize = W+H; layer = &lt;CALayer: 0x282ddd480&gt;&gt;</span><br><span class="line">   | &lt;UIView: 0x10450a690; frame = (50 100; 100 60); layer = &lt;CALayer: 0x282ddbcc0&gt;&gt;</span><br><span class="line">   | &lt;UIView: 0x107610070; frame = (160 100; 100 60); layer = &lt;CALayer: 0x282de62e0&gt;&gt;`</span><br></pre></td></tr></table></figure>

<p>这样看起来就清晰多了。</p>
<h3 id="递归打印根控制器的层级结构"><a href="#递归打印根控制器的层级结构" class="headerlink" title="递归打印根控制器的层级结构"></a>递归打印根控制器的层级结构</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cy# UIApp.keyWindow.rootViewController._printHierarchy().toString()</span><br><span class="line"><span class="string">&quot;&lt;ViewController 0x1045049f0&gt;, state: appeared, view: &lt;UIView 0x107607070&gt;&quot;</span></span><br></pre></td></tr></table></figure>

<p>由于我们的 CycriptDemo APP 中只有一个根视图控制器，所以只能看到这样的打印。</p>
<h3 id="递归打印自动布局信息"><a href="#递归打印自动布局信息" class="headerlink" title="递归打印自动布局信息"></a>递归打印自动布局信息</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cy# UIApp.keyWindow._autolayoutTrace().toString()</span><br><span class="line">`</span><br><span class="line">UIWindow:0x1045057e0</span><br><span class="line">|   UITransitionView:0x1076068d0</span><br><span class="line">|   |   UIDropShadowView:0x102e07170</span><br><span class="line">|   |   |   UIView:0x107607070</span><br><span class="line">|   UIView:0x10450a690</span><br><span class="line">|   UIView:0x107610070</span><br><span class="line"></span><br><span class="line">Legend:</span><br><span class="line">\t* - is laid out with auto layout</span><br><span class="line">\t+ - is laid out manually, but is represented <span class="keyword">in</span> the layout engine because translatesAutoresizingMaskIntoConstraints = YES</span><br><span class="line">\t\u2022 - layout engine host`</span><br></pre></td></tr></table></figure>
<p>这里出现了一些不该显示的 \t 字符，猜测可能是解析字符串的时候出了点问题，在打印对象的 <code>_ivarDescription</code> 和 <code>_methodDescription</code> 的时候也会出现。可惜 Cycript 的作者已经停止更新了。。。</p>
<h2 id="choose-查询类或其子类的实例对象"><a href="#choose-查询类或其子类的实例对象" class="headerlink" title="choose 查询类或其子类的实例对象"></a>choose 查询类或其子类的实例对象</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cy# choose(UIView)</span><br><span class="line">[#<span class="string">&quot;&lt;UIWindow: 0x1045057e0; frame = (0 0; 414 896); gestureRecognizers = &lt;NSArray: 0x28238d770&gt;; layer = &lt;UIWindowLayer: 0x28238d860&gt;&gt;&quot;</span>,#<span class="string">&quot;&lt;UIDimmingView: 0x1045065a0; frame = (0 0; 0 0); opaque = NO; gestureRecognizers = &lt;NSArray: 0x28238d230&gt;; layer = &lt;CALayer: 0x282dd9ea0&gt;&gt;&quot;</span>,#<span class="string">&quot;&lt;UIDimmingView: 0x1045070e0; frame = (0 0; 0 0); opaque = NO; gestureRecognizers = &lt;NSArray: 0x28238d1a0&gt;; layer = &lt;CALayer: 0x282dda100&gt;&gt;&quot;</span>,#<span class="string">&quot;&lt;UIView: 0x10450a690; frame = (50 100; 100 60); layer = &lt;CALayer: 0x282ddbcc0&gt;&gt;&quot;</span>,#<span class="string">&quot;&lt;UITransitionView: 0x1076068d0; frame = (0 0; 414 896); autoresize = W+H; layer = &lt;CALayer: 0x282ddd500&gt;&gt;&quot;</span>,#<span class="string">&quot;&lt;UIView: 0x107607070; frame = (0 0; 414 896); autoresize = W+H; layer = &lt;CALayer: 0x282ddd480&gt;&gt;&quot;</span>,#<span class="string">&quot;&lt;UIView: 0x107610070; frame = (160 100; 100 60); layer = &lt;CALayer: 0x282de62e0&gt;&gt;&quot;</span>,#<span class="string">&quot;&lt;UIDropShadowView: 0x102e07170; frame = (0 0; 414 896); autoresize = W+H; layer = &lt;CALayer: 0x282dc4900&gt;&gt;&quot;</span>]</span><br></pre></td></tr></table></figure>

<h2 id="tab-键自动补全代码"><a href="#tab-键自动补全代码" class="headerlink" title="tab 键自动补全代码"></a>tab 键自动补全代码</h2><p>在输入代码的时候，可以尝试使用 tab 键进行自动补全或者代码提示。在输入的代码足够分析出正确的完整代码的时候按一次 tab 键会自动补全，在输入的代码不足以分析出正确的代码的时候按两下 tab 键会给出所有可能得提示，在输入的代码完全不够解析的时候终端会有声音提醒，再多输入几个字符试试就好了。我们以对象的私有方法或成员变量（以下划线_开头）为例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cy# choose(UIView)</span><br><span class="line">[#<span class="string">&quot;&lt;UIWindow: 0x1045057e0; frame = (0 0; 414 896); gestureRecognizers = &lt;NSArray: 0x28238d770&gt;; layer = &lt;UIWindowLayer: 0x28238d860&gt;&gt;&quot;</span>,#<span class="string">&quot;&lt;UIDimmingView: 0x1045065a0; frame = (0 0; 0 0); opaque = NO; gestureRecognizers = &lt;NSArray: 0x28238d230&gt;; layer = &lt;CALayer: 0x282dd9ea0&gt;&gt;&quot;</span>,#<span class="string">&quot;&lt;UIDimmingView: 0x1045070e0; frame = (0 0; 0 0); opaque = NO; gestureRecognizers = &lt;NSArray: 0x28238d1a0&gt;; layer = &lt;CALayer: 0x282dda100&gt;&gt;&quot;</span>,#<span class="string">&quot;&lt;UIView: 0x10450a690; frame = (50 100; 100 60); layer = &lt;CALayer: 0x282ddbcc0&gt;&gt;&quot;</span>,#<span class="string">&quot;&lt;UITransitionView: 0x1076068d0; frame = (0 0; 414 896); autoresize = W+H; layer = &lt;CALayer: 0x282ddd500&gt;&gt;&quot;</span>,#<span class="string">&quot;&lt;UIView: 0x107607070; frame = (0 0; 414 896); autoresize = W+H; layer = &lt;CALayer: 0x282ddd480&gt;&gt;&quot;</span>,#<span class="string">&quot;&lt;UIView: 0x107610070; frame = (160 100; 100 60); layer = &lt;CALayer: 0x282de62e0&gt;&gt;&quot;</span>,#<span class="string">&quot;&lt;UIDropShadowView: 0x102e07170; frame = (0 0; 414 896); autoresize = W+H; layer = &lt;CALayer: 0x282dc4900&gt;&gt;&quot;</span>]</span><br><span class="line">cy# <span class="comment">#0x107610070._</span></span><br><span class="line">Display all 501 possibilities? (y or n)</span><br><span class="line">cy# <span class="comment">#0x107610070._lay</span></span><br><span class="line">_layer()                                           _layoutEngine                                      _layoutEngineRelativeAlignmentRectOriginIsValid()  _layoutRect()</span><br><span class="line">_layoutDebuggingIdentifier                         _layoutEngineCreateIfNecessary()                   _layoutHeightDependsOnWidth                        _layoutVariablesWithAmbiguousValue()</span><br><span class="line">_layoutDebuggingTitle()                            _layoutEngineHostConstraints()                     _layoutMarginsGuideIfExists()</span><br><span class="line">_layoutDescriptionIfDifferentFromDefault()         _layoutEngineIfAvailable()                         _layoutMarginsGuideIgnoresSystemMinimumMargins</span><br><span class="line">cy# <span class="comment">#0x107610070._lay</span></span><br></pre></td></tr></table></figure>

<p>首先使用 choose 查询 UIView 或其子类的实例对象。选取其中的一个 #0x107610070 ，输入 ._ 之后会出现提示显示所有 501 个可能的结果？输入 y 表示显示，n 不显示。501 个结果太多了，我选择不显示，继续输入 lay 之后按两下 tab 键由于数量不是很多于是直接将所有可能得结果都显示出来了。这个功能我只能说🐂🍺</p>
<h1 id="cycript-高级用法"><a href="#cycript-高级用法" class="headerlink" title="cycript 高级用法"></a>cycript 高级用法</h1><p>我们刚刚创建了几个变量和函数，这些变量和函数都的确处于进程的内存当中，但是当 APP 进程被杀掉重新启动的时候，我们创建的变量和函数就都会消失。如果我们需要在每次进入交互环境的时候，重新辛辛苦苦编写重复的函数代码那可就太折磨人了。</p>
<p>Cycript 作者早就想到了这样的情况，所以它支持从文件加载自己的脚本。首先编写好 Cycript 的 .cy 文件，我们 tool.cy 为例。.cy 文件使用的是 JavaScript 语法，所以没有相关背景知识的开发人员编写起来可能会感到很困难。没错，作者本人就是如此，为了实现了一个函数并让它按照预期运行就经受了一番痛苦的折磨。。。这里参考了 MJ 大神的一些<a href="https://github.com/CoderMJLee/mjcript">源码</a>，并对其中个人感觉不是很实用的进行了删减，对一些做了修改。同时对 @import 方式进行了优化，在 @import 的时候，会给出 .cy 文件中的一些关键信息，这样就不用去记忆一些变量和函数名。同时也省去了需要使用文件名.才能调用函数的麻烦（这里是参考了 AloneMonkey 大神的写法）。</p>
<h2 id="编写-cy-文件"><a href="#编写-cy-文件" class="headerlink" title="编写 .cy 文件"></a>编写 .cy 文件</h2><p>tool.cy 文件源码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params">tool</span>) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> t = tool.<span class="property">constants</span> = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="title class_">MJPointMake</span> = <span class="keyword">function</span>(<span class="params">x, y</span>) &#123; </span><br><span class="line">		<span class="keyword">return</span> &#123;<span class="number">0</span> : x, <span class="number">1</span> : y&#125;; </span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="title class_">MJSizeMake</span> = <span class="keyword">function</span>(<span class="params">w, h</span>) &#123; </span><br><span class="line">		<span class="keyword">return</span> &#123;<span class="number">0</span> : w, <span class="number">1</span> : h&#125;; </span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="title class_">MJRectMake</span> = <span class="keyword">function</span>(<span class="params">x, y, w, h</span>) &#123; </span><br><span class="line">		<span class="keyword">return</span> &#123;<span class="number">0</span> : <span class="title class_">MJPointMake</span>(x, y), <span class="number">1</span> : <span class="title class_">MJSizeMake</span>(w, h)&#125;; </span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回 bundleIdentifier</span></span><br><span class="line">	t.<span class="property">bundleId</span> = [[<span class="title class_">NSBundle</span> mainBundle] bundleIdentifier];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回安装包路径</span></span><br><span class="line">	t.<span class="property">bundlePath</span> = [[<span class="title class_">NSBundle</span> mainBundle] bundlePath];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> _MJFrontVc = <span class="keyword">function</span>(<span class="params">vc</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (vc.<span class="property">presentedViewController</span>) &#123;</span><br><span class="line">        	<span class="keyword">return</span> <span class="title function_">_MJFrontVc</span>(vc.<span class="property">presentedViewController</span>);</span><br><span class="line">	    &#125;<span class="keyword">else</span> <span class="keyword">if</span> ([vc <span class="attr">isKindOfClass</span>:[<span class="title class_">UITabBarController</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">	        <span class="keyword">return</span> <span class="title function_">_MJFrontVc</span>(vc.<span class="property">selectedViewController</span>);</span><br><span class="line">	    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([vc <span class="attr">isKindOfClass</span>:[<span class="title class_">UINavigationController</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">	        <span class="keyword">return</span> <span class="title function_">_MJFrontVc</span>(vc.<span class="property">visibleViewController</span>);</span><br><span class="line">	    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    	<span class="keyword">var</span> count = vc.<span class="property">childViewControllers</span>.<span class="property">count</span>;</span><br><span class="line">    		<span class="keyword">for</span> (<span class="keyword">var</span> i = count - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    			<span class="keyword">var</span> childVc = vc.<span class="property">childViewControllers</span>[i];</span><br><span class="line">    			<span class="keyword">if</span> (childVc &amp;&amp; childVc.<span class="property">view</span>.<span class="property">window</span>) &#123;</span><br><span class="line">    				vc = <span class="title function_">_MJFrontVc</span>(childVc);</span><br><span class="line">    				<span class="keyword">break</span>;</span><br><span class="line">    			&#125;</span><br><span class="line">    		&#125;</span><br><span class="line">	        <span class="keyword">return</span> vc;</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回最靠近用户的控制器</span></span><br><span class="line">	t.<span class="property">frontVc</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="title function_">_MJFrontVc</span>(<span class="title class_">UIApp</span>.<span class="property">keyWindow</span>.<span class="property">rootViewController</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="title class_">MJIsString</span> = <span class="keyword">function</span>(<span class="params">str</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">typeof</span> str == <span class="string">&#x27;string&#x27;</span> || str <span class="keyword">instanceof</span> <span class="title class_">String</span>;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> _MJClass = <span class="keyword">function</span>(<span class="params">className</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!className) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(missingParamStr);</span><br><span class="line">		<span class="keyword">if</span> (<span class="title class_">MJIsString</span>(className)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="title class_">NSClassFromString</span>(className);</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">if</span> (!className) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(invalidParamStr);</span><br><span class="line">		<span class="comment">// 对象或者类</span></span><br><span class="line">		<span class="keyword">return</span> className.<span class="title function_">class</span>();</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取 className 的所有子类，reg 正则过滤</span></span><br><span class="line">	t.<span class="property">subclassesWith</span> = <span class="keyword">function</span>(<span class="params">className, reg</span>) &#123;</span><br><span class="line">		className = <span class="title function_">_MJClass</span>(className);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> [c <span class="keyword">for</span> <span class="title function_">each</span> (c <span class="keyword">in</span> <span class="title class_">ObjectiveC</span>.<span class="property">classes</span>) </span><br><span class="line">		<span class="keyword">if</span> (c != className </span><br><span class="line">			&amp;&amp; <span class="title function_">class_getSuperclass</span>(c) </span><br><span class="line">			&amp;&amp; [c <span class="attr">isSubclassOfClass</span>:className] </span><br><span class="line">			&amp;&amp; (!reg || reg.<span class="title function_">test</span>(c)))</span><br><span class="line">			];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取按钮的 TouchUpInsideEvent 的 target 和 actions</span></span><br><span class="line">	t.<span class="property">touchUpInsideTargetAndActionWith</span> = <span class="keyword">function</span>(<span class="params">btn</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (![btn <span class="attr">isKindOfClass</span>:[<span class="title class_">UIControl</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;invalid parameter type,must be kind of UIControl class&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	    <span class="keyword">var</span> allTargets = [[btn allTargets] allObjects];</span><br><span class="line">    	<span class="keyword">var</span> dict = [<span class="title class_">NSMutableDictionary</span> dictionary];</span><br><span class="line">    	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; allTargets.<span class="property">count</span>; i++) &#123;</span><br><span class="line">    		<span class="keyword">var</span> actions = [btn <span class="attr">actionsForTarget</span>:allTargets[i] <span class="attr">forControlEvent</span>:<span class="title class_">UIControlEventTouchUpInside</span>];</span><br><span class="line">    		[dict <span class="attr">setValue</span>:actions <span class="attr">forKey</span>:[allTargets[i] description]];</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> dict;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> _MJGetMethods = <span class="keyword">function</span>(<span class="params">className, reg, clazz</span>) &#123;</span><br><span class="line">		className = <span class="title function_">_MJClass</span>(className);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> count = <span class="keyword">new</span> <span class="keyword">new</span> <span class="title class_">Type</span>(<span class="string">&#x27;I&#x27;</span>);</span><br><span class="line">		<span class="keyword">var</span> classObj = clazz ? className.<span class="property">constructor</span> : className;</span><br><span class="line">		<span class="keyword">var</span> methodList = <span class="title function_">class_copyMethodList</span>(classObj, count);</span><br><span class="line">		<span class="keyword">var</span> methodsArray = [];</span><br><span class="line">		<span class="keyword">var</span> methodNamesArray = [];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; *count; i++) &#123;</span><br><span class="line">			<span class="keyword">var</span> method = methodList[i];</span><br><span class="line">			<span class="keyword">var</span> selector = <span class="title function_">method_getName</span>(method);</span><br><span class="line">			<span class="keyword">var</span> name = <span class="title function_">sel_getName</span>(selector);</span><br><span class="line">			<span class="keyword">if</span> (reg &amp;&amp; !reg.<span class="title function_">test</span>(name)) <span class="keyword">continue</span>;</span><br><span class="line">			methodsArray.<span class="title function_">push</span>(&#123;</span><br><span class="line">				selector : selector, </span><br><span class="line">				type : <span class="title function_">method_getTypeEncoding</span>(method)</span><br><span class="line">			&#125;);</span><br><span class="line">			methodNamesArray.<span class="title function_">push</span>(name);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="title function_">free</span>(methodList);</span><br><span class="line">		<span class="keyword">return</span> [methodsArray, methodNamesArray];</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">var</span> _MJMethods = <span class="keyword">function</span>(<span class="params">className, reg, clazz</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="title function_">_MJGetMethods</span>(className, reg, clazz)[<span class="number">0</span>];</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 打印对象方法</span></span><br><span class="line">	t.<span class="property">instanceMethods</span> = <span class="keyword">function</span>(<span class="params">className, reg</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="title function_">_MJMethods</span>(className, reg);</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打印类方法</span></span><br><span class="line">	t.<span class="property">classMethods</span> = <span class="keyword">function</span>(<span class="params">className, reg</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="title function_">_MJMethods</span>(className, reg, <span class="literal">true</span>);</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打印响应者</span></span><br><span class="line">	t.<span class="property">rp</span> = <span class="keyword">function</span>(<span class="params">target</span>) &#123;</span><br><span class="line">		<span class="keyword">var</span> result = <span class="string">&quot;&quot;</span> + target.<span class="title function_">toString</span>();</span><br><span class="line">		<span class="keyword">while</span> (target.<span class="property">nextResponder</span>) &#123;</span><br><span class="line">			result += <span class="string">&quot;\n&quot;</span> + target.<span class="property">nextResponder</span>.<span class="title function_">toString</span>();</span><br><span class="line">			target = target.<span class="property">nextResponder</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> tool.<span class="property">constants</span>) &#123;</span><br><span class="line">		<span class="title class_">Cycript</span>.<span class="property">all</span>[k] = tool.<span class="property">constants</span>[k];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;)(<span class="built_in">exports</span>);</span><br></pre></td></tr></table></figure>

<h2 id="越狱环境下使用-cy-文件"><a href="#越狱环境下使用-cy-文件" class="headerlink" title="越狱环境下使用 .cy 文件"></a>越狱环境下使用 .cy 文件</h2><p>在越狱环境下，可以将编写好的 tool.cy 文件放到 <code>/usr/lib/cycript0.9/com/masterking</code> 目录下。这里的 masterking 是文件夹名，你可以自己创建一个文件夹换成你想要的名字。Cycript 成功附加到 APP 进程之后，使用以下命令就可以导入该文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cy# @import com.masterking.tool</span><br><span class="line">&#123;constants:&#123;bundleId:@<span class="string">&quot;com.masterking.CycriptDemo&quot;</span>,bundlePath:@<span class="string">&quot;/var/containers/Bundle/Application/85010A56-FF88-4EDE-A9CA-BA5C76638197/CycriptDemo.app&quot;</span>,frontVc:<span class="function"><span class="title">function</span></span> ()&#123;<span class="built_in">return</span> s(UIApp.keyWindow.rootViewController)&#125;,subclassesWith:<span class="keyword">function</span> (r,i)&#123;r=d(r);<span class="built_in">return</span> <span class="keyword">function</span>(n,t)&#123;var e;n=[];&#123;e=ObjectiveC.classes;<span class="keyword">for</span>(t <span class="keyword">in</span> e)&#123;t=e[t];<span class="keyword">if</span>(t!=r&amp;&amp;class_getSuperclass(t)&amp;&amp;objc_msgSend(t,<span class="string">&quot;isSubclassOfClass:&quot;</span>,r)&amp;&amp;(!i||i.test(t)))n.push(t)&#125;&#125;<span class="built_in">return</span> n&#125;()&#125;,touchUpInsideTargetAndActionWith:<span class="keyword">function</span> (r)&#123;var e,t,n,i;<span class="keyword">if</span>(!objc_msgSend(r,<span class="string">&quot;isKindOfClass:&quot;</span>,objc_msgSend(UIControl,<span class="string">&quot;class&quot;</span>)))&#123;throw new Error(<span class="string">&quot;invalid parameter type,must be kind of UIControl class&quot;</span>)&#125;i=objc_msgSend(objc_msgSend(r,<span class="string">&quot;allTargets&quot;</span>),<span class="string">&quot;allObjects&quot;</span>);n=objc_msgSend(NSMutableDictionary,<span class="string">&quot;dictionary&quot;</span>);<span class="keyword">for</span>(e=0;e&lt;i.count;e++)&#123;t=objc_msgSend(r,<span class="string">&quot;actionsForTarget:forControlEvent:&quot;</span>,i[e],UIControlEventTouchUpInside);objc_msgSend(n,<span class="string">&quot;setValue:forKey:&quot;</span>,t,objc_msgSend(i[e],<span class="string">&quot;description&quot;</span>))&#125;<span class="built_in">return</span> n&#125;,instanceMethods:<span class="keyword">function</span> (t,e)&#123;<span class="built_in">return</span> i(t,e)&#125;,classMethods:<span class="keyword">function</span> (t,e)&#123;<span class="built_in">return</span> i(t,e,!0)&#125;,rp:<span class="keyword">function</span> (t)&#123;var e;e=<span class="string">&quot;&quot;</span>+t.toString();<span class="keyword">while</span>(t.nextResponder)&#123;e+=<span class="string">&quot;\n&quot;</span>+t.nextResponder.toString();t=t.nextResponder&#125;<span class="built_in">return</span> e&#125;&#125;&#125;</span><br><span class="line">cy# frontVc()</span><br><span class="line"><span class="comment">#&quot;&lt;ViewController: 0x10f119400&gt;&quot;</span></span><br></pre></td></tr></table></figure>

<p>可以看到输出了 tool.cy 中的源码，这样不必要记忆函数名和变量名，写好了导入就可以直接使用，也不需要使用 tool.frontVc() 调用函数，直接 frontVc() 就可以调用，同时还可以使用 tab 键补全函数代码。</p>
<h2 id="非越狱环境下使用-cy-文件"><a href="#非越狱环境下使用-cy-文件" class="headerlink" title="非越狱环境下使用 .cy 文件"></a>非越狱环境下使用 .cy 文件</h2><h3 id="逆向开发的情况使用-cy-文件"><a href="#逆向开发的情况使用-cy-文件" class="headerlink" title="逆向开发的情况使用 .cy 文件"></a>逆向开发的情况使用 .cy 文件</h3><p>在非越狱环境下进行逆向开发，首先推荐的肯定是 AloneMonkey 的 <a href="https://github.com/AloneMonkey/MonkeyDev">MonkeyDev</a> 工具提供了 Xcode 工程模板，可以像正向开发那样方便的使用 Xcode 在未越狱环境进行逆向开发。由于也是很多年没有更新了，没有适配最近的几个 Xcode 版本导致可能无法成功安装。看到 Fork 里有人适配了 Xcode 13 ，使用 Xcode 13 的可以试试。由于我本人使用的是 Xcode 14.3.1 所以就没有尝试，由于之前的 Xcode 可以成功安装，于是我下载了旧版本的 Xcode 好像是 12.4。安装到了 Mac 13.5 上，会显示无法打开。不需要打开使用，直接运行 MonkeyDev 安装脚本根据提示安装，然后还是修改了 md-install 脚本之后，再升级到最新的 Xcode 版本经过一番折腾，终于算是用上了。</p>
<p><img src="4246583878e94515b9949784d0d5d9ce~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"></p>
<p>MonkeyApp 工程默认就集成了 cycript 库到项目中，经过我的观察好像不是使用的 Cycript.framework 的方式，但是也能通过 cycript 连接成功。使用自己的 .cy 文件的方式有两种，一种是使用 MDConfig.plist 配置文件，在其中添加自己的 .cy 文件配置。这个配置文件也很简单，需要一个 url 就行了，配置一个本地环境的 url 也可以。或者直接将 cy 代码复制到 content 中(这种我没试过，感兴趣的可以自己试试) 这两种方式不需要自己再手动 @import 导入 tool.cy 文件，非常省事。</p>
<p><img src="cf16fa5d3acb4cc982cd6b536b97f03d~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"></p>
<p>另一种就是手动将 tool.cy 文件拖进项目中。</p>
<p><img src="f411a3d535084fdba616bdfd5f167961~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"></p>
<p>然后再进入 cycript 交互环境的时候，手动 @import 导入一下，如下图：</p>
<p><img src="cb8b5096ea8a4e0e83ab321131a31f88~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"></p>
<h3 id="正向开发的情况使用-cy-文件"><a href="#正向开发的情况使用-cy-文件" class="headerlink" title="正向开发的情况使用 .cy 文件"></a>正向开发的情况使用 .cy 文件</h3><p>在非越狱环境正向开发的情况下，原以为可以将 tool.cy 文件打包进 APP 的安装包中之后就可以 @import 导入了。万万没有想到并没有这么简单，不确定是哪里出了问题，如果有知道的大神可以在评论区交流一下。会报以下错误：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cy# @import tool</span><br><span class="line">throw new TypeError&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>最关键的信息在{}里面没有显示。。。也没办法了</p>
<h1 id="cycript-实战"><a href="#cycript-实战" class="headerlink" title="cycript 实战"></a>cycript 实战</h1><p>能看到这里的人一定都是热爱学习的人，这里给大家准备了一个惊喜，使用 cycript 绕过某付费直播 APP 观看限制。为了防止有人说我打广告嫌疑和规避法律责任，这里不会明确是哪个 APP 并在此声明<strong>本文案例供技术交流，禁止用于商业及非法用途，如产生法律纠纷与本人无关。</strong>。</p>
<p>APP 图标大概长这样：</p>
<p align="center"><img src="47c8b94fb8c94609967e486c351a4001~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="Xnip2023-08-23_18-15-42.png"></p>

<p>下载好 APP 之后，进入 APP 的包里面，发现干净的很，分析一下原来是 Flutter 项目生成的 iOS APP。Flutter 项目也没关系，不管是什么技术，只要你需要兼容 iOS 平台，就绕不开 iOS 的技术栈 Cocoa touch 框架。</p>
<p align="center"><img src="6b877efc8b264d7ea6dcf4855c6f3580~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png" width="70%"></p>

<p>启动 APP，进入某个直播间发现有一个 30 秒的倒计时之后便出现了如下界面。</p>
<p align="center"><img src="d9b7a7ec1161497a9c1d643ce9cff150~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png" width="30%"></p>

<p>打开终端，使用 cycript 远程附加到 APP 上。递归打印出当前 APP 的界面层级结构：</p>
<p><img src="414b7f2551dc49c48e3f4a37438d17f9~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"></p>
<p>根据经验，推测绿框中的视图应该就是弹出来的视图，让它隐藏之后你就会看到你想要看的东西了😛。。。当然目前这种做法只不过是在内存中修改了视图的 hidden 属性，如果想要做到永久的修改 APP 的逻辑，还需要学习更多的内容，我会在接下来的时间里陆续更新内容，敬请期待。也欢迎感兴趣的开发者共同学习，一起交流。</p>
]]></content>
      <categories>
        <category>iOS 逆向与安全</category>
      </categories>
  </entry>
  <entry>
    <title>SDWebimage设置图片时URL不变，但图片改变的解决办法</title>
    <url>/2018/07/17/SDWebimage%E8%AE%BE%E7%BD%AE%E5%9B%BE%E7%89%87%E6%97%B6URL%E4%B8%8D%E5%8F%98%EF%BC%8C%E4%BD%86%E5%9B%BE%E7%89%87%E6%94%B9%E5%8F%98%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<p>本篇文章转载自<a href="https://blog.csdn.net/xumugui007/article/details/51605546">SDWebImage支持URL不变时更新图片内容</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SDWebImage在iOS项目中是一个很常用的开源库，而且众所周知的是，它是基于URL作为Key来实现图片缓存机制的。在90%左右的情况下，</span><br><span class="line">图片与URL是一一对应的，即使服务器修改了图片也会相应的变更URL。但是在少数情况下，服务器修改了图片后不会变更相应的URL，也就是</span><br><span class="line">说图片本身的内容变了然而它的URL没有变化，那么按照对SDWebImage的常规使用方法的话，客户端肯定更新不到同一URL对应到服务器已变</span><br><span class="line">更的图片内容。</span><br></pre></td></tr></table></figure>

<p>基于这一现象，我们来进行分析。</p>
<p>客户端第一次请求图片时，Charles抓包得知response header里有一个名为Last-Modified、数据是时间戳的键值对。</p>
<p>客户端第二次及以后请求图片时，通过Charles抓包发现，服务器返回304 not modified状态，说明服务器在接收客户端请求后通过某种判断逻辑得出结论：“客户端已缓存的图片与服务器图片都是最新的”，那么服务器如何判断的呢？</p>
<p>通过查阅HTTP协议相关的资料得知，与服务器返回的Last-Modified相对应的request header里可以加一个名为If-Modified-Since的key，value即是服务器回传的服务端图片最后被修改的时间，第一次图片请求时If-Modified-Since的值为空，第二次及以后的客户端请求会把服务器回传的Last-Modified值作为If-Modified-Since的值传给服务器，这样服务器每次接收到图片请求时就将If-Modified-Since与Last-Modified进行比较，如果客户端图片已陈旧那么返回状态码200、Last-Modified、图片内容，客户端存储Last-Modified和图片；如果客户端图片是最新的那么返回304 Not Modified、不会返回Last-Modified、图片内容。</p>
<p>关于服务器的比较逻辑，需要强调一下。</p>
<p>经查资料得知，Apache比较时是看If-Modified-Since之后有没有更新图片，Nginx比较时是看If-Modified-Since与Last-Modified是否相等，所以对于Apache服务器环境客户端每次都要严格的存储服务器回传的Last-Modified以便下次请求时作为If-Modified-Since的值传给服务器，对于Nginx服务器环境客户端不必存储服务器回传的Last-Modified，每次请求时只需将图片自身的fileModificationDate作为If-Modified-Since的值传服务器即可。在实际开发中，如果遇到明明传了If-Modified-Since、服务器图片也变更了、但是客户端却请求不到最新的图片的情况时，那么就需要查看一下服务器对这两个时间戳的比较逻辑。</p>
<p>那么，现在我们可以回到SDWebImage上来了。通过查看SDWebImageDownloader的源码得知，它开放了一个headersFilter的block，意在让开发者可以对所有图片请求追加一些额外的header，这正合我意。那么我们就可以在诸如AppDelegate didFinishLaunching的地方追加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SDWebImageDownloader *imgDownloader = SDWebImageManager.sharedManager.imageDownloader;</span><br><span class="line">imgDownloader.headersFilter  = ^NSDictionary *(NSURL *url, NSDictionary *headers) &#123;</span><br><span class="line"> </span><br><span class="line">    NSFileManager *fm = [[NSFileManager alloc] init];</span><br><span class="line">    NSString *imgKey = [SDWebImageManager.sharedManager cacheKeyForURL:url];</span><br><span class="line">    NSString *imgPath = [SDWebImageManager.sharedManager.imageCache defaultCachePathForKey:imgKey];</span><br><span class="line">    NSDictionary *fileAttr = [fm attributesOfItemAtPath:imgPath error:nil];</span><br><span class="line"> </span><br><span class="line">    NSMutableDictionary *mutableHeaders = [headers mutableCopy];</span><br><span class="line"> </span><br><span class="line">    NSDate *lastModifiedDate = nil;</span><br><span class="line"> </span><br><span class="line">    if (fileAttr.count &gt; 0) &#123;</span><br><span class="line">        if (fileAttr.count &gt; 0) &#123;</span><br><span class="line">            lastModifiedDate = (NSDate *)fileAttr[NSFileModificationDate];</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];</span><br><span class="line">    formatter.timeZone = [NSTimeZone timeZoneWithAbbreviation:@&quot;GMT&quot;];</span><br><span class="line">    formatter.locale = [[NSLocale alloc] initWithLocaleIdentifier:@&quot;en_US&quot;];</span><br><span class="line">    formatter.dateFormat = @&quot;EEE, dd MMM yyyy HH:mm:ss z&quot;;</span><br><span class="line"> </span><br><span class="line">    NSString *lastModifiedStr = [formatter stringFromDate:lastModifiedDate];</span><br><span class="line">    lastModifiedStr = lastModifiedStr.length &gt; 0 ? lastModifiedStr : @&quot;&quot;;</span><br><span class="line">    [mutableHeaders setValue:lastModifiedStr forKey:@&quot;If-Modified-Since&quot;];</span><br><span class="line"> </span><br><span class="line">    return mutableHeaders;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后，加载图片的地方以前怎么写还是怎么写，但别忘了Option是SDWebImageRefreshCached</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSURL *imgURL = [NSURL URLWithString:@&quot;http://handy-img-storage.b0.upaiyun.com/3.jpg&quot;];</span><br><span class="line">[[self imageView] sd_setImageWithURL:imgURL</span><br><span class="line">                    placeholderImage:nil</span><br><span class="line">                             options:SDWebImageRefreshCached];</span><br></pre></td></tr></table></figure>

<p>经测试，服务器只修改图片不变更URL的时候，客户端也可以更新到最新的图片。</p>
<p>从以上第一段代码内容可以看出我采用的是与ngix服务器比较逻辑对应的代码，BTW:我测试的服务器是又拍云，说明又拍云的比较逻辑是等与不等的关系判断，不是大小关系的判断。</p>
<p>这里顺便说一下，如果服务器的环境是类似于Apache的比较逻辑时，客户端可以把Last-Modified存放在图片的名称上(这需要修改SDWebImage源码，不建议)，或者用一个plist文件存放图片key名称与时间的对应关系(这个不用修改源码)。</p>
<p>OK，到此这次的主题已得到完美解决。</p>
]]></content>
      <tags>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 应用砸壳</title>
    <url>/2024/10/27/iOS-%E5%BA%94%E7%94%A8%E7%A0%B8%E5%A3%B3/</url>
    <content><![CDATA[<h1 id="什么是壳"><a href="#什么是壳" class="headerlink" title="什么是壳"></a>什么是壳</h1><p>在软件保护和安全领域，“壳”指的是利用特殊的算法对应用程序的二进制文件进行加密或包装的保护层，通常被称为 “加壳”。壳的作用是保护应用程序的代码，防止未经授权的访问、篡改和逆向工程。壳通常会在应用程序启动时将其解密到内存中，以便正常运行。</p>
<p>苹果会在应用发布到 App Store 时，对应用程序进行 DRM（数字版权管理）保护，这种保护即一种壳，目的是防止非法分发。所以从 App Store 下载的应用程序，我们无法使用 hopper，ghidra，ida 等逆向工具进行静态分析，也无法使用 class-dump 这样的工具导出头文件。需要对其进行解密也就是砸壳，也有人喜欢称脱壳之后，才能进行逆向分析。</p>
<p>iOS 应用加壳只有苹果公司内部自己能处理，所以我们只讨论砸壳的方式：</p>
<h1 id="砸壳的方式"><a href="#砸壳的方式" class="headerlink" title="砸壳的方式"></a>砸壳的方式</h1><ol>
<li><p><strong>静态砸壳或硬砸壳：</strong>就是在已经掌握和了解壳的加密算法和逻辑之后在不运行应用程序的情况下将应用程序的壳进行解密处理。静态砸壳的方法难度大，而且加密方发现应用被破解之后就可能会该用更高级和复杂的加密技术。</p>
</li>
<li><p><strong>动态砸壳：</strong>动态砸壳就是从运行在进程内存空间中的可执行文件镜像入手，将内存中的内容进行转储（dump）处理实现脱壳。这种方式实现起来相对简单且不必关心使用的是什么加密技术。</p>
</li>
</ol>
<p>iOS 砸壳大多采用动态砸壳的方式。</p>
<h1 id="查看-iOS-应用的壳状态"><a href="#查看-iOS-应用的壳状态" class="headerlink" title="查看 iOS 应用的壳状态"></a>查看 iOS 应用的壳状态</h1><p><code>LC_ENCRYPTION_INFO_64</code> 是 Mach-O 文件格式中的一个加载命令（load command），用于描述 64 位 Mach-O 文件的加密信息。该加载命令常见于 macOS 和 iOS 应用程序的可执行文件中，主要包含应用程序是否加密及其相关的加密信息。</p>
<h2 id="主要字段"><a href="#主要字段" class="headerlink" title="主要字段"></a>主要字段</h2><ul>
<li><strong>cryptoff</strong>：加密数据的偏移量，表示从文件的哪个位置开始加密数据。</li>
<li><strong>cryptsize</strong>：加密数据的大小，以字节为单位，指示被加密的范围。</li>
<li><strong>cryptid</strong>：加密标识符，用于表明数据是否被加密。值为 0 表示数据未加密；其他值表示数据已加密。</li>
</ul>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>在 iOS 应用中，<code>LC_ENCRYPTION_INFO_64</code> 常用于 <strong>FairPlay</strong> DRM（数字版权管理）保护。iOS 应用在上传到 App Store 时，苹果会对其进行加密保护，以防止未经授权的访问或修改。通过检查 <code>LC_ENCRYPTION_INFO_64</code> 的字段值，可以判断应用是否经过 DRM 加密保护。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>查看 <code>LC_ENCRYPTION_INFO_64</code> 信息有以下两种方式：</p>
<ol>
<li><strong>图形化工具：</strong>MachOView</li>
<li><strong>命令行工具：</strong>otool</li>
</ol>
<h3 id="MachOView"><a href="#MachOView" class="headerlink" title="MachOView"></a><a href="https://github.com/gdbinit/MachOView">MachOView</a></h3><p><strong>MachOView</strong> 是一款用于 macOS 的图形化工具，专门设计用于分析和查看 Mach-O 文件格式。Mach-O（Mach Object）是 macOS 和 iOS 操作系统使用的可执行文件格式，包含了二进制可执行文件、库文件、内核扩展等。</p>
<p>MachOView 提供了一个直观的界面，可以帮助开发者和逆向工程人员深入分析 Mach-O 文件的结构和内容。它展示了文件头、加载命令、段（segments）、节（sections）、符号表（symbol table）、动态符号、字符串表等各种信息。</p>
<h4 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h4><ul>
<li><strong>查看文件头</strong>：展示 Mach-O 文件的文件头信息，例如文件类型、CPU 架构等。</li>
<li><strong>加载命令</strong>：列出所有的加载命令，包括动态库依赖、入口点、数据段等。</li>
<li><strong>段和节</strong>：显示所有的段和节信息，并可以查看它们的详细内容。</li>
<li><strong>符号表</strong>：解析并显示符号表和动态符号，包括全局符号和本地符号。</li>
<li><strong>反汇编</strong>：支持代码段的反汇编，以查看可执行代码的汇编指令。</li>
<li><strong>导出功能</strong>：可以将分析结果导出为文本格式，以供进一步分析。</li>
</ul>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>MachOView 是 macOS 和 iOS 逆向工程、应用开发及安全研究的重要工具。它使得用户可以深入了解 Mach-O 文件的内部结构，适合用于以下场景：</p>
<ul>
<li><strong>应用逆向工程</strong>：了解应用内部的函数、符号等信息。</li>
<li><strong>安全研究</strong>：分析应用是否进行了加密保护，研究其安全机制。</li>
<li><strong>调试和开发</strong>：查看动态库依赖、文件结构等信息，以帮助调试和优化。</li>
</ul>
<h4 id="下载和安装"><a href="#下载和安装" class="headerlink" title="下载和安装"></a>下载和安装</h4><p>MachOView 可以通过项目的 GitHub 页面进行下载，支持 macOS 平台。使用者可以直接下载预编译的二进制文件，或通过源码自行编译安装。</p>
<p>使用 MachOView 查看可执行文件的 <code>LC_ENCRYPTION_INFO_64</code> 信息</p>
<p><img src="Xnip2024-10-14_16-56-13.jpg"></p>
<h3 id="otool"><a href="#otool" class="headerlink" title="otool"></a>otool</h3><p><code>otool</code> 是 macOS 上的一个命令行工具，用于显示可执行文件、动态库和目标文件的各种低级信息。它是开发者用来分析、调试和检查 Mach-O 文件结构的重要工具。Mach-O（Mach Object）文件格式是 macOS 和 iOS 使用的可执行文件格式，包括应用程序、动态库和内核扩展等。对于从事 macOS 或 iOS 应用开发及逆向工程的人员，<code>otool</code> 是一个非常有用的工具。</p>
<p><code>otool</code> 并非 macOS 系统自带的，而是随 <strong>Xcode Command Line Tools</strong> 一起提供的。因此，默认情况下 macOS 并不包含 <code>otool</code>。要使用 <code>otool</code>，需要先安装 <strong>Xcode Command Line Tools</strong>。幸运的是，不需要安装完整的 Xcode 应用，只需安装命令行工具即可获取 otool。</p>
<p>可以通过以下命令快速安装 Xcode Command Line Tools：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure>

<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p>假设我们有一个 Mach-O 文件 <code>example</code>，可以用以下命令查看其是壳的状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> ~/ otool -l MachO文件 | grep crypt</span><br><span class="line">     cryptoff 16384</span><br><span class="line">    cryptsize 265289728</span><br><span class="line">      cryptid 0</span><br></pre></td></tr></table></figure>

<p>显示 <code>cryptid 0</code> 表示壳已经被解密。</p>
<h1 id="iOS-应用砸壳工具"><a href="#iOS-应用砸壳工具" class="headerlink" title="iOS 应用砸壳工具"></a>iOS 应用砸壳工具</h1><h2 id="dumpdecrypted"><a href="#dumpdecrypted" class="headerlink" title="dumpdecrypted"></a><a href="https://github.com/stefanesser/dumpdecrypted">dumpdecrypted</a></h2><p>是一个动态库，利用 DYLD 的环境变量，将自己插入需要砸壳的进程中，但是很多年没有维护更新了。。。</p>
<h2 id="Clutch"><a href="#Clutch" class="headerlink" title="Clutch"></a><a href="https://github.com/KJCracks/Clutch">Clutch</a></h2><p>是一个 iOS 上命令行程序，也是很多年没有维护更新了。下载编译后在 iOS12.5.7 上，能砸壳一些简单的 app，但是像微信，支付宝这样的 app 会失败。</p>
<h2 id="frida-ios-dump"><a href="#frida-ios-dump" class="headerlink" title="frida-ios-dump"></a><a href="https://github.com/AloneMonkey/frida-ios-dump">frida-ios-dump</a></h2><p>是一个 python 脚本，目前最强的 iOS 砸壳脚本，支持最新版本微信，支付宝等。</p>
<h2 id="LLDB"><a href="#LLDB" class="headerlink" title="LLDB"></a>LLDB</h2><p>Xcode 自带的调试器，使用 lldb 命令手动实现砸壳。</p>
<h2 id="AppDump2"><a href="#AppDump2" class="headerlink" title="AppDump2"></a>AppDump2</h2><p>是一个 iOS App，不需要越狱设备，但是设备需要安装巨魔才能安装 AppDump2 实现砸壳。。。</p>
]]></content>
      <categories>
        <category>iOS 逆向与安全</category>
      </categories>
  </entry>
  <entry>
    <title>iPhoneX上pop回到根控制器上漂移的bug</title>
    <url>/2018/04/28/iPhoneX%E4%B8%8Apop%E5%9B%9E%E5%88%B0%E6%A0%B9%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B8%8A%E6%BC%82%E7%A7%BB%E7%9A%84bug/</url>
    <content><![CDATA[<p>记录一个在iPhone X上发生的诡异的bug…语言怎么描述都太苍白,那么直接看图<br><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/master/BrowserPreview_tmp201804281808.gif"></p>
<p>只有在滑动到最底部的时候,push到下一个页面,然后在pop回来就会出现contentOffset.y值自动偏移的现象…</p>
<p>视图的层次结构如图:<br><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/master/Snip20180428_1.png"></p>
<p>选中的视图控制器就是TabBarController的第二个子控制器,控制器的view就是一个UICollectionView;我是很懵逼的…同事说可能是iPhone X上的安全距离的原因(但我还是很懵逼)…于是我对视图层次结构做了下修改;</p>
<ul>
<li>取消修改控制器的view为UICollectionView</li>
<li>将UICollectionView作为控制器的view的子视图</li>
<li>设置collectionView的约束为,上左右等于控制器的view,下等于控制器的view的下面,但是偏移一个-34的高度(仅在iPhone X上)</li>
</ul>
<p>修改之后的视图层次结构如下:<br><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/master/Snip20180428_2.png"></p>
<p>这样,collectionView不再漂移了…对上述偏移的值进行修改测试可以发现,当这个值小于等于-34的时候就不会发生漂移,大于-34时就会发生漂移…换一句话的意思就是,如果collectionView距离底部的距离小于34的那么就会漂移,大于等于34不会发生漂移…</p>
]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenSSH</title>
    <url>/2024/10/27/OpenSSH/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>平时在使用 Mac 的过程中，经常会使用终端输入命令来执行一些操作。在越狱开发的过程中，同样需要在 iOS 系统上输入一些命令来执行一些任务。那么如何才能在 iOS 系统上输入命令呢，在 iOS 上安装一个终端命令行工具，然后在 iPhone 那小小的屏幕上用触摸屏输入命令吗？虽然说理论上和实际上都是可行的，但是通过手指触摸屏幕来输入命令的方式效率比较低，也不是很方便。这里还是推荐在 Mac 上远程登录到 iOS 系统，这样就可以使用 Mac 的键盘输入命令到 iOS 上去执行，更加方便，快捷。</p>
<h1 id="SSL、openSSL、SSH、openSSH"><a href="#SSL、openSSL、SSH、openSSH" class="headerlink" title="SSL、openSSL、SSH、openSSH"></a>SSL、openSSL、SSH、openSSH</h1><p>SSL（Secure Sockets Layer）是一种用于在计算机网络上进行安全通信的协议。SSL 最初由 Netscape 开发，后来发展为 TLS（Transport Layer Security）。SSL&#x2F;TLS 用于在客户端和服务器之间建立安全的加密连接，以保护敏感数据的传输，例如在网页浏览器和服务器之间的数据传输。</p>
<p>OpenSSL 是一个强大的、商业级的、功能齐全的开源工具包，它提供了一组库和命令行工具，用于处理 SSL&#x2F;TLS 协议和加密算法，是 SSL 协议的一款开源实现工具。OpenSSL 可以用于创建和管理数字证书、实现安全传输和通信，以及进行加密和解密等操作。它不仅支持 SSL&#x2F;TLS 协议，还支持多种加密算法和密码学功能。</p>
<p>SSH（Secure Shell）是一种用于安全远程登录和数据传输的网络协议。它为计算机之间的通信提供了加密和身份验证，以确保通信的机密性和完整性。SSH 使用公钥密码体制进行身份验证，并使用加密算法来保护数据的传输。</p>
<p>OpenSSH 是一个开源的 SSH 实现，它提供了 SSH 客户端和服务器的功能，用于安全远程登录、命令执行和文件传输。它包括客户端 ssh 和服务器 sshd、文件传输实用程序 scp 和 sftp 以及密钥生成工具 (ssh-keygen)、运行时密钥存储 (ssh-agent) 和许多支持程序。它是 Linux 和其他类 Unix 系统中最常见的 SSH 实现，也支持其他操作系统。</p>
<p>SSL 最早出现于 1994 年，用于 Web 浏览器和服务器之间的安全通信。OpenSSL 和 SSH 都起源于 1995 年，OpenSSL 是一个加密工具包，而 SSH 是用于安全远程登录和数据传输的协议。OpenSSH 是 SSH 协议的开源实现，起源于 1999 年，为 SSH 提供了广泛使用的实现。</p>
<p>OpenSSH 通常依赖于 OpenSSL。OpenSSH 使用 OpenSSL 库来实现加密和安全功能，包括加密通信、密钥生成、数字证书处理等。OpenSSL 提供了各种加密算法和密码学功能，使 OpenSSH 能够建立安全的 SSH 连接，并保护通信数据的机密性和完整性。在大多数情况下，安装 OpenSSH 时，系统会自动安装或链接到已经安装的 OpenSSL 库。这样，OpenSSH 就能够使用 OpenSSL 的功能来实现加密和安全性，而不必重新实现这些复杂的加密算法和协议。</p>
<p>因此，可以说 OpenSSH 依赖于 OpenSSL，OpenSSL 提供了 OpenSSH 所需的加密和安全功能，使得 OpenSSH 成为一种安全、可靠的远程登录和数据传输工具。这些安全协议和工具对于保护通信和数据安全至关重要。</p>
<h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><blockquote>
<p>⚠️注意：这里作者使用的是 checkra1n 越狱的 iOS 12.5.7 iPhone5s。</p>
</blockquote>
<p>对以上名词概念有了基本的了解之后，我们可以进行实践操作。如果感觉还是迷迷糊糊也不要紧，实践起来就会感觉简单多了。主要是对 OpenSSH 这个开源库提供的常用命令的使用。Mac 系统自带了这个工具所以不需要进行配置，而 iOS 系统上默认是没有安装这个工具的，包括越狱之后的 iOS 也没有，所以需要先下载安装这个工具。</p>
<p>安装过程很简单，如下图所示，在 Cydia 上搜索 OpenSSH 下载并按照提示进行安装就好了。</p>
<img src="32a8afae2fae413d8fa5984d89693e0f~tplv-k3u1fbpfcp-watermark.png" alt="IMG_0001.PNG" width="50%">

<p>安装好之后，就可以在 Mac 上远程登录到越狱 iOS 了。iOS 系统默认提供了两个用户，一个是 root 用户，是 iOS 中最高权限的用户，我们在逆向开发过程中基本都是使用这个用户。还有一个是 mobile 用户，是普通权限用户，iOS 平时进行 APP 安装，卸载基本都是使用这个用户，但是我们在逆向开发中很少或者基本不会使用到这个用户，这里有个了解就够了。</p>
<p>Cydia 首页有 OpenSSH 访问教程，这个文档详细的记载了如何从 Mac 远程登录到 iOS 设备上，并且也提供了修改默认密码的方法。建议英文不错的同学直接阅读这篇文档，不想看的就看我后面的介绍也可以。文档位置如下图所示</p>
<img src="41ffb7e4fae849d7846018c90bbbc177~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="IMG_0002.PNG" width="50%">

<h3 id="通过默认账号密码登录到-iPhone"><a href="#通过默认账号密码登录到-iPhone" class="headerlink" title="通过默认账号密码登录到 iPhone"></a>通过默认账号密码登录到 iPhone</h3><p>ssh 提供了两种登录到服务器的方式，第一种是使用账号和密码。第二种是免密码登录。下面先介绍第一种</p>
<ol>
<li>越狱 iPhone 在 Cydia 上安装 OpenSSH</li>
<li>确认 iPhone 和 Mac 电脑在同一个局域网下，在 Mac 打开终端，输入以下命令 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh root@iPhone的IP地址</span><br></pre></td></tr></table></figure>
 第一次连接会出现 <code>Are you sure you want to continue connecting (yes/no/[fingerprint])?</code> 提示，输入 <code>yes</code> 确认进行连接</li>
<li>输入默认的初始密码 <code>alpine</code> ,这里终端为了安全并不会显示密码的明文</li>
<li>之后就会看到终端切换到了 <code>iPhone:~ root#</code> 用户，代表成功登录到远程 iPhone 手机的 root 用户上了。这个时候，你在 Mac 终端输入的指令都会被发送到 iPhone 上，如下图<br> <img src="6b806498309a4589a7e39b35238b1616~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"><br> 如果你觉得还不过瘾，可以输入 <code>reboot</code> 命令，体会一下远程操纵手机的快乐（重启之后，你可能需要重新越狱一下 iPhone 了😶）</li>
<li>输入 <code>exit</code> 退出登录</li>
</ol>
<p>刚刚我们登录的是 <code>root</code> 用户。在 iOS 中，除了 <code>root</code> 用户，还有一个 <code>mobile</code> 用户。其中 <code>root</code> 用户是 iOS 中最高权限的用户。<code>mobile</code> 是普通权限用户，其实平时越狱调试过程中，很少会使用这个 <code>mobile</code> 用户，这里只是介绍一下。</p>
<p>能够成功登录 iPhone 之后，建议修改一下用户的默认密码，既然做逆向开发了，当然对安全也要注意一点。在登录 root 用户之后，</p>
<ul>
<li>输入 <code>passwd</code> 可以修改 root 用户的密码</li>
<li>输入 <code>passwd mobile</code> 可以修改 mobile 用户的密码。</li>
</ul>
<h3 id="通过免密码方式登录到-iPhone"><a href="#通过免密码方式登录到-iPhone" class="headerlink" title="通过免密码方式登录到 iPhone"></a>通过免密码方式登录到 iPhone</h3><p>OpenSSH 除了默认的账号密码登录的方式，还提供了免密码登录的方式。需要进一步完成一些配置才可以实现。服务器（在当前情况下，iPhone是服务器，Mac是客户端）的 ~&#x2F;.ssh 目录下需要添加一个 authorized_keys 文件，里面记录可以免密登录的设备的公钥信息。</p>
<p>当有客户端（Mac）登录的时候，服务器会查看 ~&#x2F;.ssh&#x2F;authorized_keys 文件中是否记录了当前登录的客户端的公钥信息，如果有就直接登录成功，没有就要求输入密码。所以我们要做的就是将 Mac 设备的公钥信息追加到 iPhone 的 authorized_keys 文件内容的最后面。追加是为了不影响其他的设备。完成这个操作需要先确保我们的 Mac 设备上已经有 ssh 生成的公钥文件。</p>
<p>打开 Mac 终端，输入 <code>ls ~/.ssh</code> 查看是否已经存在 <code>id_rsa.pub</code> 公钥文件，<code>.pub</code>就是公钥文件的后缀</p>
<p><img src="7b97ca3f9eee41048514e786d0909eea~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"></p>
<p>如果没有看到公钥文件，需要使用 <code>ssh-keygen</code> 命令生成该文件。按回车键接受默认选项，或者根据需要输入新的文件名和密码。这将生成一个公钥文件（id_rsa.pub）和一个私钥文件（id_rsa）。</p>
<p>使用 SSH 复制公钥到远程服务器。使用以下命令将本地计算机（Mac）上的公钥复制到远程服务器（iPhone）。请将<code>user</code>替换为您的远程服务器用户名，以及<code>remote_server</code>替换为服务器的域名或IP地址。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ssh-copy-id user@remote_server</span><br></pre></td></tr></table></figure>

<p><img src="72e2862e24124ebc9b8bc1d6122e7ff4~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"></p>
<p>在远程服务器（iPhone）上设置正确的权限。确保远程服务器上的<code>~/.ssh</code>文件夹权限设置为 700，并将<code>~/.ssh/authorized_keys</code>文件的权限设置为 600。这样可以确保SSH可以正确识别公钥并允许免密码登录。如下图所示：</p>
<p><img src="60c0d90bbd12440b9b15dea392525c10~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"></p>
<p>.ssh 文件夹前面的 <code>drwx------</code> 是 Linux 和类 Unix 系统中表示文件或目录权限的一种格式。在这个格式中，每一组由10个字符组成，代表文件或目录的不同权限。让我们逐个解释这些字符的含义：</p>
<ol>
<li><p>第一个字符：文件类型</p>
<ul>
<li><code>d</code> 表示目录（directory）</li>
<li><code>-</code> 表示普通文件</li>
<li><code>l</code> 表示符号链接（symlink）</li>
<li><code>b</code> 表示块设备文件（block device）</li>
<li><code>c</code> 表示字符设备文件（character device）</li>
<li><code>s</code> 表示套接字（socket）</li>
<li><code>p</code> 表示命名管道（named pipe）</li>
</ul>
</li>
<li><p>接下来的三个字符：文件所有者的权限</p>
<ul>
<li><code>r</code> 表示读权限（read）</li>
<li><code>w</code> 表示写权限（write）</li>
<li><code>x</code> 表示执行权限（execute）</li>
</ul>
</li>
<li><p>接下来的三个字符：文件所有者所在组的权限</p>
<ul>
<li><code>r</code> 表示读权限（read）</li>
<li><code>w</code> 表示写权限（write）</li>
<li><code>x</code> 表示执行权限（execute）</li>
</ul>
</li>
<li><p>最后三个字符：其他用户的权限</p>
<ul>
<li><code>r</code> 表示读权限（read）</li>
<li><code>w</code> 表示写权限（write）</li>
<li><code>x</code> 表示执行权限（execute）</li>
</ul>
</li>
</ol>
<p>所以，<code>drwx------</code> 表示这是一个目录，并且具有以下权限：</p>
<ul>
<li>文件所有者具有读、写和执行权限。</li>
<li>文件所有者所在组没有任何权限。</li>
<li>其他用户没有任何权限。</li>
</ul>
<p>后面 9 个字符分为三组，每组从左至右如果有对应的权限就是<code>421</code>相加起来就是 7 后面都是0。所以 .ssh 文件夹的权限是正确的值 700，如果不是 700 的使用 <code>chmod 700 .ssh</code> 进行提权。authorized_keys 文件的权限是 <code>rw</code> 就是 <code>420</code> 相加起来就是 6 。后面都是 0，所以 authorized_keys 的权限也是正确的值 600。同样如果不是 600，使用 <code>chmod 600 authorized_keys</code> 命令修改权限。</p>
<p>配置完成后，您现在可以使用 SSH 免密码登录到远程服务器（iPhone）。在 Mac 上，使用以下命令连接到远程服务器：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ssh root@10.10.20.155</span><br></pre></td></tr></table></figure>

<p>这将直接连接到远程服务器，而无需输入密码。</p>
<p><img src="866ac19a922d485083538ac1d4fbff8c~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"></p>
<h3 id="通过-USB-有线的方式登录到-iPhone"><a href="#通过-USB-有线的方式登录到-iPhone" class="headerlink" title="通过 USB 有线的方式登录到 iPhone"></a>通过 USB 有线的方式登录到 iPhone</h3><p>配置为免密码登录之后，还可以进一步使用 USB 有线连接的方式登录到手机。如果你经常使用 WiFi 这种方式远程登录调试就会发现偶尔会碰到指令输入，响应卡顿，反应慢的情况，这样的体验显然让人感到不爽。所以，在大部分情况下，更推荐使用 USB 有线连接登录到 iPhone 上，这样使用的过程中，就像在本地输入命令操作一样流畅。</p>
<p><code>iproxy</code> 是一个用于端口转发的命令行工具。它通常用于在 iOS 设备和计算机之间建立端口映射，从而将 iOS 设备上运行的服务暴露到计算机上。这对于开发者来说非常有用，因为可以通过本地计算机访问 iOS 设备上运行的服务，而无需将服务部署到公共网络上。</p>
<p><code>iproxy</code> 是 <code>usbmuxd</code> 的一部分，后者是一个用于连接和管理 iOS 设备的 USB 通信的守护进程。<code>usbmuxd</code> 允许通过 USB 连接与 iOS 设备进行通信，并且<code>iproxy</code> 则负责在本地计算机和iOS设备之间建立端口转发。</p>
<p>通常，您可以在命令行中使用 <code>iproxy</code> 命令来建立端口转发，例如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">iproxy local_port device_port</span><br></pre></td></tr></table></figure>

<p>其中，<code>local_port</code> 是本地计算机上的端口号，<code>device_port</code> 是 iOS 设备上的端口号。执行此命令后，iOS 设备上的服务将通过 <code>device_port</code> 映射到本地计算机上的 <code>local_port</code>。</p>
<p>请注意，使用 <code>iproxy</code> 需要先安装 <code>libusbmuxd</code> 包。在 macOS 上，您可以使用 Homebrew 来安装 <code>libusbmuxd</code>：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">brew install libusbmuxd</span><br></pre></td></tr></table></figure>

<p>安装好之后，就可以使用 iproxy 命令了，使用 iproxy 将本机 10010 端口和 USB 设备的 22 端口进行映射的命令如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">iproxy 10010 22</span><br></pre></td></tr></table></figure>

<p><img src="68273210a76642c5b692f47eadb5eeaa~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"></p>
<p>这里本机的端口 10010 可以设置为你想要的其他端口，但是不能是系统保留的端口（系统保留的端口有哪些，可以看<a href="https://baike.baidu.com/item/%E7%AB%AF%E5%8F%A3/103505?fr=ge_ala">百度</a>的介绍）。端口转发设置完成之后，这个终端就不要关闭，也不要管它了，新建另一个终端窗口进行 ssh 登录。此时，需要给 ssh 加上指定端口参数，命令如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ssh -p 10010 root@localhost</span><br></pre></td></tr></table></figure>

<p>同样第一次使用这种方式建立连接会给出提示，输入 <code>yes</code> 确认</p>
<p><img src="15c962453c7749b7bdb59c531c18f10e~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="image.png"></p>
<p>之后，在 iPhone 设备上输入命令调试时，再也不会遇到卡顿，慢，延迟的现象啦。玩得开心~</p>
<h1 id="ssh-常见问题"><a href="#ssh-常见问题" class="headerlink" title="ssh 常见问题"></a>ssh 常见问题</h1><p>有时候我们会对 iOS 设备重新越狱，重新越狱后的设备信息发生了变化，继续使用 ssh 登录是无法成功的。会给出如下信息：</p>
<p><img src="Xnip2024-09-15_04-35-31.jpg" alt="image.png"></p>
<p>在这种情况下，我们知道并不是发生了中间人攻击，而是 IP 地址跟设备不匹配了。所以可以使用 <code>ssh-keygen -R IP地址</code> 移除指定 IP 的设备信息。</p>
<p><img src="Xnip2024-09-15_04-39-25.jpg" alt="image.jpg"></p>
<p>再次使用 ssh 进行远程连接，就回到第一次远程登录那样了。</p>
<p><img src="Xnip2024-09-15_04-41-23.jpg" alt="image.jpg"></p>
<h1 id="在-palera1n-越狱的-iOS16-7-10-iPhone8plus-上使用-OpenSSH-遇到的问题"><a href="#在-palera1n-越狱的-iOS16-7-10-iPhone8plus-上使用-OpenSSH-遇到的问题" class="headerlink" title="在 palera1n 越狱的 iOS16.7.10 iPhone8plus 上使用 OpenSSH 遇到的问题"></a>在 palera1n 越狱的 iOS16.7.10 iPhone8plus 上使用 OpenSSH 遇到的问题</h1><p>使用 palera1n 越狱的时候，在安装 Sileo 的时候会提示设置一个终端密码，意味着默认的密码不再是 alpine 了。安装好 Sileo 之后，默认的软件源中已经有 openssh 了，所以直接在搜索框中搜索就好了。如下图所示：</p>
<img src="IMG_0005.PNG" alt="IMG_0003.PNG" width="50%">

<p>原本以为安装好 openssh 之后，可以像 iOS 12.5.7 那样顺利的远程连接。实际发现无法使用 root 用户登录，即使密码输入的是正确的。如下图：</p>
<p><img src="Xnip2024-09-15_05-02-16.jpg"></p>
<p>在 iOS 16 系统上，使用 palera1n 或者 dopamine 越狱成功之后，使用 ssh 的时候，默认的 root 用户出于安全考虑是禁用的，需要执行一次 <code>sudo passwd root</code> 修改 root 用户密码之后才可以使用，即使你修改的密码是一样的。 所以解决的方法有两种</p>
<ol>
<li>先用 mobile 用户登录，再执行 <code>sudo passwd root</code> 修改 root 密码之后，再次使用 root 用户登录。</li>
<li>在 iPhone 上下载终端应用程序，然后输入 <code>sudo passwd root</code> 修改 root 密码，之后再使用 root 用户登录。</li>
</ol>
<p>这里第一种方法我就不演示了，肯定没问题的。第 2 种方法需要用到 iOS 端的 Terminal App。我试过一些其他的终端程序无法成功运行。但是 <a href="https://mtac.app/repo/">MTAC’s Repo</a> 的 MTerminal 是可以成功在 iOS 16.7.10 上正常运行的。</p>
<p>在 iPhone 上运行 MTerminal 进行修改 root 用户密码操作如下图：</p>
<img src="IMG_0006.PNG" alt="IMG_0003.PNG" width="80%">

<p>修改成功后，再次使用 root 用户进行 ssh 远程连接到 iPhone 就和之前一模一样了，可以愉快的玩耍了。</p>
<p><img src="Xnip2024-09-15_05-17-44.jpg"></p>
]]></content>
      <categories>
        <category>iOS 逆向与安全</category>
      </categories>
  </entry>
  <entry>
    <title>解决git clone速度慢的问题</title>
    <url>/2018/10/26/%E8%A7%A3%E5%86%B3git-clone%E9%80%9F%E5%BA%A6%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>之前一直以为是公司对网络的封锁,导致git clone速度慢,后来网上查找这个问题的时候得知不能怪公司,是因为咱们在这个局域网内…<br>扯多了,回到正题,解决问题,由于我的是Mac电脑,我说的只针对Mac电脑</p>
<h5 id="1-进入终端命令行模式-输入"><a href="#1-进入终端命令行模式-输入" class="headerlink" title="1. 进入终端命令行模式,输入"></a>1. 进入终端命令行模式,输入</h5><p><code>sudo vim /etc/hosts</code></p>
<h5 id="2-输入i进入编辑模式-移动到最后一行准备输入"><a href="#2-输入i进入编辑模式-移动到最后一行准备输入" class="headerlink" title="2. 输入i进入编辑模式,移动到最后一行准备输入"></a>2. 输入i进入编辑模式,移动到最后一行准备输入</h5><h5 id="3-用浏览器访问-http-tool-chinaz-com-使用-IP查询-工具获得github-com和github-global-ssl-fastly-net的ip地址"><a href="#3-用浏览器访问-http-tool-chinaz-com-使用-IP查询-工具获得github-com和github-global-ssl-fastly-net的ip地址" class="headerlink" title="3. 用浏览器访问 http://tool.chinaz.com 使用 IP查询 工具获得github.com和github.global.ssl.fastly.net的ip地址"></a>3. 用浏览器访问 <a href="http://tool.chinaz.com/">http://tool.chinaz.com</a> 使用 IP查询 工具获得github.com和github.global.ssl.fastly.net的ip地址</h5><h5 id="4-回到第2步中按如下格式输入"><a href="#4-回到第2步中按如下格式输入" class="headerlink" title="4. 回到第2步中按如下格式输入:"></a>4. 回到第2步中按如下格式输入:</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">192.30.253.112 github.com</span><br><span class="line">151.101.44.249 github.global.ssl.fastly.net</span><br></pre></td></tr></table></figure>
<h5 id="5-按-esc-键-然后输入-wq-保存文件并退出vim编辑模式-到此hosts文件修改结束"><a href="#5-按-esc-键-然后输入-wq-保存文件并退出vim编辑模式-到此hosts文件修改结束" class="headerlink" title="5. 按 esc 键,然后输入 :wq 保存文件并退出vim编辑模式,到此hosts文件修改结束"></a>5. 按 esc 键,然后输入 :wq 保存文件并退出vim编辑模式,到此hosts文件修改结束</h5><h5 id="6-更新DNS缓存-输入"><a href="#6-更新DNS缓存-输入" class="headerlink" title="6. 更新DNS缓存,输入"></a>6. 更新DNS缓存,输入</h5><p><code>sudo dscacheutil -flushcache </code></p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一个pod install失败的解决方法</title>
    <url>/2018/04/16/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%AApod-install%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>今天在网络看到一个demo,想把它clone下来运行一下看看效果,大家都知道一般clone下来的项目需要使用<code>pod install</code>命令安装一下第三方库的,这个demo也不例外;问题在于这个demo的cocoapods版本太低了(0.39.0)以至于Podfile中有些语法现如今都无法识别…以下截图是执行<code>pod install</code>命令之后给出了的错误提示:<br><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/master/Snip20180416_21.png"></p>
<p>项目的Podfile如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source &#x27;https://github.com/CocoaPods/Specs.git&#x27;</span><br><span class="line">use_frameworks!</span><br><span class="line"></span><br><span class="line">target &#x27;RTPagedCollectionViewLayout_Example&#x27;, :exclusive =&gt; true do</span><br><span class="line">  pod &#x27;RTPagedCollectionViewLayout&#x27;, :path =&gt; &#x27;../&#x27;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">target &#x27;RTPagedCollectionViewLayout_Tests&#x27;, :exclusive =&gt; true do</span><br><span class="line">  pod &#x27;RTPagedCollectionViewLayout&#x27;, :path =&gt; &#x27;../&#x27;</span><br><span class="line">  </span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>大概的意思就是不支持 :exclusive &#x3D;&gt; true语法，在cocoaPods 1.0之后exclusive语法已经被移除了</p>
<p><a href="https://github.com/CocoaPods/CocoaPods/issues/4705">这里是Stack Overflow上的解答</a></p>
<p>将相关的代码删除之后,注意<code>,</code>号也要删除;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source &#x27;https://github.com/CocoaPods/Specs.git&#x27;</span><br><span class="line">use_frameworks!</span><br><span class="line"></span><br><span class="line">target &#x27;RTPagedCollectionViewLayout_Example&#x27; do</span><br><span class="line">  pod &#x27;RTPagedCollectionViewLayout&#x27;, :path =&gt; &#x27;../&#x27;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">target &#x27;RTPagedCollectionViewLayout_Tests&#x27; do</span><br><span class="line">  pod &#x27;RTPagedCollectionViewLayout&#x27;, :path =&gt; &#x27;../&#x27;</span><br><span class="line">  </span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>再次执行<code>pod install</code>命令,结果如下<br><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/master/Snip20180416_22.png"><br>已经安装成功了,给了两个警告⚠️,你可以不用管它,有强迫症的同学可以在target前加上<code>platform :ios, &#39;7.1&#39;</code>,这个7.1是你的项目的Deployment Target…</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source &#x27;https://github.com/CocoaPods/Specs.git&#x27;</span><br><span class="line">use_frameworks!</span><br><span class="line"></span><br><span class="line">platform :ios, &#x27;7.1&#x27;</span><br><span class="line"></span><br><span class="line">target &#x27;RTPagedCollectionViewLayout_Example&#x27; do</span><br><span class="line">  pod &#x27;RTPagedCollectionViewLayout&#x27;, :path =&gt; &#x27;../&#x27;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">target &#x27;RTPagedCollectionViewLayout_Tests&#x27; do</span><br><span class="line">  pod &#x27;RTPagedCollectionViewLayout&#x27;, :path =&gt; &#x27;../&#x27;</span><br><span class="line">  </span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>再次运行<code>pod install</code>完美</p>
<p><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/master/Snip20180416_23.png"></p>
]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>密码学概述</title>
    <url>/2024/04/24/%E5%AF%86%E7%A0%81%E5%AD%A6%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>密码学（来自希腊语kryptos，意思是隐藏）一词的核心是指使数据无法被窥探者读取的技术。当然，密码学也可以用于其他目的。密码学包括一系列技术，如验证数据的真实性（检测是否修改）、确定个人或其他实体的身份、确定谁发送了特定消息或创建了特定数据片段、通过网络安全地发送数据、用密码或口令安全地锁定文件等等。</p>
<p>计算机安全中使用的加密主要有两种类型，称为对称密钥加密和非对称密钥加密。</p>
<h1 id="对称密钥加密"><a href="#对称密钥加密" class="headerlink" title="对称密钥加密"></a>对称密钥加密</h1><p>对称密钥加密（也称为秘密密钥加密）是大多数人熟悉的密钥的经典用法：使用相同的密钥来加密和解密数据。经典且最容易破解的版本是凯撒密码（以朱利叶斯·凯撒命名），其中消息中的每个字母都被替换为字母表中固定位置数的字母（例如，“a”被“c”替换，“b”被替换为“d”等）。在凯撒密码中，用于加密和解密消息的密钥只是字母表旋转的位数以及旋转的方向。现代对称密钥算法更加复杂并且更难破解。</p>
<p>有许多不同的算法用于对称密钥加密，提供从最低限度到几乎牢不可破的安全性。其中一些算法提供了强大的安全性、易于代码实现以及快速的加密和解密。此类算法对于加密存储在计算机上的文件以保护它们以防未经授权的个人使用计算机等目的非常有用。但它们在从一台计算机向另一台计算机发送消息时用处不大，因为通信通道的两端都必须拥有相同的密钥并且必须保证其安全。此类密钥的分发和安全存储可能很困难，并且可能会造成安全漏洞。</p>
<p>虽然交换或创建对称密钥的安全技术可以在一定程度上克服这个问题（例如 Diffie-Hellman 密钥交换），但随着非对称密钥加密算法的发明，出现了一种用于计算机通信的更实用的解决方案。</p>
<p>常见的现代对称密钥加密算法有 DES，3DES，AES 等</p>
<h2 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h2><p>数据加密标准（英语：Data Encryption Standard，缩写为 DES）是一种对称密钥加密算法，1976 年被美国联邦政府的国家标准局确定为联邦资料处理标准，随后在国际上广泛流传开来。</p>
<p>DES 现在已经不是一种安全的加密方法，主要因为它使用的 56 位密钥过短。1999 年 1 月，distributed.net 与电子前哨基金会合作，在 22 小时 15 分钟内即公开破解了一个 DES 密钥。<br>也有一些分析报告提出了该算法的理论上的弱点，虽然在实际中难以应用。为了提供实用所需的安全性，可以使用 DES 的派生算法 3DES 来进行加密，虽然 3DES 也存在理论上的攻击方法。DES 标准和 3DES 标准已逐渐被高级加密标准（AES）所取代。</p>
<h2 id="3DES"><a href="#3DES" class="headerlink" title="3DES"></a>3DES</h2><p>三重数据加密算法（英语：Triple Data Encryption Algorithm，缩写为 TDEA，Triple DEA），或称 3DES（Triple DES），是一种对称密钥加密块密码，相当于是对每个数据块应用三次资料加密标准（DES）算法。由于计算机运算能力的增强，原版 DES 由于密钥长度过低容易被暴力破解；3DES 即是设计用来提供一种相对简单的方法，即通过增加 DES 的密钥长度来避免类似的攻击，而不是设计一种全新的块密码算法。</p>
<h2 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h2><p>高级加密标准（英语：Advanced Encryption Standard，缩写：AES），又称 Rijndael加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的 DES，已经被多方分析且广为全世界所使用。经过五年的甄选流程，高级加密标准由美国国家标准与技术研究院（NIST）于 2001 年 11 月 26 日发布于 FIPS PUB 197，并在 2002 年 5 月 26 日成为有效的标准。现在，高级加密标准已然成为对称密钥加密中最流行的算法之一。</p>
<p>该算法为比利时密码学家 Joan Daemen 和 Vincent Rijmen 所设计，结合两位作者的名字，以 Rijndael 为名投稿高级加密标准的甄选流程。</p>
<h2 id="加密模式"><a href="#加密模式" class="headerlink" title="加密模式"></a>加密模式</h2><p>对称加密算法的加密模式是指在对称加密过程中，明文如何被切分、填充和加密，以及密文如何被解密和还原成原始的明文。常见的对称加密算法包括 AES（高级加密标准）和 DES（数据加密标准），它们可以使用不同的加密模式来实现数据的保密性。</p>
<p>虽然加密模式通常应用于对称加密，它亦可以应用于公钥加密，例如在原理上对 RSA 进行处理，但在实用中，公钥密码学通常不用于加密较长的信息，而是使用结合对称加密和公钥加密的混合加密方案。</p>
<p>常见的对称加密模式包括：</p>
<ul>
<li>电子密码本模式（ECB）：是最简单的加密模式，将明文分成固定大小的块，然后每个块单独加密。这种模式的问题在于相同的明文块会加密成相同的密文块，可能导致安全性问题。</li>
<li>密码分组链接模式（CBC）：1976 年，IBM 发明了密码分组链接（CBC，Cipher-block chaining）模式。在 CBC 模式中，每个明文块先与前一个密文块进行异或后，再进行加密。在这种方法中，每个密文块都依赖于它前面的所有明文块。同时，为了保证每条消息的唯一性，在第一个块中需要使用初始化向量。</li>
<li>计数器模式（CTR）：将一个计数器与明文块进行加密，然后再将结果与明文进行异或操作，从而产生密文。这种模式可以并行处理，并且不需要对明文进行填充，因此在某些情况下更高效。</li>
<li>密文反馈模式（CFB）：将前一个密文块作为加密器的输入，然后将结果与明文进行异或操作，得到密文。这种模式可以进行流加密，即逐位地进行加密和解密。</li>
<li>输出反馈模式（OFB）：类似于CFB，但是加密器的输出用于生成密钥流，而不是直接与明文进行异或操作。</li>
</ul>
<p>这些加密模式的选择取决于应用场景、安全需求和性能要求。在实际应用中，需要根据具体情况选择最合适的加密方式和模式。</p>
<h2 id="对称加密的终端练习"><a href="#对称加密的终端练习" class="headerlink" title="对称加密的终端练习"></a>对称加密的终端练习</h2><p>MacOS 自带了一个叫 OpenSSL 的开源加密工具包，提供了一系列的加密算法和安全通信协议的实现，包括 SSL 和 TLS。它由一组函数库和命令行工具组成，可以用于处理数字证书、实现安全通信协议、进行加密和解密等任务。</p>
<p>由于 DES，3DES 目前都不太推荐了，所以这里仅使用 AES 算法演示。</p>
<p>使用 openssl 对明文 helloworld 进行 AES 算法 ECB 模式加密的命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;helloworld&quot;</span> | openssl enc -e -aes-256-ecb -a -pbkdf2 -K 123456</span><br></pre></td></tr></table></figure>

<p>会输出如下结果</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">bnPkNleniCxX5rE1JjnOYg==</span><br></pre></td></tr></table></figure>

<p>对以上结果解密的命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;bnPkNleniCxX5rE1JjnOYg==&quot;</span> | openssl enc -d -aes-256-ecb -a -pbkdf2 -K</span><br><span class="line"> 123456</span><br></pre></td></tr></table></figure>


<p>对明文 helloworld 进行 aes cbc 加密的命令是：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> helloworld | openssl enc -e -aes-256-cbc -a -pbkdf2 -K 123456</span><br><span class="line">U2FsdGVkX19TcP2WjEKOsVXGblFWLGMJM/1dDgvY/S8=</span><br></pre></td></tr></table></figure>

<p>这里 -k 后面的参数 123456 就是用到的密钥。对上面的输出进行解密的命令是：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> U2FsdGVkX19TcP2WjEKOsVXGblFWLGMJM/1dDgvY/S8= | openssl enc -d -aes-256</span><br><span class="line">-cbc -a -pbkdf2 -K 123456</span><br><span class="line">helloworld</span><br></pre></td></tr></table></figure>

<h2 id="iOS-中使用对称加密"><a href="#iOS-中使用对称加密" class="headerlink" title="iOS 中使用对称加密"></a>iOS 中使用对称加密</h2><p>iOS 系统提供了一个 CommonCrypto 库用于加密解密，生成消息摘要（hash）等功能。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;ViewController.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;CommonCrypto/CommonCrypto.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSData</span> *encryptAES256CBC(<span class="built_in">NSData</span> *data, <span class="built_in">NSData</span> *key, <span class="built_in">NSData</span> *iv) &#123;</span><br><span class="line">    size_t bufferSize = data.length + kCCBlockSizeAES128;</span><br><span class="line">    uint8_t buffer[bufferSize];</span><br><span class="line">    size_t numBytesEncrypted = <span class="number">0</span>;</span><br><span class="line">    CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt,</span><br><span class="line">                                          kCCAlgorithmAES,</span><br><span class="line">                                          kCCOptionPKCS7Padding,</span><br><span class="line">                                          key.bytes, key.length,</span><br><span class="line">                                          iv.bytes,</span><br><span class="line">                                          data.bytes, data.length,</span><br><span class="line">                                          buffer, bufferSize,</span><br><span class="line">                                          &amp;numBytesEncrypted);</span><br><span class="line">    <span class="keyword">if</span> (cryptStatus == kCCSuccess) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSData</span> dataWithBytes:buffer length:numBytesEncrypted];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Error: %d&quot;</span>, cryptStatus);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSData</span> *decryptAES256CBC(<span class="built_in">NSData</span> *data, <span class="built_in">NSData</span> *key, <span class="built_in">NSData</span> *iv) &#123;</span><br><span class="line">    size_t bufferSize = data.length + kCCBlockSizeAES128;</span><br><span class="line">    uint8_t buffer[bufferSize];</span><br><span class="line">    size_t numBytesDecrypted = <span class="number">0</span>;</span><br><span class="line">    CCCryptorStatus cryptStatus = CCCrypt(kCCDecrypt,</span><br><span class="line">                                          kCCAlgorithmAES,</span><br><span class="line">                                          kCCOptionPKCS7Padding,</span><br><span class="line">                                          key.bytes, key.length,</span><br><span class="line">                                          iv.bytes,</span><br><span class="line">                                          data.bytes, data.length,</span><br><span class="line">                                          buffer, bufferSize,</span><br><span class="line">                                          &amp;numBytesDecrypted);</span><br><span class="line">    <span class="keyword">if</span> (cryptStatus == kCCSuccess) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSData</span> dataWithBytes:buffer length:numBytesDecrypted];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Error: %d&quot;</span>, cryptStatus);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line">    <span class="built_in">NSString</span> *plaintext = <span class="string">@&quot;helloworld&quot;</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *key = <span class="string">@&quot;12345678123456781234567812345678&quot;</span>; <span class="comment">// 32字节长的密钥</span></span><br><span class="line">    <span class="built_in">NSString</span> *iv = <span class="string">@&quot;0123456789abcdef&quot;</span>; <span class="comment">// 16字节长的初始化向量</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSData</span> *plaintextData = [plaintext dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    <span class="built_in">NSData</span> *keyData = [key dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    <span class="built_in">NSData</span> *ivData = [iv dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSData</span> *encryptedData = encryptAES256CBC(plaintextData, keyData, ivData);</span><br><span class="line">    <span class="keyword">if</span> (encryptedData) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Encrypted data: %@&quot;</span>, [encryptedData base64EncodedStringWithOptions:<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSData</span> *decryptedData = decryptAES256CBC(encryptedData, keyData, ivData);</span><br><span class="line">    <span class="keyword">if</span> (decryptedData) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Decrypted data: %@&quot;</span>, [[<span class="built_in">NSString</span> alloc] initWithData:decryptedData encoding:<span class="built_in">NSUTF8StringEncoding</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>上面的 iOS 代码中使用的加密和解密函数，等价于以下 openssl 终端命令：</p>
<p>加密</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;helloworld&quot;</span> | openssl enc -e -aes-256-cbc -K <span class="string">&quot;3132333435363738313233343536373831323334353637383132333435363738&quot;</span> -iv <span class="string">&quot;30313233343536373839616263646566&quot;</span> -<span class="built_in">base64</span></span><br><span class="line">dMujh+yeGsbTA0xqdhae4Q==</span><br></pre></td></tr></table></figure>

<p>解密</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;dMujh+yeGsbTA0xqdhae4Q==&quot;</span> | openssl enc -d -aes-256-cbc -K <span class="string">&quot;3132333435363738313233343536373831323334353637383132333435363738&quot;</span> -iv <span class="string">&quot;30313233343536373839616263646566&quot;</span> -<span class="built_in">base64</span></span><br><span class="line">helloworld%</span><br></pre></td></tr></table></figure>

<p>openssl 的 -K 和 -iv 参数的类型是 16 进制编码的字符串。12345678123456781234567812345678 的 16 进制编码就是 3132333435363738313233343536373831323334353637383132333435363738，同样 0123456789abcdef 的 16 进制编码就是 30313233343536373839616263646566</p>
<h1 id="非对称密钥加密"><a href="#非对称密钥加密" class="headerlink" title="非对称密钥加密"></a>非对称密钥加密</h1><p>在非对称密钥加密中，不同的密钥用于加密和解密消息。最有用的非对称密钥算法是那些不能从另一个密钥推导出密钥的算法。在这种情况下，一个密钥可以公开，而另一个密钥则保持安全。这种安排通常称为公钥密码术，并且与对称加密相比具有一些明显的优势：消除了向大量用户分发密钥的必要性，并且该算法可用于身份验证以及加密。</p>
<p>第一个广泛使用的公钥算法由 Ron Rivest、Adi Shamir 和 Len Adleman 于 1977 年描述，被称为 RSA 加密，源自其缩写。尽管此后又创建了其他公钥算法，但 RSA 仍然是最常用的。该方法的数学原理超出了本文档的范围，可以在互联网和许多密码学书籍中找到。该算法基于两个大素数及其乘积的数学运算。人们认为它的强度与分解非常大的数的难度有关。以现代数字计算机当前和可预见的速度，在生成 RSA 密钥时选择足够长的素数应该可以使该算法无限期地安全。然而，这一观点尚未得到数学证明，并且快速分解算法或完全不同的破解 RSA 加密的方法是有可能的。此外，如果实用的量子计算机被开发出来，分解大数将不再是一个棘手的问题。</p>
<p>其他公钥算法基于与 RSA 具有同等复杂性的不同数学，包括 ElGamal 加密和椭圆曲线加密。它们的使用类似于 RSA 加密（尽管它们背后的数学原理不同），并且本文档不会进一步讨论它们。</p>
<h2 id="RSA-算法"><a href="#RSA-算法" class="headerlink" title="RSA 算法"></a>RSA 算法</h2><p>1977 年三位麻省理工学院的数学家 罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起设计了一种算法，可以实现非对称加密。这个算法用他们三个人的名字命名，叫做 RSA 算法。</p>
<h3 id="RSA-密钥生成过程"><a href="#RSA-密钥生成过程" class="headerlink" title="RSA 密钥生成过程"></a>RSA 密钥生成过程</h3><p>在 RSA 算法中，首先选择两个大质数 p 和 q，然后计算他们的乘积 n &#x3D; p * q。接下来，计算欧拉函数 φ(n) &#x3D; (p-1)(q-1)。在选择公钥 e 时，需要确保 e 和 φ(n) 互质。<br>然后找到一个整数 d，使得（e * d）mod φ(n) &#x3D; 1。这个 d 就是私钥。</p>
<h3 id="RSA-加密和解密"><a href="#RSA-加密和解密" class="headerlink" title="RSA 加密和解密"></a>RSA 加密和解密</h3><p>在 RSA 加密过程中，明文 m 经过公钥 e 进行加密得到密文 c ，计算公式为 c &#x3D; m<sup>e</sup> % n。在 RSA 解密过程中，密文 c 经过私钥 d 进行解密得到明文 m，计算公式为 m &#x3D; c<sup>d</sup> % n。</p>
<blockquote>
<p>一个问题？在 RSA 算法中，为什么 e 和 φ(n) 互质，d 是 e 的模反元素，就可以保证 M<sup>e * d</sup> % n &#x3D; M 呢？我听过某讲师说是基于欧拉定理，但是欧拉定理的推导中是要求 m 和 n 互质的，但是刚刚 RSA 密钥生成过程中并没有要求 m 和 n 互质，只需要 m 小于 n 就够了。</p>
</blockquote>
<h3 id="RSA-算法的终端练习"><a href="#RSA-算法的终端练习" class="headerlink" title="RSA 算法的终端练习"></a>RSA 算法的终端练习</h3><p>使用 openssl 生成 RSA 私钥的命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">openssl genrsa -out private_key.pem 2048</span><br></pre></td></tr></table></figure>

<p>这个命令会生成一个 2048 位长度的 RSA 私钥，并将其保存在名为 private_key.pem 的文件中。</p>
<p>将私钥转换成对应的公钥，可以使用以下命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">openssl rsa -pubout -<span class="keyword">in</span> private_key.pem -out public_key.pem</span><br></pre></td></tr></table></figure>

<p>现在在当前目录下就会存在两个文件，一个是公钥 <em>public_key.pem</em>，一个是私钥 <em>private_key.pem</em> 。</p>
<p>接下来我们使用这对密钥进行加密解密的演示，先创建一个文件 original.txt 存放明文数据，命令如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;密码是123456&quot;</span> &gt; original.txt</span><br></pre></td></tr></table></figure>

<p>使用公钥对 original.txt 文件进行加密并生成一个 encrypted.txt 文件的命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">openssl pkeyutl -encrypt -<span class="keyword">in</span> original.txt -out encrypted.txt -pubin -inkey public_key.pem</span><br></pre></td></tr></table></figure>

<p>可以使用 <code>cat encrypted.txt </code> 查看加密后的结果，发现是一堆乱码，啥也看不懂。。。接下来使用私钥对 encrypted.txt 文件进行解密并生成一个 decrypted.txt 文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">openssl pkeyutl -decrypt -<span class="keyword">in</span> encrypted.txt -out decrypted.txt -inkey private_key.pem</span><br></pre></td></tr></table></figure>

<p>使用 <code>cat decrypted.txt </code> 查看解密后的结果，可以看到跟 original.txt 的内容是一模一样的。</p>
<!--
### RSA 的数学原理
理解 RSA 的密钥生成过程和加密解密需要一定的数学基础，欧拉函数，欧拉定理，模反元素。如果不感兴趣的也可以跳过本节内容。

了解欧拉函数之前，首先需要知道什么是两个数互质，如果两个正整数，除了 1 以外，没有其他公因数，那么这两个数就是互质的。

#### 欧拉函数

欧拉函数也称为欧拉 φ 函数（phi函数），通常用符号 φ(n) 表示，是一个与正整数 n 相关的算术函数。它表示小于或等于 n 的正整数中与 n 互质的数的个数。

欧拉函数的性质：

* 如果 n 为质数，那么 φ(n) = n - 1
* 如果 n 是两个互质的整数 a，b 之积，那么 φ(n) = φ(a) * φ(b)

结合上面两点可以得到以下结论，如果 n 是两个质数 p1，p2 之积，那么

φ(n) = φ(p1) * φ(p2) = (p1 - 1) * (p2 - 1)

#### 欧拉定理

如果两个正整数 m 和 n 互质，那么 m 的 φ(n) 次方减去 1，可以被 n 整除。即：

m<sup>φ(n)</sup> mod n = 1

这个是已经证明的数学定理，不需要怀疑它的正确性。将上式两边同时加上 k 次方可以得到

m<sup>k * φ(n)</sup> mod n = 1

再将两边同时乘以 m 可以得到：

m<sup>k * φ(n) + 1</sup> mod n = m

#### 模反元素
-->

<h3 id="iOS-中使用非对称加密算法"><a href="#iOS-中使用非对称加密算法" class="headerlink" title="iOS 中使用非对称加密算法"></a>iOS 中使用非对称加密算法</h3><p>iOS 提供了 Security.framework 框架用于帮助开发者实现各种安全相关的功能。这个框架包含了处理加密、密钥管理、证书、信任策略和安全通信的基本功能。通过使用 Security 框架，开发者可以确保应用程序的数据保护、安全传输和用户身份验证等功能。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;ViewController.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;Security/Security.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"><span class="comment">// 生成密钥对</span></span><br><span class="line">- (<span class="built_in">NSDictionary</span> *)generateKeyPair &#123;</span><br><span class="line">    <span class="built_in">NSDictionary</span> *parameters = @&#123;</span><br><span class="line">        (__bridge <span class="type">id</span>)kSecAttrKeyType : (__bridge <span class="type">id</span>)kSecAttrKeyTypeRSA,</span><br><span class="line">        (__bridge <span class="type">id</span>)kSecAttrKeySizeInBits : @<span class="number">2048</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">CFErrorRef</span> createError = <span class="literal">NULL</span>;</span><br><span class="line">    SecKeyRef privateKeyRef = SecKeyCreateRandomKey((__bridge <span class="built_in">CFDictionaryRef</span>)parameters, &amp;createError);</span><br><span class="line">    SecKeyRef publicKeyRef  = SecKeyCopyPublicKey(privateKeyRef);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (privateKeyRef &amp;&amp; publicKeyRef &amp;&amp; createError == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">NSData</span> *publicKeyData = (__bridge_transfer <span class="built_in">NSData</span> *)SecKeyCopyExternalRepresentation(publicKeyRef, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">NSData</span> *privateKeyData = (__bridge_transfer <span class="built_in">NSData</span> *)SecKeyCopyExternalRepresentation(privateKeyRef, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">CFRelease</span>(privateKeyRef); <span class="comment">// 释放 privateKeyRef</span></span><br><span class="line">        <span class="built_in">CFRelease</span>(publicKeyRef); <span class="comment">// 释放 publicKeyRef</span></span><br><span class="line">        <span class="keyword">return</span> @&#123;</span><br><span class="line">            <span class="string">@&quot;publicKey&quot;</span>: publicKeyData,</span><br><span class="line">            <span class="string">@&quot;privateKey&quot;</span>: privateKeyData</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Failed to generate key pair: %@&quot;</span>, (__bridge <span class="built_in">NSError</span> *)createError);</span><br><span class="line">        <span class="keyword">if</span> (createError) &#123;</span><br><span class="line">            <span class="built_in">CFRelease</span>(createError); <span class="comment">// 释放错误对象</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (privateKeyRef) &#123;</span><br><span class="line">            <span class="built_in">CFRelease</span>(privateKeyRef); <span class="comment">// 释放 privateKeyRef</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (publicKeyRef) &#123;</span><br><span class="line">            <span class="built_in">CFRelease</span>(publicKeyRef); <span class="comment">// 释放 publicKeyRef</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用公钥加密数据</span></span><br><span class="line">- (<span class="built_in">NSData</span> *)encryptDataWithPublicKey:(SecKeyRef)publicKey data:(<span class="built_in">NSData</span> *)data &#123;</span><br><span class="line">    <span class="built_in">CFErrorRef</span> error = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">CFDataRef</span> encryptedData = SecKeyCreateEncryptedData(publicKey, kSecKeyAlgorithmRSAEncryptionPKCS1, (__bridge <span class="built_in">CFDataRef</span>)data, &amp;error);</span><br><span class="line">    <span class="keyword">if</span> (encryptedData &amp;&amp; error == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">NSData</span> *result = (__bridge_transfer <span class="built_in">NSData</span> *)encryptedData;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Encryption failed with error: %@&quot;</span>, (__bridge <span class="built_in">NSError</span> *)error);</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            <span class="built_in">CFRelease</span>(error);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (encryptedData) &#123;</span><br><span class="line">            <span class="built_in">CFRelease</span>(encryptedData);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用私钥解密数据</span></span><br><span class="line">- (<span class="built_in">NSData</span> *)decryptDataWithPrivateKey:(SecKeyRef)privateKey data:(<span class="built_in">NSData</span> *)data &#123;</span><br><span class="line">    <span class="built_in">CFErrorRef</span> error = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">CFDataRef</span> decryptedData = SecKeyCreateDecryptedData(privateKey, kSecKeyAlgorithmRSAEncryptionPKCS1, (__bridge <span class="built_in">CFDataRef</span>)data, &amp;error);</span><br><span class="line">    <span class="keyword">if</span> (error == <span class="literal">NULL</span> &amp;&amp; decryptedData) &#123;</span><br><span class="line">        <span class="built_in">NSData</span> *data = (__bridge <span class="built_in">NSData</span> *)decryptedData;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Decryption failed with error: %@&quot;</span>, (__bridge <span class="built_in">NSError</span> *)error);</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            <span class="built_in">CFRelease</span>(error);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (decryptedData) &#123;</span><br><span class="line">            <span class="built_in">CFRelease</span>(decryptedData);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line">    <span class="built_in">NSDictionary</span> *keyPair = [<span class="keyword">self</span> generateKeyPair];</span><br><span class="line">    <span class="built_in">NSData</span> *publicKeyData = keyPair[<span class="string">@&quot;publicKey&quot;</span>];</span><br><span class="line">    <span class="built_in">NSData</span> *privateKeyData = keyPair[<span class="string">@&quot;privateKey&quot;</span>];</span><br><span class="line">    <span class="keyword">if</span> (publicKeyData &amp;&amp; privateKeyData) &#123;</span><br><span class="line">        <span class="built_in">NSMutableDictionary</span> *attributes = @&#123;</span><br><span class="line">            (__bridge <span class="type">id</span>)kSecAttrKeyType : (__bridge <span class="type">id</span>)kSecAttrKeyTypeRSA,</span><br><span class="line">            (__bridge <span class="type">id</span>)kSecAttrKeyClass : (__bridge <span class="type">id</span>)kSecAttrKeyClassPublic</span><br><span class="line">        &#125;.mutableCopy;</span><br><span class="line">        SecKeyRef publicKeyRef = SecKeyCreateWithData((__bridge <span class="built_in">CFDataRef</span>)publicKeyData, (__bridge <span class="built_in">CFDictionaryRef</span>)attributes, <span class="literal">NULL</span>);</span><br><span class="line">        attributes[(__bridge <span class="type">id</span>)kSecAttrKeyClass] = (__bridge <span class="type">id</span>)kSecAttrKeyClassPrivate;</span><br><span class="line">        SecKeyRef privateKeyRef = SecKeyCreateWithData((__bridge <span class="built_in">CFDataRef</span>)privateKeyData, (__bridge <span class="built_in">CFDictionaryRef</span>)attributes, <span class="literal">NULL</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSString</span> *originalString = <span class="string">@&quot;Hello, World!&quot;</span>;</span><br><span class="line">        <span class="built_in">NSData</span> *originalData = [originalString dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSData</span> *encryptedData = [<span class="keyword">self</span> encryptDataWithPublicKey:publicKeyRef data:originalData];</span><br><span class="line">        <span class="keyword">if</span> (encryptedData) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;Encrypted Data: %@&quot;</span>, [encryptedData base64EncodedStringWithOptions:<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">NSData</span> *decryptedData = [<span class="keyword">self</span> decryptDataWithPrivateKey:privateKeyRef data:encryptedData];</span><br><span class="line">            <span class="keyword">if</span> (decryptedData) &#123;</span><br><span class="line">                <span class="built_in">NSString</span> *decryptedString = [[<span class="built_in">NSString</span> alloc] initWithData:decryptedData encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@&quot;Decrypted String: %@&quot;</span>, decryptedString);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h1 id="Hash-函数"><a href="#Hash-函数" class="headerlink" title="Hash 函数"></a>Hash 函数</h1><p>Hash，一般翻译做“散列”，也有直接音译为“哈希”的。哈希函数是一种将任意大小的输入数据转换为固定长度散列值的算法。哈希函数的主要作用是验证数据的完整性和唯一性，可以简单的理解为二进制数据的身份证或者指纹。常见的哈希函数包括 MD5、SHA-1 和 SHA-256 等。</p>
<p>哈希函数的特点：</p>
<ul>
<li>计算速度快</li>
<li>将任意长度的数据计算出固定长度的哈希值</li>
<li>对相同数据计算得到的结果是不变的</li>
<li>具备单向性，无法逆运算</li>
</ul>
<h2 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h2><p>即 Message Digest 5 的缩写，产生 128 位的哈希值。也就是 32 位 16 进制数。Mac 电脑终端一般自带 md5 命令，可以用于一些简单的计算。例如计算 “12345” 的 md5 值：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">md5 -s 12345</span><br><span class="line">MD5 (<span class="string">&quot;12345&quot;</span>) = 827ccb0eea8a706c4c34a16891f84e7b</span><br></pre></td></tr></table></figure>

<p>假设你有两份同名的文件，但是不确定内容是否是一样的。就可以使用 md5 查看两个文件的哈希值。</p>
<p>注意 md5 由于长度较短，目前已经不太安全，因为可以对明文和它的 md5 哈希值建立一个字典，比如 “12345” 的 md5 值是 827ccb0eea8a706c4c34a16891f84e7b 。目前某些解密网站已经建立了这样的字典，如 <a href="https://www.cmd5.com/">https://www.cmd5.com/</a> 所以如果你的需求对安全性要求较高的话，不推荐使用了。但如果是平时用来验证文件的唯一性倒也没什么太大问题。</p>
<h2 id="SHA"><a href="#SHA" class="headerlink" title="SHA"></a>SHA</h2><p>SHA 代表安全散列算法（Secure Hash Algorithm），是一种广泛使用的密码学哈希函数，用于生成数据的哈希值。哈希函数将输入数据转换为固定长度的数据串，通常是一串数字和字母的组合，该串称为哈希值或消息摘要。SHA 算法的哈希值长度可以根据具体的 SHA 版本而变化，比如 SHA-1 生成 160 位的哈希值，而 SHA-256 生成 256 位的哈希值。目前主流的 SHA 版本主要是 SHA-256 和 SHA-3。这两个版本都是较新的，并且在安全性和性能方面都得到了广泛认可。</p>
<h3 id="SHA-1"><a href="#SHA-1" class="headerlink" title="SHA-1"></a>SHA-1</h3><p>产生 160 位的散列值，目前已经不安全</p>
<h3 id="SHA-2"><a href="#SHA-2" class="headerlink" title="SHA-2"></a>SHA-2</h3><p>SHA-256，SHA-384，SHA-512，散列值长度分别是 256 位，384 位，512 位</p>
<h3 id="SHA-3"><a href="#SHA-3" class="headerlink" title="SHA-3"></a>SHA-3</h3><p>SHA-3 是 NIST 选定的一种新的哈希算法标准，也称为 Keccak。它是在 SHA-2 之后发布的，与 SHA-2 系列不同，SHA-3 提供了与之前版本不同的设计和性能特性。SHA-3 的最常见变体是 SHA-3-256，生成 256 位的哈希值。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul>
<li>HMAC（Hash-based Message Authentication Code）是一种用于验证消息完整性和真实性的加密方案。</li>
<li>拆词搜索</li>
<li>版权</li>
<li>数字签名</li>
</ul>
<h1 id="base64-编码"><a href="#base64-编码" class="headerlink" title="base64 编码"></a>base64 编码</h1><p>Base64 编码是一种将二进制数据转换成文本数据的编码方式。在 Base64 编码中，每个字符由 64 个字符中的一个表示，因此得名。Base64 编码常用于在网络传输中表示二进制数据，比如在电子邮件中传输附件、在网页中嵌入图片等场景。</p>
<p>Base64 编码的原理是将二进制数据每 6 位转换成一个字符，所以每 3 个字节（24 位）的二进制数据转换成 4 个 Base64 字符。如果原始数据长度不是 3 的倍数，则在末尾补上相应数量的 0，并用 “&#x3D;” 字符填充以保持长度是 4 的倍数。所以以后看到字符串的末尾是 “&#x3D;” 字符的时候，它有可能就是 Base64 编码后的字符串。</p>
<p>Base64 编码使用了 64 个字符，通常是大小写字母 a-z、A-Z、数字 0-9，以及两个额外的字符（通常是”+”和”&#x2F;“）作为基本字符集，不同的实现中有时候会用不同的字符集。</p>
<p>Base64 编码并不是加密算法，因为它可以轻松地被解码还原成原始数据。它的主要作用是在不支持二进制传输的环境中，将二进制数据表示为文本，便于传输和处理。</p>
<h1 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h1><p>数字签名是一种用于验证数据完整性和身份验证的技术。它使用非对称加密技术，结合了哈希函数和公钥加密算法，以确保数据的完整性、真实性和不可否认性。</p>
<p>数字签名通常由以下步骤组成：</p>
<ol>
<li>创建消息摘要：发送方使用哈希函数（如 SHA-256）生成消息的摘要或哈希值。这个摘要是一个固定长度的字符串，用于代表原始数据的内容。</li>
<li>使用私钥签名：发送方使用自己的私钥对消息摘要进行加密，形成数字签名。私钥只有发送方知道，因此只有发送方能够使用私钥进行签名。</li>
<li>传输数据：发送方将原始数据与数字签名一起发送给接收方。</li>
<li>验证签名：接收方收到数据后，使用发送方的公钥对数字签名进行解密，得到消息摘要。然后，接收方使用相同的哈希函数生成接收到的原始数据的摘要。如果两个摘要匹配，则表明数据未被篡改，签名有效；否则，数据可能已被篡改或签名无效。</li>
</ol>
<p>数字签名的主要目的是确保数据的完整性和真实性，同时提供身份验证和不可否认性，即发送方不能否认其曾经签署过数据。这使得数字签名在许多领域，如电子商务、数字文档、软件分发等方面发挥了重要作用。</p>
<p>简单的一句话概括，数字签名就是使用私钥对数据的哈希值进行加密。</p>
<h1 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h1><p>数字证书是一种用于加密和认证网络通信的安全工具。它是由一个权威的数字证书颁发机构（Certificate Authority，CA）签发的一种电子文档，用于确认特定实体的身份信息。数字证书包含了一些重要的信息，包括：</p>
<p>一个数字证书通常包含以下信息：</p>
<ul>
<li>主体信息：证书的主体是该证书所代表的实体，通常是一个个人、组织或网络设备。主体信息通常包括名称、电子邮件地址等。</li>
<li>公钥：证书包含了主体的公钥，用于加密和验证数字签名。这个公钥与主体的私钥配对，用于加密和解密通信数据。</li>
<li>证书序列号：每个证书都有一个唯一的序列号，用于标识该证书。</li>
<li>有效期：证书有一个有效期限，指定了证书的生效时间和到期时间。过期的证书不再可信。</li>
<li>数字签名：证书被 CA 用其私钥签名，以确保证书的真实性和完整性。客户端可以使用 CA 的公钥来验证数字签名。</li>
<li>颁发者信息：指定了颁发该证书的 CA 的信息。</li>
<li>扩展信息：可能包含一些其他信息，例如用途、策略等。</li>
</ul>
<p>数字证书在网络通信中广泛用于安全连接的建立，例如 HTTPS（安全的HTTP）、SSL&#x2F;TLS等。通过验证数字证书的真实性，可以确保与远程服务器之间的通信是安全的，并且可以防止中间人攻击等安全威胁。</p>
]]></content>
      <categories>
        <category>iOS 逆向与安全</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>密码学</tag>
        <tag>hash</tag>
        <tag>RSA</tag>
        <tag>DES</tag>
        <tag>AES</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS逆向与安全开篇介绍</title>
    <url>/2024/03/27/iOS%E9%80%86%E5%90%91%E4%B8%8E%E5%AE%89%E5%85%A8%E5%BC%80%E7%AF%87%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="学习-iOS-逆向开发的前提"><a href="#学习-iOS-逆向开发的前提" class="headerlink" title="学习 iOS 逆向开发的前提"></a>学习 iOS 逆向开发的前提</h1><ul>
<li>有一定的正向开发经验（最起码对 iOS 系统的 UIKit 框架有一定的了解）</li>
<li>一台越狱的 iOS 设备（推荐至少是 64 位架构，iPhone 是从 iPhone 5s 开始，iPad 是从 iPad Air 和 iPad mini 2 开始）</li>
<li>一台 Mac 电脑，理论上来说 Linux 或 Windows 也可以（实际上作者没有实践过）</li>
<li>时间和恒心</li>
</ul>
<h1 id="什么是-iOS-逆向开发"><a href="#什么是-iOS-逆向开发" class="headerlink" title="什么是 iOS 逆向开发"></a>什么是 iOS 逆向开发</h1><p>很多 iOS 开发者可能都不是科班出身的程序员，所以对于逆向开发可能没有任何概念。实不相瞒，作者本人就是如此。工作多年后才慢慢接触并了解了逆向开发，逆向工程等相关的知识。</p>
<p>逆向开发（Reverse Engineering）是一种通过分析和研究已有软件或系统的内部结构、逻辑和功能，以理解其实现方式的技术。在软件开发中，逆向开发通常涉及反编译、反汇编或动态调试，以揭示目标程序的代码逻辑和功能。</p>
<p>iOS 逆向开发是指通过分析已有的 iOS 应用程序或 iOS 系统来理解其内部结构、行为以及工作原理的过程。与常规开发（从源代码构建应用程序）相反，逆向开发是在没有源代码的情况下，逆向分析编译后的二进制文件，研究应用的工作机制。</p>
<h1 id="学习-iOS-逆向开发有什么用"><a href="#学习-iOS-逆向开发有什么用" class="headerlink" title="学习 iOS 逆向开发有什么用"></a>学习 iOS 逆向开发有什么用</h1><ul>
<li><p><strong>应用分析与调试：</strong>使用工具来调试和分析应用程序，理解其功能实现。研究员常用 LLDB、Hopper、Ghidra 等工具来反汇编和反编译 iOS 应用，以了解代码的工作方式。</p>
</li>
<li><p><strong>破解和去除限制：</strong>通过逆向手段绕过某些应用的限制，如应用内购买、付费功能等。虽然这属于非法行为，但仍是逆向开发中不可忽视的一部分。</p>
</li>
<li><p><strong>安全性研究与漏洞发现：</strong>逆向开发在 iOS 安全研究中非常重要。通过逆向工程，安全研究人员可以分析应用的加密算法、安全协议等，寻找漏洞并提出防御措施。</p>
</li>
<li><p><strong>学习与模仿：</strong>开发者通过逆向分析成熟的应用来学习优秀的开发技巧，或者模仿某些功能。</p>
</li>
</ul>
<p>玩过 LOL 的老玩家应该还记得多年前某些辅助工具可以实现自己使用任意皮肤，这也是通过逆向开发做到的，属于 window 逆向方向的，而 iOS 平台的有移除 App 内的广告，绕过打卡类 App 的 Wi-Fi 限制，GPS 检测实现任意打卡，微信自动抢红包，还有游戏的外挂辅助软件也都是通过逆向开发实现的。。。这些都是正向开发做不到，或者不可能提供的。这些也正是逆向开发的用武之地。当然，学会了如何破解别人的 APP，自然也知道了该如何去防护自己的 APP，提高安全性，不会进攻谈什么安全防护呢。</p>
<p>以上这些功能，如果你听到了就感觉到很兴奋，那么恭喜你来对了地方！通过本门课程的学习，以上案例都有可能可以实现。不过还是需要提醒一下大家，一般来说逆向开发的难度相较于正向开发会更加困难，想要掌握逆向开发并不是一件容易的事情，需要持之以恒的学习。</p>
<h1 id="关于-iOS-开发人员的概念解释"><a href="#关于-iOS-开发人员的概念解释" class="headerlink" title="关于 iOS 开发人员的概念解释"></a>关于 iOS 开发人员的概念解释</h1><ol>
<li><p><strong>iOS 应用开发人员</strong></p>
<p> iOS 应用开发人员通常是指那些为 iOS 系统开发应用程序的人。他们主要使用苹果的开发工具和框架，比如 Xcode、Swift、Objective-C 等，目标是创建可以在苹果的 App Store 上发布的应用程序。这类开发人员的主要工作是围绕用户体验、界面设计、功能实现和优化应用性能。</p>
<p> 他们的主要任务包括：</p>
<ul>
<li>开发和维护 iPhone、iPad 上运行的应用程序</li>
<li>使用 iOS SDK（软件开发工具包）和相关的 API（如 UIKit、Core Data、ARKit 等）</li>
<li>与后端服务交互（通常使用 RESTful API 或 GraphQL）</li>
<li>解决与应用程序相关的性能和安全问题</li>
<li>测试和调试应用程序 <br></li>
</ul>
</li>
<li><p><strong>iOS 系统开发人员（越狱插件、底层开发等）</strong></p>
<p> 真正意义上的 iOS 开发人员更适合用于描述那些进行 iOS 系统级开发的人。这些开发人员深入到 iOS 系统的底层，做与操作系统本身相关的开发工作，比如修改系统行为、开发越狱插件、研究内核安全性或进行硬件驱动开发。</p>
<p> 他们的主要任务包括：</p>
<ul>
<li>研究 iOS 系统的底层结构和安全机制</li>
<li>开发越狱工具、插件（比如 Cydia 插件）</li>
<li>修改系统设置或行为，允许用户做出官方系统不允许的操作</li>
<li>逆向工程或研究系统漏洞</li>
<li>优化或修改内核（kernel）层的功能</li>
</ul>
</li>
</ol>
<p>市场上面招聘的 iOS 开发人员基本上都是指 iOS 应用开发人员。iOS 系统开发人员的岗位较少。但如果 iOS 应用开发人员具备逆向分析开发的能力则是一项优势。</p>
<h1 id="本书如何学习"><a href="#本书如何学习" class="headerlink" title="本书如何学习"></a>本书如何学习</h1><p>作者将以微信抢红包的实战项目出发，从 0 到 1 演示如何实现微信抢红包插件，实现插件过程中涉及到的技术和理论知识都会在后续的章节中详细介绍，对 iOS 逆向开发感兴趣的同学通过这个项目，可以迅速的建立对 iOS 逆向开发的整体认知。</p>
]]></content>
      <categories>
        <category>iOS 逆向与安全</category>
      </categories>
  </entry>
  <entry>
    <title>揭开神秘的iOS布局</title>
    <url>/2018/03/26/%E6%8F%AD%E7%A7%98iOS%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<p>翻译自: <a href="http://tech.gc.com/demystifying-ios-layout/">Demystifying iOS Layout</a></p>
<p>在你刚开始开发iOS应用时,最难避免或者说最难调试的是处理视图的布局和内容;通常这些事情的发生是因为对 <strong>视图更新</strong> 真实发生存在误解;了解 <strong>视图更新</strong> 的方式和时间需要更深入地了解iOS应用程序的主运行循环,以及它如何与<code>UIView</code>提供的某些方法关联;这篇博文将解释这些互动,希望澄清如何使用<code>UIView</code>的方法来获得你想要的行为;</p>
<h2 id="iOS应用程序的主运行循环"><a href="#iOS应用程序的主运行循环" class="headerlink" title="iOS应用程序的主运行循环"></a>iOS应用程序的主运行循环</h2><p>iOS应用程序的主运行循环用来处理所有用户输入事件并在您的应用程序中触发适当的响应;任何与应用程序的用户交互都会被添加到事件队列中;应用程序对象(如下图所示)将事件队列中的事件取出,并将它们分派给应用程序中的其他对象;<strong>它本质上是通过解释来自用户的输入事件并在应用程序的核心对象中为该输入调用相应的处理程序来执行运行循环</strong>;这些处理程序调用应用程序开发人员编写的代码;一旦这些方法调用返回,控制回到主运行循环并且开始更新周期;更新周期负责布局和重绘视图(在下一节中介绍);下面是应用程序如何与设备进行通信并处理用户输入的插图</p>
<p><img src="http://tech.gc.com/images/demystifying-ios-layout/main_event_loop.jpg" alt="Main Event Loop"></p>
<p><em><a href="https://developer.apple.com/library/content/documentation/General/Conceptual/Devpedia-CocoaApp/MainEventLoop.html">https://developer.apple.com/library/content/documentation/General/Conceptual/Devpedia-CocoaApp/MainEventLoop.html</a></em></p>
<h2 id="更新周期-Update-Cycle"><a href="#更新周期-Update-Cycle" class="headerlink" title="更新周期(Update Cycle)"></a>更新周期(Update Cycle)</h2><p>更新周期是应用程序完成运行所有事件处理代码后,控制权返回到主运行循环的点;就是在这个点,系统开始更新布局,显示和约束;如果您要求改变视图而它正在执行事件处理程序,系统会将此视图标记为需要重绘;在下一次更新周期,系统将执行这些视图上所有的变化;用户交互和布局更新之间的时间间隔对用户来说应该是感觉不到的;iOS应用程序通常以60fps动画,这意味着一个刷新周期只需要1&#x2F;60秒;由于这种情况发生的速度很快,用户不会注意到她与设备上的应用程序进行交互和看到内容和布局更新之间的UI的滞后;但是,由于事件被执行的时间和相应视图的重绘时间之间存在时间间隔,所以在运行循环过程中,视图可能不会按照您希望的方式更新;如果您有任何计算依赖视图最新的内容或布局,您有可能操作的是该视图的旧的内容或布局而不是最新的;了解运行循环,更新周期和某些的<code>UIView</code>方法能够帮助避免或者调试这类问题;</p>
<p>您可以在下图中看到更新周期在运行循环结束时如何发生<br><img src="http://tech.gc.com/images/demystifying-ios-layout/tech-blog-loop.png" alt="Update Cycle"></p>
<h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>视图的布局指的是它在屏幕上的大小和位置;每一个视图都有一个<code>frame</code>属性来描述它在父视图坐标系统中的位置以及它的大小;<code>UIView</code>提供了一些方法,可以让你通知系统一个视图的布局已经改变,同时为你提供了可以重写的方法,以便在重新计算视图的布局后定义要执行的操作</p>
<h3 id="layoutSubviews"><a href="#layoutSubviews" class="headerlink" title="layoutSubviews()"></a>layoutSubviews()</h3><p>这个<code>UIView</code>方法调整视图及其所有子视图的大小和位置;它给出当前视图和每个子视图的位置和大小;此方法很昂贵,因为它对视图的所有子视图起作用并调用其相应的<code>layoutSubviews</code>方法;系统会在任何需要重新计算视图的 frame 属性时调用此方法,因此当您想要设置 frame 属性指定视图位置和大小的时候您应该重写此方法;但是,当您的视图层次结构需要布局刷新时,您绝不应该显示的调用它;相反,在运行循环期间,您可以使用多种机制在不同点触发<code>layoutSubviews</code>调用,这比直接调用<code>layoutSubviews</code>方法要便宜的多;</p>
<p>当<code>layoutSubviews</code>方法完成时,将在拥有该视图的视图控制器中触发对<code>viewDidLayoutSubviews</code>的调用;<strong>由于<code>layoutSubviews</code>是更新视图布局后可靠调用的唯一方法,因此应该将任何取决于布局和大小的逻辑代码方法<code>viewDidLayoutSubviews</code>中,而不是放在<code>viewDidLoad</code>或<code>viewDidAppear</code>中</strong>;这是避免使用过时的布局或者位置变量的唯一方法。</p>
<h2 id="自动刷新触发器"><a href="#自动刷新触发器" class="headerlink" title="自动刷新触发器"></a>自动刷新触发器</h2><p>有多个事件会自动地将视图标记为布局已经改变,所以该视图的<code>layoutSubviews</code>方法将在下一次更新周期时被系统调用,不需要开发人员手动执行这个方法;</p>
<p>这些自动将视图标记为布局已经改变的方式有以下几种:</p>
<ul>
<li>改变视图的大小</li>
<li>添加子视图</li>
<li>用户滚动<code>UIScrollView</code>(<code>layoutSubviews</code>方法会被<code>UIScrollView</code>以及它的父视图调用)</li>
<li>用户旋转设备</li>
<li>更新视图的约束</li>
</ul>
<p>以上这些方式都告诉系统,视图的位置需要重新计算并且会自动导致最终的<code>layoutSubviews</code>方法的调用;当然,也有直接触发<code>layoutSubviews</code>方法调用的办法;</p>
<h3 id="setNeedsLayout"><a href="#setNeedsLayout" class="headerlink" title="setNeedsLayout()"></a>setNeedsLayout()</h3><p>触发<code>layoutSubviews</code>调用最省资源的方式就是在您的视图上调用<code>setNeedsLayout</code>方法;这将指示系统这个视图的布局需要重新计算;<code>setNeedsLayout</code>执行并立即返回,并且在返回之前并不实际更新视图;相反,视图将会在下一个更新周期(系统调用这些视图以及后续所有子视图的<code>layoutSubviews</code>方法)实际更新视图的布局;即使从<code>setNeedsLayout</code>返回后到视图被重新绘制布局之间有一段任意的时间间隔,但是这个延迟不会对用户造成影响,因为永远不会长到对界面造成卡顿;</p>
<h3 id="layoutIfNeeded"><a href="#layoutIfNeeded" class="headerlink" title="layoutIfNeeded()"></a>layoutIfNeeded()</h3><p><code>layoutIfNeeded</code>是<code>UIView</code>的另一个将会在不久后触发<code>layoutSubviews</code>调用的方法;与<code>setNeedsLayout</code>会让视图在下一个周期调用<code>layoutSubviews</code>更新视图不同,<code>layoutIfNeeded</code>会立即触发<code>layoutSubviews</code>方法调用,如果视图需要布局更新的话;如果你在调用<code>setNeedsLayout</code>方法或者触发上面描述的自动刷新触发器之后调用了<code>layoutIfNeeded</code>方法,<code>layoutSubviews</code>将会在视图上被调用;然而,如果你调用<code>layoutIfNeeded</code>之后没有动作指示系统视图需要重新刷新视图,那么<code>layoutSubviews</code>方法将不会被调用;<br>在一次运行循环中,两次调用视图的<code>layoutIfNeeded</code>方法之间,视图的布局并没有变化的话,那么第二次调用将不会触发<code>layoutSubviews</code>的调用;</p>
<p>与<code>setNeedsLayout</code>方法不同,使用<code>layoutIfNeeded</code>方法,布局和重绘会在函数返回之前立即发生改变(除非有正在运行中的动画);这个方法在你需要依赖新的布局而又无法等待视图的下次更新周期到来的时候特别有用;然而,除了这种情况外,你还是应该调用<code>setNeedsLayout</code>然后等待下次更新周期的到来,这样在每次运行循环中都只会更新一次布局;</p>
<p>动画更改约束时,此方法特别有用;您应该在动画的 block 开始之前调用一次<code>layoutIfNeeded</code>,以确保在动画开始之前通知所有的布局更新;配置新的约束,然后在动画 block 内,再次调用<code>layoutIfNeeded</code>以动画到最新的状态;</p>
<h2 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h2><p>视图的显示包含颜色,文本,图片和Core Graphics绘制等视图属性,但不包含它和它的子视图的大小和位置;和布局的方法类似,显示也有触发更新的方法,它们由系统在检测到更新时被自动调用,或者我们可以手动调用直接触发更新;</p>
<h3 id="draw"><a href="#draw" class="headerlink" title="draw(_:)"></a>draw(_:)</h3><p><code>UIView</code>的<code>draw</code>方法(Objective-C中的<code>drawRect</code>)对视图的显示内容的作用	就像 <code>layoutSubviews</code>方法对视图的位置和尺寸的作用;同<code>layoutSubviews</code>一样,你不应该在代码中直接调用<code>draw</code>方法,而应该在运行循环的不同点调用能触发<code>draw</code>方法调用的方法;然而,与<code>layoutSubviews</code>方法不同的是,<code>draw</code>方法不会触发后续子视图的调用;</p>
<h3 id="setNeedsDisplay"><a href="#setNeedsDisplay" class="headerlink" title="setNeedsDisplay()"></a>setNeedsDisplay()</h3><p>这个方法类似布局中的<code>setNeedsLayout</code>;它会给有显示内容更新的视图设置一个内部的标记之后返回,并不会真正的视图重绘;而是在接下来的更新周期中,系统会遍历所有已被标记的视图,调用它们的<code>draw</code>方法;如果你只想在下次更新时重绘部分的视图,你可以调用<code>setNeedsDisplay(_:)</code>(Objective-C中的<code>setNeedsDisplayInRect:</code>)方法,并把希望重绘的矩形部分传入参数;</p>
<p>大部分时候,在视图中更新任何 UI 组件都会通过自动设置内部的”显示内容更新”标记将视图标记为”dirty”的;导致在下一次更新周期中视图的内容就会重绘而不需要直接显示调用<code>setNeedsDisplay</code>;然而如果你有一个属性没有绑定到UI控件,但需要在属性值每次更新重绘视图,那么你可以实现该属性的<code>didSet</code>方法,并在里面调用<code>setNeedsDisplay</code>方法来触发视图的更新;</p>
<p>有时设置一个属性要求自定义绘制,这种情况下你需要重写<code>draw</code>方法;在下面的例子中,设置<code>numberOfPoints</code>会触发系统根据具体点数绘制不同的视图;在这个例子中,你需要在<code>draw</code>方法中实现自定义绘制,并在<code>numberOfPoints</code>的property observer里调用<code>setNeedsDisplay</code>;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class MyView: UIView &#123;</span><br><span class="line">	var numberOfPoints = 0 &#123;</span><br><span class="line">		didSet &#123;</span><br><span class="line">			setNeedsDisplay()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	override func draw(_ rect: CGRect) &#123;</span><br><span class="line">		switch numberOfPoints &#123;</span><br><span class="line">		case 0: </span><br><span class="line">			return</span><br><span class="line">		case 1: </span><br><span class="line">			drawPoint(rect)</span><br><span class="line">		case 2:</span><br><span class="line">			drawLine(rect)</span><br><span class="line">		case 3: </span><br><span class="line">			drawTriangle(rect)</span><br><span class="line">		case 4:</span><br><span class="line">			drawRectangle(rect)</span><br><span class="line">		case 5: </span><br><span class="line">			drawPentagon(rect)</span><br><span class="line">		default:</span><br><span class="line">			drawEllipse(rect)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>视图的显示方法里没有类似布局中的<code>layoutIfNeeded</code>这样可以触发立即更新的方法;通常情况下等到下一个更新周期再重新绘制视图也无所谓;</p>
<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>在自动布局技术中布局和重绘视图有三个步骤;第一步是更新约束,系统计算并设置视图上所有必需的约束条件;第二步是布局阶段,布局引擎计算视图和子视图的 frame 并且将它们布局;最后一步完成这一循环的是显示阶段;第三步完成此次循环的是显示阶段,如果有必要,那么通过调用视图的<code>draw</code>方法重绘视图的内容;</p>
<h3 id="updateConstraints"><a href="#updateConstraints" class="headerlink" title="updateConstraints()"></a>updateConstraints()</h3><p>这个方法用在自动布局中动态的改变视图的约束;和布局中的<code>layoutSubviews</code>方法和显示内容中的<code>draw</code>方法类似,<code>updateConstraints</code>只应该被重写,而不应该在你的代码中直接调用;一般来说,您应该在<code>updateConstraints</code>方法中仅仅实现必须要更新的约束;静态的约束应该设置在interface builder,视图的初始化方法(initializer)或者控制器的<code>viewDidLoad</code>中;</p>
<p>通常情况下,开启或者关闭约束,更改约束的优先级或者常量值,或者从视图层级中移除一个视图时都会设置一个内部的标记,这个标记将会在下一次更新周期触发<code>updateConstraints</code>方法调用;当然啦,也有手动的给视图打上需要更新约束的标记的方法,如下:</p>
<h3 id="setNeedsUpdateConstraints"><a href="#setNeedsUpdateConstraints" class="headerlink" title="setNeedsUpdateConstraints()"></a>setNeedsUpdateConstraints()</h3><p>调用<code>setNeedsUpdateConstraints</code>会保证在下一次的更新周期中更新约束;它通过标记视图的约束已更新来触发<code>updateConstraints</code>调用;这个方法和<code>setNeedsDisplay</code>,<code>setNeedsLayout</code>方法的工作机制类似;</p>
<h3 id="updateConstraintsIfNeeded"><a href="#updateConstraintsIfNeeded" class="headerlink" title="updateConstraintsIfNeeded()"></a>updateConstraintsIfNeeded()</h3><p>这个方法就等同于使用了自动布局的视图中的<code>layoutIfNeeded</code>方法;它会检查视图约束是否更新的标记(能够被自动设置,或者通过<code>setNeedsUpdateConstraints</code>设置,或者通过<code>invalidateInstrinsicContentSize</code>设置),如果它表明约束需要更新,它将立刻触发<code>updateConstraints</code>方法的调用而不需要等到运行循环的结束;</p>
<h3 id="invalidateIntrinsicContentSize"><a href="#invalidateIntrinsicContentSize" class="headerlink" title="invalidateIntrinsicContentSize()"></a>invalidateIntrinsicContentSize()</h3><p>一些使用自动布局的视图中会有一个<code>intrinsicContentSize</code>的属性,这是视图根据它的内容得到的自然尺寸;一个视图的<code>intrinsicContentSize</code>属性通常由所包含的元素的约束来决定,但是也可以通过重写来提供自定义的行为;调用<code>invalidateIntrinsicContentSize</code>会设置一个标记表示这个视图的<code>intrinsicContentSize</code>已经过期,需要在下一个布局阶段重新计算;</p>
<h2 id="它们是如何连接的"><a href="#它们是如何连接的" class="headerlink" title="它们是如何连接的"></a>它们是如何连接的</h2><p>视图的布局,显示以及约束都遵循着相似的模式,例如它们更新的方式以及如何在运行循环的不同点上强制更新;任意组件都有一个实际去更新的方法(<code>layoutSubviews</code>,<code>draw</code>,以及<code>updateConstraints</code>),你可以重写来手动操作视图,但是任何情况下都不要在你的代码中直接调用;这些方法仅仅在视图有标记,告诉系统视图的某些组件需要更新了,在主运行循环的后面被调用;有些操作会自动设置这个标志,也有一些方法能够让您手动的设置它;对于布局和约束的更新,如果您无法等到更新周期的到来(因为有些操作依赖最新的布局),有这么一些方法可以让你立即更新,并保证布局需要更新标记被正确标记;下面的表格列出了任意组件会怎样更新及其对应方法;</p>
<table>
<thead>
<tr>
<th>Method purposes</th>
<th>Layout</th>
<th>Display</th>
<th>Constraints</th>
</tr>
</thead>
<tbody><tr>
<td>Implement updates(override,don’t call explicitly)</td>
<td><code>layoutSubviews</code></td>
<td><code>draw</code></td>
<td><code>updateConstraints</code></td>
</tr>
<tr>
<td>Explicitly mark view as needing update on next update cycle</td>
<td><code>setNeedsLayout</code></td>
<td><code>setNeedsDisplay</code></td>
<td><code>setNeedsUpdateConstraints</code> <code>invalidateIntrinsicContentSize</code></td>
</tr>
<tr>
<td>Update iimmediately if view is marked as ‘dirty’</td>
<td><code>layoutIfNeeded</code></td>
<td></td>
<td><code>updateConstraintsIfNeeded</code></td>
</tr>
<tr>
<td>Actions that implicitly cause views to be updated</td>
<td><code>addSubview</code><br> Resizing视图,通过<code>setFrame</code>改变视图的<code>bounds</code>(不只是translation)<br>用户滑动UIScrollView<br>用户旋转设备</td>
<td>改变视图的<code>bounds</code></td>
<td>激活&#x2F;禁用约束<br>更改约束的值或者优先级<br>从视图层次结构中移除视图</td>
</tr>
</tbody></table>
<p>下面的流程图总结了<strong>更新周期</strong>和<strong>事件循环</strong>之间的交互,并指出了上文提到的方法在<strong>运行循环</strong>期间的位置;你可以在运行循环中的任意一点直接的调用<code>layoutIfNeeded</code>或者<code>updateConstraintsIfNeeded</code>,需要记住,这开销会很大;在循环的主运行循环的后面是更新周期,如果视图被设置特定的”需要更新约束”,”需要更新布局”或者”需要更新显示”的标记,在这个节点会进行更新约束,更新布局以及更新显示内容;一旦这些更新结束,主运行循环会重新开始;</p>
<p><img src="http://tech.gc.com/images/demystifying-ios-layout/update_cycle.png" alt="Update Cycle"><em><a href="https://i.stack.imgur.com/i9YuN.png">https://i.stack.imgur.com/i9YuN.png</a></em></p>
]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>微信抢红包插件</title>
    <url>/2024/04/10/%E5%BE%AE%E4%BF%A1%E6%8A%A2%E7%BA%A2%E5%8C%85%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<p>本篇文章将介绍如何从 0 到 1 一步步实现微信抢红包插件功能，需要用到</p>
<ul>
<li><p>一部能越狱的 iPhone，作者使用的 iOS12.5.7 的 5s。</p>
<p>   推荐使用 iOS15 之前的设备，因为 iOS15 <a href="https://theapplewiki.com/wiki/Signed_System_Volume">SSV</a> 的出现诞生了一种新的越狱方案 <a href="https://theapplewiki.com/wiki/Rootless">rootless</a>。导致很多以前能运行的越狱插件，工具都无法在 iOS15 及后续的系统上正常运行。因为这些工具大多都还没有针对 rootless 进行适配。使用 iOS15 之前的设备能够更完美的进行教学，和拥有更好的体验。当你学有所成的时候，可以尝试对那些暂时没有适配的越狱插件，工具自己进行适配了。这里特别说明一下，rootless 越狱并不是指越狱后没有 root 权限，而是 iOS15 SSV 的出现导致即使是 root 用户也无法往系统目录（如&#x2F;System和&#x2F;usr）写入文件，类似于 macOS 上的 SIP，所以诞生了 rootless 解决方案。</p>
<p>   如果你是 iOS15 及以上的设备，那么越狱也推荐选择 rootful 越狱而不是 rootless，同样还是因为 rootless 很多工具无法使用的原因，比如砸壳工具 frida-ios-dump 在 rootless 越狱设备下大部分 App 都无法砸壳成功。作为普通用户，你可以选择 rootless 越狱，但如果你是想进行逆向学习，还是更推荐使用 rootful 越狱。</p>
</li>
<li><p>一台 Mac 电脑，作者使用的系统是 14.5。</p>
<p>  理论上来说 Linux 或 Windows 也可以，因为 Theos 支持，但是作者没有亲自实践过。</p>
</li>
<li><p>使用终端输入命令行的基本知识。比如 cd 进入目录或删除文件</p>
<p>  其实最好是有 Linux 或者 Unix 系统的基础知识。毕竟 iOS 系统内核 XNU 就是 Unix 类的系统。这一点不算是必要条件吧，可以在过程中学习。</p>
</li>
</ul>
<p>只需要具备以上先决条件即使你不了解 iOS 应用逆向开发也能实现这个功能，感受逆向开发的乐趣。而对于懂编程，对 iOS 应用逆向开发感兴趣的同学则可以通过这个实战项目，迅速的建立对 iOS 应用逆向开发的整体认知。作者将以这一实战项目为根基，实现项目过程中涉及的技术点为枝叶，建立起 iOS 应用逆向开发的知识体系。</p>
<p>从 0 到 1 实现微信抢红包项目的步骤为：</p>
<ol>
<li><a href="#1">越狱 iPhone</a> <ul>
<li><a href="#2">什么是 iPhone 越狱</a></li>
<li><a href="#3">越狱的原理</a></li>
<li><a href="#4">越狱的主要目的</a></li>
<li><a href="#5">越狱后的注意事项</a></li>
<li><a href="#6">iOS 越狱的四种类型</a></li>
<li><a href="#7">包管理器</a></li>
<li><a href="#8">越狱后常用的软件包</a></li>
<li><a href="#9">iOS 如何判断设备是否越狱</a></li>
</ul>
</li>
<li><a href="#10">脱壳微信</a><ul>
<li><a href="#11">下载 frida-ios-dump 项目</a></li>
<li><a href="#12">手机安装 frida</a></li>
<li><a href="#13">安装 frida-ios-dump 的依赖库</a></li>
<li><a href="#14">进行端口转发</a></li>
<li><a href="#15">运行 dump.py 脚本 </a></li>
</ul>
</li>
<li><a href="#16">安装 Theos 创建抢红包 tweak 项目</a></li>
<li><a href="#17">实现抢红包插件的 UI 代码</a></li>
<li><a href="#18">实现抢红包插件的功能代码</a><ul>
<li><a href="#19">1.定位收到微信消息的方法</a></li>
<li><a href="#20">2.定位打开红包的方法</a></li>
<li><a href="#21">3.静态分析开红包的方法</a></li>
<li><a href="#22">最终代码</a></li>
</ul>
</li>
</ol>
<!--
编写 tweak 的过程中用到了。。。
3. 界面分析：分析微信设置界面，实现抢红包功能 UI 界面
    * Cycript
    * Revael
    * Lookin
    * lldb 
5. 静态分析代码：反编译可执行文件，分析微信获取消息流程代码，开红包逻辑
    * MachOView，class-dump，Hopper Disassembler，ida，ghidra 等
6. 动态调试代码
    * lldb+debugserver
7. 编写插件：将我们的代码注入到app中，必要时可能需要重新签名，打包 ipa
-->

<h1 id="越狱-iPhone"><a href="#越狱-iPhone" class="headerlink" title="越狱 iPhone"></a>越狱 iPhone</h1><p>这一步不是本篇文章的重点。因为有很多更好的越狱教程，推荐个<a href="https://ios.cfw.guide/">网站</a>，大家自己去看，选择手机实现越狱。如果对越狱比较熟悉的同学就可以直接跳过这一部分了。</p>
<p>综合考虑下来，目前 8，8plus，x 都是不错的选择，价格合适，性能够用，LCD 屏不怕长时间亮屏幕导致烧屏，且最高支持 iOS16.7.10 越狱，即使出现任何问题导致白苹果，也可以通过刷机恢复之后再次越狱。不会像后面新出的手机如果出现问题，只能更新到最新系统，结果无法越狱的尴尬。</p>
<p>但从学习逆向的角度来说，可能最高搭载 iOS12.5.7 的 iPhone 6&#x2F;6plus 是更合适的选择，一是它是 iOS15 以前的系统许多逆向相关的工具都能正常使用，二是同前面一样即使因为越狱出现了任何问题导致手机无法正常使用，也完全可以通过刷机之后重新越狱，可刷机可越狱的机型就是这么任性。</p>
<p>当然，如果你手中刚好有一台 iOS15 系统之前的 iPhone，也完全可以使用它进行逆向学习，毕竟因为越狱导致 iPhone<br>无法正常使用的情况还是蛮少的，实在不放心就将数据备份已备恢复。</p>
<p>其实越狱 iPhone 并不是逆向开发的必要条件，因为有 <a href="https://github.com/AloneMonkey/MonkeyDev">MonkeyDev</a> 的存在可以实现在未越狱的 iOS 设备上开发插件，但在未越狱设备上开发插件时总会存在一些不方便的情况。比如一些知名的 App 都做了 CFBundleIdentifier 的防护，MonkeyDev 重签名 App 之后修改了 CFBundleIdentifier 就会导致获取不到数据的情况出现就会影响开发，虽然也可以做一些绕过措施但依旧存在其他的问题。</p>
<h2 id="什么是-iPhone-越狱"><a href="#什么是-iPhone-越狱" class="headerlink" title="什么是 iPhone 越狱"></a>什么是 iPhone 越狱</h2><p>iPhone 越狱是指通过特定工具或方法绕过苹果公司对 iOS 操作系统的限制，获取更高权限的过程。这使用户能够访问和修改系统文件、安装非苹果 App Store 中的应用程序，以及对系统进行其他未被官方允许的更改。</p>
<h2 id="越狱的原理"><a href="#越狱的原理" class="headerlink" title="越狱的原理"></a>越狱的原理</h2><p>越狱的原理主要在于利用 iOS 系统中的安全漏洞，获取 root 权限，从而绕过 Apple 的限制，允许用户安装未经过认证的应用和进行系统级的修改。一些开源的越狱工具如 <a href="https://github.com/palera1n/palera1n">palera1n</a>，<a href="https://github.com/opa334/Dopamine">Dopamine</a> 就是通过利用公开的 iOS 系统漏洞来实现的。</p>
<p>公开的 iOS 系统漏洞有 CVE-2021-1782，CVE-2022-32917，CVE-2021-30955 等等，CVE（Common Vulnerabilities and Exposures）是一个公共数据库，用于标识和记录已知的安全漏洞和暴露。每个 CVE 条目都有一个唯一的标识符，格式为 CVE-年份-序号。具体含义如下：</p>
<ul>
<li><strong>CVE：</strong>代表“通用漏洞和曝光”。</li>
<li><strong>年份：</strong>指出该漏洞首次被记录或公开的年份。</li>
<li><strong>序号：</strong>在该年份中，为该漏洞分配的唯一数字。</li>
</ul>
<p>至于这些公开的 iOS 系统漏洞是如何发现和记录的，一般通过以下这几种方式：</p>
<ul>
<li><p><strong>安全研究人员：</strong>独立的安全专家和研究机构会对软件和系统进行审计和测试，发现漏洞后会将其报告给开发者，并在确认后提交 CVE 申请。</p>
</li>
<li><p><strong>开发者和厂商：</strong>软件开发者和公司在进行内部安全测试时，可能会发现漏洞，并会向 CVE 数据库提交这些信息。</p>
</li>
<li><p><strong>社区报告：</strong>开源软件社区和用户在使用软件时，可能会发现安全问题并进行报告。这些报告有时会引发更深入的安全审计。</p>
</li>
<li><p><strong>安全会议和黑客大会：</strong>在这些会议上，研究人员通常会展示他们的研究成果，包括新发现的漏洞，之后这些信息可能会被记录为 CVE。</p>
</li>
<li><p><strong>自动化工具：</strong>一些工具会扫描软件和系统以发现已知的漏洞，并将结果报告给开发者或安全机构。</p>
</li>
</ul>
<p>那么安全研究人员又是如何发现漏洞的呢？一般也就是通过逆向工程，对二进制文件进行反汇编之后，分析代码的内部工作原理，找出潜在的漏洞。安全研究人员的要求通常比一般的程序员更高，主要体现在以下几个方面：</p>
<ul>
<li><p><strong>深厚的安全知识：</strong>安全研究人员需要深入了解安全理论、漏洞类型、攻击向量以及防御机制。</p>
</li>
<li><p><strong>逆向工程能力：</strong>能够反汇编和分析二进制文件，理解底层实现，以发现潜在漏洞。</p>
</li>
<li><p><strong>熟悉网络协议：</strong>对网络安全、协议分析和加密技术有深入理解，以识别网络层面的安全问题。</p>
</li>
<li><p><strong>编程能力：</strong>熟悉多种编程语言，能够编写自动化工具或脚本来测试和分析系统。</p>
</li>
<li><p><strong>持续学习：</strong>安全领域不断变化，研究人员需要跟上最新的安全威胁和防护措施，参与安全社区的讨论和研究。</p>
</li>
<li><p><strong>问题解决能力：</strong>能够分析复杂问题，进行创新性思考，以找到漏洞或制定有效的安全策略。</p>
</li>
</ul>
<h2 id="越狱的主要目的"><a href="#越狱的主要目的" class="headerlink" title="越狱的主要目的"></a>越狱的主要目的</h2><ol>
<li><strong>安装非官方应用：</strong> 越狱允许用户安装苹果官方 App Store 外的应用程序和插件。</li>
<li><strong>自定义界面：</strong> 用户可以通过越狱自定义 iOS 设备的界面和功能，如主题、图标等。</li>
<li><strong>增强功能：</strong> 可以使用各种增强功能的插件和工具，如系统优化、功能扩展等。</li>
<li><strong>完全的访问 iOS 文件系统：</strong> 越狱之后的 iOS 设备可以完全访问它的文件系统。</li>
<li><strong>提供逆向开发的环境：</strong> 越狱之后的 iOS 设备可以更方便的进行逆向开发。</li>
</ol>
<h2 id="越狱后的注意事项"><a href="#越狱后的注意事项" class="headerlink" title="越狱后的注意事项"></a>越狱后的注意事项</h2><ol>
<li>安全风险：<ul>
<li><strong>恶意软件和病毒：</strong>越狱解除了一些系统安全限制，非官方来源的应用可能包含恶意代码，增加设备感染恶意软件的风险。所以要谨慎安装不知名的插件。</li>
<li><strong>系统漏洞：</strong>越狱会使设备暴露于更大的安全漏洞中，黑客可以利用这些漏洞攻击设备。</li>
<li><strong>App 沙盒机制可能被绕过：</strong>虽然越狱不会直接破坏沙盒，但有的恶意插件可能试图绕过应用的沙盒保护，获取不应有的数据访问权限。</li>
</ul>
</li>
<li>系统稳定性降低：<ul>
<li><strong>崩溃和异常：</strong>越狱后安装的某些第三方插件和应用可能与系统不兼容，导致应用崩溃或系统不稳定，甚至出现无法启动的问题。</li>
<li><strong>电池续航缩短：</strong>某些越狱插件可能在后台耗电增加，导致设备电池续航能力下降。</li>
</ul>
</li>
<li>设备保修失效：<ul>
<li><strong>失去官方支持：</strong>苹果公司规定，越狱设备不再享有官方保修服务。如果越狱导致设备问题，官方可能拒绝维修。</li>
</ul>
</li>
<li>应用兼容性问题：<ul>
<li><strong>应用检测越狱：</strong>某些应用（如金融类、支付类、游戏类应用）可能会检测越狱状态，并拒绝在越狱设备上运行。</li>
</ul>
</li>
</ol>
<h2 id="iOS-越狱的四种类型"><a href="#iOS-越狱的四种类型" class="headerlink" title="iOS 越狱的四种类型"></a>iOS 越狱的四种类型</h2><p>有以下四种不同类型的越狱，每种类型取决于它与计算机的独立程度。</p>
<ul>
<li><p><strong>Untethered Jailbreaks 不受限制的越狱</strong></p>
<p>  不受限制的越狱可以被认为是所有越狱的圣杯。他们只需要通过网站、应用程序或计算机运行一次漏洞利用程序。之后，您的设备已完全越狱，不需要任何进一步的操作。即使您重新启动设备后，该漏洞仍将保留在设备上。</p>
<p>  不幸的是，已经很长一段时间没有为最终用户提供新的不受限制的越狱了，而且我们很可能以后都不会看到这样的越狱了。不受限制的越狱的唯一缺点是，如果出现问题，很可能会导致引导循环，要求您通过 iTunes 或 Finder（macOS Catalina 或更高版本）恢复设备。这种情况发生的可能性很低，但确实有可能。</p>
</li>
<li><p><strong>Semi-Untethered Jailbreaks 半不受限制的越狱</strong></p>
<p>  半自由越狱是近这些年来最流行的越狱类型。这种类型的越狱需要在每次重新启动或关闭 iOS 设备时执行漏洞利用。大部分是通过 iOS 设备上的应用程序或者网站运行漏洞。</p>
</li>
<li><p><strong>Semi-Tethered Jailbreaks 半受限制的越狱</strong></p>
<p>  半受限制的越狱与半不受限制的越狱非常相似，但是该漏洞必须使用计算机运行，而不是使用侧载应用程序。由于在每次重新启动 iOS 设备后需要计算机才能重新越狱，因此大多数人选择使用半不受限制的越狱。</p>
</li>
<li><p><strong>Tethered Jailbreaks 受限制的越狱</strong></p>
<p>  受限制的越狱并不适合公众使用。这些漏洞会修改设备，甚至即使没有越狱也需要 PC 才能启动。因此，这些往往只被为新版 iOS 做好准备的越狱开发人员使用。</p>
</li>
</ul>
<h2 id="包管理器"><a href="#包管理器" class="headerlink" title="包管理器"></a>包管理器</h2><p>在 iOS 设备未越狱时，我们只能通过 App Store 或爱思，沙漏这样的第三方平台下载安装应用程序。而越狱之后，我们不仅同样可以使用上面的方式下载安装应用程序，还可以通过像 Cydia，Sileo，等一些包管理器来安装 tweak，应用程序，命令行程序等其他软件。默认情况下，不同的越狱程序与不同的包管理器捆绑在一起，但目前最受欢迎的是 Sileo。</p>
<h3 id="Sileo"><a href="#Sileo" class="headerlink" title="Sileo"></a>Sileo</h3><p>Sileo 是 <a href="https://x.com/elihwyma">Amy</a> 为 iOS 11 及更高版本维护的包管理器。 Sileo 以其基于 Swift 的设计、快速性能和总体质量改进（例如适当的 iPad 支持）而自豪。</p>
<p>Sileo 默认安装在 Electra、Chimera、Odyssey、Taurine 和 Odysseyra1n 上。 Sileo 还可以在 iOS 12.0 及更高版本上通过 checkra1n 以及 unc0ver 下载。</p>
<h3 id="Cydia"><a href="#Cydia" class="headerlink" title="Cydia"></a>Cydia</h3><p>Cydia 是一个包管理器，长期以来被认为是越狱的代表，以前是大多数越狱的首选包管理器。Cydia 的原始创建者 Saurik 已停止维护该项目，但近年来 Sam Bingner 更新了适用于现代设备和 iOS 版本的软件。</p>
<p>关于包管理器的使用，这里不做更深入的介绍了，网上有很多介绍。</p>
<blockquote>
<p>在使用包管理器安装某些应用程序之后，包管理器有时会提示我们重启 SpringBoard 。</p>
<p>SpringBoard 是 iOS 的主屏幕应用程序，管理图标、壁纸、通知等元素，就是我们接触最多的 iOS 桌面。Apple 官方有专门的岗位 iOS SpringBoard Engineer 用于开发和维护 SpringBoard 。</p>
</blockquote>
<h2 id="越狱后常用的软件包"><a href="#越狱后常用的软件包" class="headerlink" title="越狱后常用的软件包"></a>越狱后常用的软件包</h2><ul>
<li><p><strong>Apple File Conduit “2”：</strong> </p>
<p>  简称 AFC2，是一款在越狱后的 iOS 设备上使用的工具，它扩展了默认的 Apple File Conduit 服务，使得用户可以通过 USB 连接访问 iOS 文件系统中的完整内容。通常情况下，非越狱设备的文件系统只能通过 AFC 协议访问有限的部分，而 AFC2 则允许用户访问系统的根目录及其他受限制的区域。Mac 使用如 iFunBox、iExplorer、3uTools 等工具配合 AFC2 实现对越狱设备文件系统的完整访问。</p>
</li>
<li><p><strong>AppSync Unified：</strong> </p>
<p>  它允许用户在设备上安装、管理和运行非官方签名的应用程序。这类应用通常包括未通过苹果审核的应用、已修改的应用、以及自行编译或未经 App Store 发布的应用。AppSync Unified 通过补丁系统文件，绕过了 iOS 的应用签名限制。</p>
</li>
<li><p><strong>Filza File Manager：</strong> </p>
<p>  是一款功能强大的文件管理器，专为越狱后的 iOS 设备设计。它允许用户在设备上直接浏览、管理和编辑文件系统的内容。Filza 提供了与桌面操作系统文件管理器类似的体验，让用户可以轻松访问和操作 iOS 设备上的所有文件，包括系统文件和应用数据。</p>
</li>
<li><p><strong><a href="../openssh/openssh.md">OpenSSH</a></strong> </p>
<p>  是一个开源的 SSH 实现，它提供服务器的功能，用于安全远程登录、命令执行和文件传输。iOS 安装之后可以我们可以使用 Mac 远程登录到设备上。</p>
</li>
</ul>
<blockquote>
<p>如果遇到包管理器下载安装某些软件包失败的情况，可以手动安装软件包。</p>
</blockquote>
<p>如果你已经下载了 .deb 文件（iOS 软件包的格式），可以通过以下步骤在 Sileo 中进行本地安装：</p>
<ol>
<li><strong>将 .deb 文件传输到设备上：</strong>你可以使用文件管理工具或其他方法将 .deb 文件传输到你的 iOS 设备上，比如使用文件传输工具或通过越狱后的文件系统。</li>
<li><strong>使用文件管理工具访问文件：</strong>在设备上打开你用来管理文件的工具（例如 Filza File Manager）。</li>
<li><strong>找到 .deb 文件：</strong>浏览到存储 .deb 文件的目录。</li>
<li><strong>使用 Sileo 安装：</strong>在文件管理工具中找到 .deb 文件，点击它，通常会弹出一个选项，允许你选择使用 Sileo 或其他包管理工具进行安装。</li>
<li><strong>确认安装：</strong>选择 Sileo 进行安装，Sileo 将会处理包的安装过程。</li>
</ol>
<h2 id="iOS-如何判断设备是否越狱"><a href="#iOS-如何判断设备是否越狱" class="headerlink" title="iOS 如何判断设备是否越狱"></a>iOS 如何判断设备是否越狱</h2><p>iOS 可以通过多种方法来检测设备是否越狱，主要是利用越狱后系统的某些变化和越狱工具的行为。以下是常见的越狱检测方法：</p>
<h3 id="检查系统文件的存在"><a href="#检查系统文件的存在" class="headerlink" title="检查系统文件的存在"></a>检查系统文件的存在</h3><p>越狱后，一些特定的文件和目录可能会存在，正常情况下这些文件不应该存在。例如：</p>
<ul>
<li><strong>Cydia 应用的路径：</strong>&#x2F;Applications&#x2F;Cydia.app，如果这个路径存在，说明设备很可能已经越狱。</li>
<li><strong>其他越狱工具的路径：</strong>比如 Sileo.app 或者 Zebra.app。</li>
</ul>
<p>常用代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ([[<span class="built_in">NSFileManager</span> defaultManager] fileExistsAtPath:<span class="string">@&quot;/Applications/Cydia.app&quot;</span>] ||</span><br><span class="line">    [[<span class="built_in">NSFileManager</span> defaultManager] fileExistsAtPath:<span class="string">@&quot;/Library/MobileSubstrate/MobileSubstrate.dylib&quot;</span>] ||</span><br><span class="line">    [[<span class="built_in">NSFileManager</span> defaultManager] fileExistsAtPath:<span class="string">@&quot;/usr/sbin/sshd&quot;</span>] ||</span><br><span class="line">    [[<span class="built_in">NSFileManager</span> defaultManager] fileExistsAtPath:<span class="string">@&quot;/etc/apt&quot;</span>]) &#123;</span><br><span class="line">    <span class="comment">// 设备已经越狱</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这种方式存在一个问题，即曾经越狱过的设备可能在系统中留下了这些文件，但后续升级了 iOS 之后失去了越狱状态就会导致明明是未越狱设备却被判定为越狱设备。</p>
<h3 id="检查是否能够访问系统的根目录"><a href="#检查是否能够访问系统的根目录" class="headerlink" title="检查是否能够访问系统的根目录"></a>检查是否能够访问系统的根目录</h3><p>越狱后，某些应用会获得更高权限，可以访问系统的根目录。因此，通过尝试在 &#x2F;private 目录下写入文件，可以判断设备是否越狱：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSError</span> *error;</span><br><span class="line"><span class="built_in">NSString</span> *testWrite = <span class="string">@&quot;/private/jailbreak_test.txt&quot;</span>;</span><br><span class="line">[<span class="string">@&quot;Jailbreak Test&quot;</span> writeToFile:testWrite atomically:<span class="literal">YES</span> encoding:<span class="built_in">NSUTF8StringEncoding</span> error:&amp;error];</span><br><span class="line"><span class="keyword">if</span> (error == <span class="literal">nil</span>) &#123;</span><br><span class="line">    <span class="comment">// 设备已越狱</span></span><br><span class="line">    [[<span class="built_in">NSFileManager</span> defaultManager] removeItemAtPath:testWrite error:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="检查是否可以调用-fork-函数"><a href="#检查是否可以调用-fork-函数" class="headerlink" title="检查是否可以调用 fork() 函数"></a>检查是否可以调用 fork() 函数</h3><p>iOS 设备在非越狱环境下不允许创建子进程，而越狱设备可以使用 fork() 函数来创建子进程。通过检查是否可以成功调用 fork()，可以判断设备是否越狱：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 设备已越狱</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="检测越狱工具的存在"><a href="#检测越狱工具的存在" class="headerlink" title="检测越狱工具的存在"></a>检测越狱工具的存在</h3><p>有些应用会检查常见的越狱工具，如 Cydia 或 Sileo 是否能够被打开：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ([[<span class="built_in">UIApplication</span> sharedApplication] canOpenURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@&quot;cydia://&quot;</span>]]) &#123;</span><br><span class="line">    <span class="comment">// 设备已越狱</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="检查动态库注入"><a href="#检查动态库注入" class="headerlink" title="检查动态库注入"></a>检查动态库注入</h3><p>越狱通常会引入一些动态库来修改系统行为。可以通过查看运行时的动态库是否有常见的越狱库，例如 MobileSubstrate:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> dyld_count = _dyld_image_count();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dyld_count; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(_dyld_get_image_name(i), <span class="string">&quot;MobileSubstrate&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 设备已越狱</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="脱壳微信"><a href="#脱壳微信" class="headerlink" title="脱壳微信"></a>脱壳微信</h1><p>对一个应用程序进行逆向分析之前，首先需要对其进行脱壳操作。至于什么是壳，请看 <a href="../binary_dumping/binary_dumping.md">iOS 应用脱壳</a></p>
<p>在 iOS12.5.7 上脱壳微信的方法有很多，这里只介绍 frida-ios-dump，要想成功脱壳还需要不少的配置和步骤。简单点来说就是使用 frida-ios-dump 需要用到 frida 等第三方库，而安装 frida 又需要用到其他的库，所以导致可能不会一次性就能成功运行脱壳。加上每个人的电脑环境不同，可能出现的问题千奇百怪，这里就记录作者本人使用过程中遇到的问题和解决的办法。</p>
<h3 id="1-手机安装-frida"><a href="#1-手机安装-frida" class="headerlink" title="1.手机安装 frida"></a>1.手机安装 frida</h3><p>在 cydia&#x2F;sileo 上添加源 <a href="https://build.frida.re/">https://build.frida.re</a>，点击 frida 安装就好了。可以参考<a href="https://frida.re/docs/ios/#with-jailbreak">官方文档</a> </p>
<h3 id="2-Mac下载-frida-ios-dump-项目"><a href="#2-Mac下载-frida-ios-dump-项目" class="headerlink" title="2.Mac下载 frida-ios-dump 项目"></a>2.Mac下载 <a href="https://github.com/AloneMonkey/frida-ios-dump">frida-ios-dump</a> 项目</h3><p>这一步是最简单的，大家都是程序员的话应该不用多说了吧。在终端输入以下命令下载：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/AloneMonkey/frida-ios-dump.git</span><br></pre></td></tr></table></figure>

<h3 id="3-安装-frida-ios-dump-的依赖库"><a href="#3-安装-frida-ios-dump-的依赖库" class="headerlink" title="3.安装 frida-ios-dump 的依赖库"></a>3.安装 frida-ios-dump 的依赖库</h3><p>按照 frida-ios-dump 的文档执行 <code>sudo pip install -r requirements.txt --upgrade</code> 的时候，出现了以下错误：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> ~/frida-ios-dump/ [master*] <span class="built_in">sudo</span> pip install -r requirements.txt --upgrade</span><br><span class="line">Password:</span><br><span class="line"><span class="built_in">sudo</span>: pip: <span class="built_in">command</span> not found</span><br></pre></td></tr></table></figure>

<p>这个问题好解决，由于作者是用 brew 安装的 python3，可以使用它附带的 pip3。所以修改为 pip3 就好了。输入 <code>sudo pip3 install -r requirements.txt --upgrade</code>，还是出错了：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> ~/frida-ios-dump/ [master*] <span class="built_in">sudo</span> pip3 install -r requirements.txt --upgrade</span><br><span class="line">WARNING: The directory <span class="string">&#x27;/Users/franky/Library/Caches/pip&#x27;</span> or its parent directory is not owned or is not writable by the current user. The cache has been disabled. Check the permissions and owner of that directory. If executing pip with <span class="built_in">sudo</span>, you should use <span class="built_in">sudo</span><span class="string">&#x27;s -H flag.</span></span><br><span class="line"><span class="string">error: externally-managed-environment</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">× This environment is externally managed</span></span><br><span class="line"><span class="string">╰─&gt; To install Python packages system-wide, try brew install</span></span><br><span class="line"><span class="string">    xyz, where xyz is the package you are trying to</span></span><br><span class="line"><span class="string">    install.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If you wish to install a Python library that isn&#x27;</span>t <span class="keyword">in</span> Homebrew,</span><br><span class="line">    use a virtual environment:</span><br><span class="line"></span><br><span class="line">    python3 -m venv path/to/venv</span><br><span class="line">    <span class="built_in">source</span> path/to/venv/bin/activate</span><br><span class="line">    python3 -m pip install xyz</span><br><span class="line"></span><br><span class="line">    If you wish to install a Python application that isn<span class="string">&#x27;t in Homebrew,</span></span><br><span class="line"><span class="string">    it may be easiest to use &#x27;</span>pipx install xyz<span class="string">&#x27;, which will manage a</span></span><br><span class="line"><span class="string">    virtual environment for you. You can install pipx with</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    brew install pipx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    You may restore the old behavior of pip by passing</span></span><br><span class="line"><span class="string">    the &#x27;</span>--break-system-packages<span class="string">&#x27; flag to pip, or by adding</span></span><br><span class="line"><span class="string">    &#x27;</span>break-system-packages = <span class="literal">true</span><span class="string">&#x27; to your pip.conf file. The latter</span></span><br><span class="line"><span class="string">    will permanently disable this error.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If you disable this error, we STRONGLY recommend that you additionally</span></span><br><span class="line"><span class="string">    pass the &#x27;</span>--user<span class="string">&#x27; flag to pip, or set &#x27;</span>user = <span class="literal">true</span><span class="string">&#x27; in your pip.conf</span></span><br><span class="line"><span class="string">    file. Failure to do this can result in a broken Homebrew installation.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Read more about this behavior here: &lt;https://peps.python.org/pep-0668/&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">note: If you believe this is a mistake, please contact your Python installation or OS distribution provider. You can override this, at the risk of breaking your Python installation or OS, by passing --break-system-packages.</span></span><br><span class="line"><span class="string">hint: See PEP 668 for the detailed specification.</span></span><br></pre></td></tr></table></figure>

<p>好在给出的提示足够多，解决方法也有。于是按照提示使用 python 虚拟环境。这个虚拟环境一开始给我的感觉很懵逼。但实际的做法就是在项目的目录下新建一个文件夹用于存放 python 相关的资源，这样不影响系统的 python 环境。按照提示输入以下命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> ~/frida-ios-dump/ [master] python3 -m venv path/to/venv</span><br><span class="line"> ~/frida-ios-dump/ [master] <span class="built_in">source</span> path/to/venv/bin/activate</span><br><span class="line">(venv)  ~/frida-ios-dump/ [master] pip3 install -r requirements.txt --upgrade</span><br><span class="line">Collecting asn1crypto (from -r requirements.txt (line 1))</span><br><span class="line">  Using cached asn1crypto-1.5.1-py2.py3-none-any.whl.metadata (13 kB)</span><br><span class="line">Collecting bcrypt (from -r requirements.txt (line 2))</span><br><span class="line">  Using cached bcrypt-4.2.0-cp39-abi3-macosx_10_12_universal2.whl.metadata (9.6 kB)</span><br><span class="line">Collecting cffi (from -r requirements.txt (line 3))</span><br><span class="line">  Using cached cffi-1.17.1-cp312-cp312-macosx_10_9_x86_64.whl.metadata (1.5 kB)</span><br><span class="line">Collecting colorama (from -r requirements.txt (line 4))</span><br><span class="line">  Using cached colorama-0.4.6-py2.py3-none-any.whl.metadata (17 kB)</span><br><span class="line">Collecting cryptography (from -r requirements.txt (line 5))</span><br><span class="line">  Using cached cryptography-43.0.1-cp39-abi3-macosx_10_9_universal2.whl.metadata (5.4 kB)</span><br><span class="line">Collecting enum34 (from -r requirements.txt (line 6))</span><br><span class="line">  Using cached enum34-1.1.10-py3-none-any.whl.metadata (1.6 kB)</span><br><span class="line">Collecting frida-tools (from -r requirements.txt (line 7))</span><br><span class="line">  Using cached frida_tools-13.3.0-py3-none-any.whl</span><br><span class="line">Collecting idna (from -r requirements.txt (line 8))</span><br><span class="line">  Using cached idna-3.10-py3-none-any.whl.metadata (10 kB)</span><br><span class="line">Collecting ipaddress (from -r requirements.txt (line 9))</span><br><span class="line">  Using cached ipaddress-1.0.23-py2.py3-none-any.whl.metadata (923 bytes)</span><br><span class="line">Collecting paramiko (from -r requirements.txt (line 10))</span><br><span class="line">  Using cached paramiko-3.5.0-py3-none-any.whl.metadata (4.4 kB)</span><br><span class="line">Collecting prompt-toolkit (from -r requirements.txt (line 11))</span><br><span class="line">  Using cached prompt_toolkit-3.0.48-py3-none-any.whl.metadata (6.4 kB)</span><br><span class="line">Collecting pyasn1 (from -r requirements.txt (line 12))</span><br><span class="line">  Using cached pyasn1-0.6.1-py3-none-any.whl.metadata (8.4 kB)</span><br><span class="line">Collecting pycparser (from -r requirements.txt (line 13))</span><br><span class="line">  Using cached pycparser-2.22-py3-none-any.whl.metadata (943 bytes)</span><br><span class="line">Collecting Pygments (from -r requirements.txt (line 14))</span><br><span class="line">  Using cached pygments-2.18.0-py3-none-any.whl.metadata (2.5 kB)</span><br><span class="line">Collecting PyNaCl (from -r requirements.txt (line 15))</span><br><span class="line">  Using cached PyNaCl-1.5.0-cp36-abi3-macosx_10_10_universal2.whl.metadata (8.7 kB)</span><br><span class="line">Collecting scp (from -r requirements.txt (line 16))</span><br><span class="line">  Using cached scp-0.15.0-py2.py3-none-any.whl.metadata (4.3 kB)</span><br><span class="line">Collecting six (from -r requirements.txt (line 17))</span><br><span class="line">  Using cached six-1.16.0-py2.py3-none-any.whl.metadata (1.8 kB)</span><br><span class="line">Collecting tqdm (from -r requirements.txt (line 18))</span><br><span class="line">  Using cached tqdm-4.66.5-py3-none-any.whl.metadata (57 kB)</span><br><span class="line">Collecting wcwidth (from -r requirements.txt (line 19))</span><br><span class="line">  Using cached wcwidth-0.2.13-py2.py3-none-any.whl.metadata (14 kB)</span><br><span class="line">Collecting frida&lt;17.0.0,&gt;=16.2.2 (from frida-tools-&gt;-r requirements.txt (line 7))</span><br><span class="line">  Using cached frida-16.5.5-cp37-abi3-macosx_10_13_x86_64.whl.metadata (2.0 kB)</span><br><span class="line">Collecting websockets&lt;14.0.0,&gt;=13.0.0 (from frida-tools-&gt;-r requirements.txt (line 7))</span><br><span class="line">  Using cached websockets-13.1-cp312-cp312-macosx_10_9_x86_64.whl.metadata (6.8 kB)</span><br><span class="line">Using cached asn1crypto-1.5.1-py2.py3-none-any.whl (105 kB)</span><br><span class="line">Using cached bcrypt-4.2.0-cp39-abi3-macosx_10_12_universal2.whl (472 kB)</span><br><span class="line">Using cached cffi-1.17.1-cp312-cp312-macosx_10_9_x86_64.whl (183 kB)</span><br><span class="line">Using cached colorama-0.4.6-py2.py3-none-any.whl (25 kB)</span><br><span class="line">Using cached cryptography-43.0.1-cp39-abi3-macosx_10_9_universal2.whl (6.2 MB)</span><br><span class="line">Using cached enum34-1.1.10-py3-none-any.whl (11 kB)</span><br><span class="line">Using cached idna-3.10-py3-none-any.whl (70 kB)</span><br><span class="line">Using cached ipaddress-1.0.23-py2.py3-none-any.whl (18 kB)</span><br><span class="line">Using cached paramiko-3.5.0-py3-none-any.whl (227 kB)</span><br><span class="line">Using cached prompt_toolkit-3.0.48-py3-none-any.whl (386 kB)</span><br><span class="line">Using cached pyasn1-0.6.1-py3-none-any.whl (83 kB)</span><br><span class="line">Using cached pycparser-2.22-py3-none-any.whl (117 kB)</span><br><span class="line">Using cached pygments-2.18.0-py3-none-any.whl (1.2 MB)</span><br><span class="line">Using cached PyNaCl-1.5.0-cp36-abi3-macosx_10_10_universal2.whl (349 kB)</span><br><span class="line">Using cached scp-0.15.0-py2.py3-none-any.whl (8.8 kB)</span><br><span class="line">Using cached six-1.16.0-py2.py3-none-any.whl (11 kB)</span><br><span class="line">Using cached tqdm-4.66.5-py3-none-any.whl (78 kB)</span><br><span class="line">Using cached wcwidth-0.2.13-py2.py3-none-any.whl (34 kB)</span><br><span class="line">Using cached frida-16.5.5-cp37-abi3-macosx_10_13_x86_64.whl (16.7 MB)</span><br><span class="line">Using cached websockets-13.1-cp312-cp312-macosx_10_9_x86_64.whl (155 kB)</span><br><span class="line">Installing collected packages: wcwidth, ipaddress, enum34, asn1crypto, websockets, tqdm, six, Pygments, pycparser, pyasn1, prompt-toolkit, idna, frida, colorama, bcrypt, frida-tools, cffi, PyNaCl, cryptography, paramiko, scp</span><br><span class="line">Successfully installed PyNaCl-1.5.0 Pygments-2.18.0 asn1crypto-1.5.1 bcrypt-4.2.0 cffi-1.17.1 colorama-0.4.6 cryptography-43.0.1 enum34-1.1.10 frida-16.5.5 frida-tools-13.3.0 idna-3.10 ipaddress-1.0.23 paramiko-3.5.0 prompt-toolkit-3.0.48 pyasn1-0.6.1 pycparser-2.22 scp-0.15.0 six-1.16.0 tqdm-4.66.5 wcwidth-0.2.13 websockets-13.1</span><br></pre></td></tr></table></figure>

<p>可以看到成功安装了 frida。可以使用 <code>pip3 list</code> 查看 frida 的版本号。确保 frida 的版本号和手机上的 frida 是同个版本。</p>
<h3 id="4-进行端口转发"><a href="#4-进行端口转发" class="headerlink" title="4.进行端口转发"></a>4.进行端口转发</h3><p>使用 frida-ios-dump 的前提是你的越狱设备安装并配置好了 <a href="../openssh/openssh.md">OpenSSH</a> 免密码登录。这可以看我之前写过的文章。</p>
<p>使用 iproxy 进行端口转发，<code>iproxy 2222:22</code> 通过 USB 将电脑上的 2222 端口和手机的 22 端口建立映射。这一步基本没什么问题。<code>iproxy</code> 是 <code>libimobiledevice</code> 工具集的一部分，所以通过 <code>brew</code> 安装 <code>libimobiledevice</code> 获得 <code>iproxy</code>。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">brew install libimobiledevice</span><br></pre></td></tr></table></figure>

<p>然后在终端新开一个窗口运行 <code>iproxy 2222:22</code>，之后这个终端窗口就不接受用户输入，无法交互了，但不要关闭它，因为它一直在工作中。。。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> ~/ iproxy 2222:22</span><br><span class="line">Creating listening port 2222 <span class="keyword">for</span> device port 22</span><br><span class="line">waiting <span class="keyword">for</span> connection</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h3 id="5-运行-dump-py-脚本"><a href="#5-运行-dump-py-脚本" class="headerlink" title="5.运行 dump.py 脚本"></a>5.运行 dump.py 脚本</h3><p>在运行 dump.py 脚本之前，我们可能还需要对它进行一些修改。打开 dump.py 文件，找到下面配置，在文件的 40-43 行。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">User = <span class="string">&#x27;root&#x27;</span></span><br><span class="line">Password = <span class="string">&#x27;alpine&#x27;</span></span><br><span class="line">Host = <span class="string">&#x27;localhost&#x27;</span></span><br><span class="line">Port = <span class="number">2222</span></span><br><span class="line">KeyFileName = <span class="literal">None</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这里的密码，是你在越狱 iPhone 之后设置的密码，如果是老旧的 iOS12 越狱可能是默认的密码 alpine。如果是新一点的版本如 iOS16，则是你越狱后安装 Sileo 时设置的密码，或者后续手动设置的密码。Host 设置为 localhost，是因为我们进行了 USB 端口转发，通过 USB 连接手机，就可以实现访问电脑的 2222 端口相当于访问了手机的 22 端口。</p>
<p>修改好以上配置之后使用命令 <code>python3 dump.py -l</code> 可以列举越狱设备上可砸壳的应用程序。然后输入以下命令 <code>python3 dump.py 微信</code> 运行，就可以看到终端脱壳的过程了。如果终端没有反应，可以手动打开 微信 app。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(venv)  ~/frida-ios-dump/ [master*] python3 dump.py 微信</span><br><span class="line">Start the target app 微信</span><br><span class="line">attach pid : 18956</span><br><span class="line">Dumping 微信 to /var/folders/rt/zkm8hst55kv45x396jh95v3h0000gn/T</span><br><span class="line">[frida-ios-dump]: Load ilink_network.framework success.</span><br><span class="line">[frida-ios-dump]: Load TPFFmpeg.framework success.</span><br><span class="line">[frida-ios-dump]: Load NewMessageRingUtil.framework success.</span><br><span class="line">[frida-ios-dump]: Load SoundTouch.framework success.</span><br><span class="line">[frida-ios-dump]: Load openssl.framework success.</span><br><span class="line">[frida-ios-dump]: Load MMRouter.framework success.</span><br><span class="line">[frida-ios-dump]: Load owl.framework success.</span><br><span class="line">[frida-ios-dump]: Load TPThirdParties.framework success.</span><br><span class="line">[frida-ios-dump]: Load andromeda.framework success.</span><br><span class="line">[frida-ios-dump]: Load matrixreport.framework success.</span><br><span class="line">[frida-ios-dump]: Load Lottie.framework success.</span><br><span class="line">[frida-ios-dump]: Load ProtobufLite.framework success.</span><br><span class="line">[frida-ios-dump]: Load App.framework success.</span><br><span class="line">[frida-ios-dump]: Load JavaScriptCore2.framework success.</span><br><span class="line">start dump /private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/WeChat</span><br><span class="line">0.00B [00:00, ?B/s]payload : &#123;<span class="string">&#x27;dump&#x27;</span>: <span class="string">&#x27;/var/mobile/Containers/Data/Application/CC606C90-0A7C-4829-B31E-3027FFFCE2D7/Documents/WeChat.322542873.fid&#x27;</span>, <span class="string">&#x27;path&#x27;</span>: <span class="string">&#x27;/private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/WeChat&#x27;</span>&#125;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/Users/franky/frida-ios-dump/path/to/venv/lib/python3.12/site-packages/frida/core.py&quot;</span>, line 562, <span class="keyword">in</span> _on_message</span><br><span class="line">    callback(message, data)</span><br><span class="line">  File <span class="string">&quot;/Users/franky/frida-ios-dump/dump.py&quot;</span>, line 571, <span class="keyword">in</span> on_message</span><br><span class="line">    scp.get(scp_from, scp_to)</span><br><span class="line">  File <span class="string">&quot;/Users/franky/frida-ios-dump/path/to/venv/lib/python3.12/site-packages/scp.py&quot;</span>, line 286, <span class="keyword">in</span> get</span><br><span class="line">    self._recv_all()</span><br><span class="line">  File <span class="string">&quot;/Users/franky/frida-ios-dump/path/to/venv/lib/python3.12/site-packages/scp.py&quot;</span>, line 440, <span class="keyword">in</span> _recv_all</span><br><span class="line">    raise SCPException(asunicode(msg[1:]))</span><br><span class="line">scp.SCPException: scp: /var/mobile/Containers/Data/Application/CC606C90-0A7C-4829-B31E-3027FFFCE2D7/Documents/WeChat.322542873.fid: No such file or directory</span><br><span class="line">0.00B [00:00, ?B/s]</span><br><span class="line">start dump /private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/TPThirdParties.framework/TPThirdParties</span><br><span class="line">0.00B [00:00, ?B/s]payload : &#123;<span class="string">&#x27;dump&#x27;</span>: <span class="string">&#x27;/var/mobile/Containers/Data/Application/CC606C90-0A7C-4829-B31E-3027FFFCE2D7/Documents/TPThirdParties.-1804490760.fid&#x27;</span>, <span class="string">&#x27;path&#x27;</span>: <span class="string">&#x27;/private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/TPThirdParties.framework/TPThirdParties&#x27;</span>&#125;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/Users/franky/frida-ios-dump/path/to/venv/lib/python3.12/site-packages/frida/core.py&quot;</span>, line 562, <span class="keyword">in</span> _on_message</span><br><span class="line">    callback(message, data)</span><br><span class="line">  File <span class="string">&quot;/Users/franky/frida-ios-dump/dump.py&quot;</span>, line 571, <span class="keyword">in</span> on_message</span><br><span class="line">    scp.get(scp_from, scp_to)</span><br><span class="line">  File <span class="string">&quot;/Users/franky/frida-ios-dump/path/to/venv/lib/python3.12/site-packages/scp.py&quot;</span>, line 286, <span class="keyword">in</span> get</span><br><span class="line">    self._recv_all()</span><br><span class="line">  File <span class="string">&quot;/Users/franky/frida-ios-dump/path/to/venv/lib/python3.12/site-packages/scp.py&quot;</span>, line 440, <span class="keyword">in</span> _recv_all</span><br><span class="line">    raise SCPException(asunicode(msg[1:]))</span><br><span class="line">scp.SCPException: scp: /var/mobile/Containers/Data/Application/CC606C90-0A7C-4829-B31E-3027FFFCE2D7/Documents/TPThirdParties.-1804490760.fid: No such file or directory</span><br><span class="line">0.00B [00:00, ?B/s]</span><br><span class="line">start dump /private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/TPFFmpeg.framework/TPFFmpeg</span><br><span class="line">0.00B [00:00, ?B/s]payload : &#123;<span class="string">&#x27;dump&#x27;</span>: <span class="string">&#x27;/var/mobile/Containers/Data/Application/CC606C90-0A7C-4829-B31E-3027FFFCE2D7/Documents/TPFFmpeg.-1887525640.fid&#x27;</span>, <span class="string">&#x27;path&#x27;</span>: <span class="string">&#x27;/private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/TPFFmpeg.framework/TPFFmpeg&#x27;</span>&#125;</span><br><span class="line">100%|██████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 12.3M/12.3M [00:00&lt;00:00, 34.7MB/s]</span><br><span class="line">start dump /private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/owl.framework/owl</span><br><span class="line">0.00B [00:00, ?B/s]payload : &#123;<span class="string">&#x27;dump&#x27;</span>: <span class="string">&#x27;/var/mobile/Containers/Data/Application/CC606C90-0A7C-4829-B31E-3027FFFCE2D7/Documents/owl.348061506.fid&#x27;</span>, <span class="string">&#x27;path&#x27;</span>: <span class="string">&#x27;/private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/owl.framework/owl&#x27;</span>&#125;</span><br><span class="line">100%|██████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 1.36M/1.36M [00:00&lt;00:00, 15.2MB/s]</span><br><span class="line">start dump /private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/ilink_network.framework/ilink_network</span><br><span class="line">0.00B [00:00, ?B/s]payload : &#123;<span class="string">&#x27;dump&#x27;</span>: <span class="string">&#x27;/var/mobile/Containers/Data/Application/CC606C90-0A7C-4829-B31E-3027FFFCE2D7/Documents/ilink_network.928538910.fid&#x27;</span>, <span class="string">&#x27;path&#x27;</span>: <span class="string">&#x27;/private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/ilink_network.framework/ilink_network&#x27;</span>&#125;</span><br><span class="line">100%|██████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 7.14M/7.14M [00:00&lt;00:00, 21.6MB/s]</span><br><span class="line">start dump /private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/SoundTouch.framework/SoundTouch</span><br><span class="line">0.00B [00:00, ?B/s]payload : &#123;<span class="string">&#x27;dump&#x27;</span>: <span class="string">&#x27;/var/mobile/Containers/Data/Application/CC606C90-0A7C-4829-B31E-3027FFFCE2D7/Documents/SoundTouch.1717022808.fid&#x27;</span>, <span class="string">&#x27;path&#x27;</span>: <span class="string">&#x27;/private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/SoundTouch.framework/SoundTouch&#x27;</span>&#125;</span><br><span class="line">100%|████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 113k/113k [00:00&lt;00:00, 2.13MB/s]</span><br><span class="line">start dump /private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/JavaScriptCore2.framework/JavaScriptCore2</span><br><span class="line">0.00B [00:00, ?B/s]payload : &#123;<span class="string">&#x27;dump&#x27;</span>: <span class="string">&#x27;/var/mobile/Containers/Data/Application/CC606C90-0A7C-4829-B31E-3027FFFCE2D7/Documents/JavaScriptCore2.514565318.fid&#x27;</span>, <span class="string">&#x27;path&#x27;</span>: <span class="string">&#x27;/private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/JavaScriptCore2.framework/JavaScriptCore2&#x27;</span>&#125;</span><br><span class="line">100%|██████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 12.6M/12.6M [00:00&lt;00:00, 34.6MB/s]</span><br><span class="line">start dump /private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/ProtobufLite.framework/ProtobufLite</span><br><span class="line">0.00B [00:00, ?B/s]payload : &#123;<span class="string">&#x27;dump&#x27;</span>: <span class="string">&#x27;/var/mobile/Containers/Data/Application/CC606C90-0A7C-4829-B31E-3027FFFCE2D7/Documents/ProtobufLite.410267128.fid&#x27;</span>, <span class="string">&#x27;path&#x27;</span>: <span class="string">&#x27;/private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/ProtobufLite.framework/ProtobufLite&#x27;</span>&#125;</span><br><span class="line">100%|████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 544k/544k [00:00&lt;00:00, 7.19MB/s]</span><br><span class="line">start dump /private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/MMRouter.framework/MMRouter</span><br><span class="line">0.00B [00:00, ?B/s]payload : &#123;<span class="string">&#x27;dump&#x27;</span>: <span class="string">&#x27;/var/mobile/Containers/Data/Application/CC606C90-0A7C-4829-B31E-3027FFFCE2D7/Documents/MMRouter.-2017767432.fid&#x27;</span>, <span class="string">&#x27;path&#x27;</span>: <span class="string">&#x27;/private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/MMRouter.framework/MMRouter&#x27;</span>&#125;</span><br><span class="line">100%|██████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 96.5k/96.5k [00:00&lt;00:00, 1.82MB/s]</span><br><span class="line">start dump /private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/Lottie.framework/Lottie</span><br><span class="line">0.00B [00:00, ?B/s]payload : &#123;<span class="string">&#x27;dump&#x27;</span>: <span class="string">&#x27;/var/mobile/Containers/Data/Application/CC606C90-0A7C-4829-B31E-3027FFFCE2D7/Documents/Lottie.1475886264.fid&#x27;</span>, <span class="string">&#x27;path&#x27;</span>: <span class="string">&#x27;/private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/Lottie.framework/Lottie&#x27;</span>&#125;</span><br><span class="line">100%|████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 488k/488k [00:00&lt;00:00, 9.93MB/s]</span><br><span class="line">start dump /private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/andromeda.framework/andromeda</span><br><span class="line">0.00B [00:00, ?B/s]payload : &#123;<span class="string">&#x27;dump&#x27;</span>: <span class="string">&#x27;/var/mobile/Containers/Data/Application/CC606C90-0A7C-4829-B31E-3027FFFCE2D7/Documents/andromeda.419211084.fid&#x27;</span>, <span class="string">&#x27;path&#x27;</span>: <span class="string">&#x27;/private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/andromeda.framework/andromeda&#x27;</span>&#125;</span><br><span class="line">100%|██████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 8.50M/8.50M [00:00&lt;00:00, 34.4MB/s]</span><br><span class="line">start dump /private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/openssl.framework/openssl</span><br><span class="line">0.00B [00:00, ?B/s]payload : &#123;<span class="string">&#x27;dump&#x27;</span>: <span class="string">&#x27;/var/mobile/Containers/Data/Application/CC606C90-0A7C-4829-B31E-3027FFFCE2D7/Documents/openssl.680017982.fid&#x27;</span>, <span class="string">&#x27;path&#x27;</span>: <span class="string">&#x27;/private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/openssl.framework/openssl&#x27;</span>&#125;</span><br><span class="line">100%|██████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 2.59M/2.59M [00:00&lt;00:00, 17.5MB/s]</span><br><span class="line">start dump /private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/matrixreport.framework/matrixreport</span><br><span class="line">0.00B [00:00, ?B/s]payload : &#123;<span class="string">&#x27;dump&#x27;</span>: <span class="string">&#x27;/var/mobile/Containers/Data/Application/CC606C90-0A7C-4829-B31E-3027FFFCE2D7/Documents/matrixreport.-1076983176.fid&#x27;</span>, <span class="string">&#x27;path&#x27;</span>: <span class="string">&#x27;/private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/matrixreport.framework/matrixreport&#x27;</span>&#125;</span><br><span class="line">100%|████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 469k/469k [00:00&lt;00:00, 8.20MB/s]</span><br><span class="line">start dump /private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/NewMessageRingUtil.framework/NewMessageRingUtil</span><br><span class="line">0.00B [00:00, ?B/s]payload : &#123;<span class="string">&#x27;dump&#x27;</span>: <span class="string">&#x27;/var/mobile/Containers/Data/Application/CC606C90-0A7C-4829-B31E-3027FFFCE2D7/Documents/NewMessageRingUtil.709267448.fid&#x27;</span>, <span class="string">&#x27;path&#x27;</span>: <span class="string">&#x27;/private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/NewMessageRingUtil.framework/NewMessageRingUtil&#x27;</span>&#125;</span><br><span class="line">100%|██████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 87.6k/87.6k [00:00&lt;00:00, 2.23MB/s]</span><br><span class="line">start dump /private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/App.framework/App</span><br><span class="line">0.00B [00:00, ?B/s]payload : &#123;<span class="string">&#x27;dump&#x27;</span>: <span class="string">&#x27;/var/mobile/Containers/Data/Application/CC606C90-0A7C-4829-B31E-3027FFFCE2D7/Documents/App.-760674948.fid&#x27;</span>, <span class="string">&#x27;path&#x27;</span>: <span class="string">&#x27;/private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app/Frameworks/App.framework/App&#x27;</span>&#125;</span><br><span class="line">100%|██████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 50.6M/50.6M [00:01&lt;00:00, 38.5MB/s]</span><br><span class="line">0.00B [00:00, ?B/s]payload : &#123;<span class="string">&#x27;app&#x27;</span>: <span class="string">&#x27;/private/var/containers/Bundle/Application/2171A776-C87B-4E20-8DD4-8163443CF339/WeChat.app&#x27;</span>&#125;</span><br><span class="line">/var/folders/rt/zkm8hst55kv45x396jh95v3h0000gn/T/Payload/</span><br><span class="line">666MB [00:25, 27.1MB/s]</span><br><span class="line">0.00B [00:00, ?B/s]payload : &#123;<span class="string">&#x27;done&#x27;</span>: <span class="string">&#x27;ok&#x27;</span>&#125;</span><br><span class="line">DONE!</span><br><span class="line">0.00B [00:00, ?B/s]</span><br><span class="line">Generating <span class="string">&quot;微信.ipa&quot;</span></span><br></pre></td></tr></table></figure>

<p>输入 la 查看当前目录下，多了一个 微信.ipa 文件。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(venv)  ~/frida-ios-dump/ [master*] la</span><br><span class="line">total 590168</span><br><span class="line">drwxr-xr-x@ 13 franky  staff   416B  9 26 18:46 .git</span><br><span class="line">-rw-r--r--@  1 franky  staff   1.0K  5 31 20:48 LICENSE</span><br><span class="line">-rw-r--r--@  1 franky  staff   804B  5 31 20:48 README.md</span><br><span class="line">-rwxr-xr-x@  1 franky  staff    25K  9 26 11:19 dump.py</span><br><span class="line">drwxr-xr-x@  3 franky  staff    96B  9 26 18:49 path</span><br><span class="line">-rw-r--r--@  1 franky  staff   2.0K  5 31 20:48 process.sh</span><br><span class="line">-rw-r--r--@  1 franky  staff    36B  9 26 18:53 requirements.txt</span><br><span class="line">-rw-r--r--@  1 franky  staff   276M  9 26 19:35 微信.ipa</span><br></pre></td></tr></table></figure>

<p>解压缩 ipa 之后，使用 <code>otool -l Payload/WeChat.app/WeChat | grep crypt</code> 查看 WeChat 是否脱壳成功，记得一定要检查，有时候会看起一切正常然而并没有脱壳成功。如何判断是否脱壳成功呢？检查 cryptid 后面的值，是 0 就代表脱壳成功了，非 0 表示脱壳失败，该二进制文件依旧有壳。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> ~/frida-ios-dump/ [master*] otool -l Payload/WeChat.app/WeChat | grep crypt</span><br><span class="line">     cryptoff 138072064</span><br><span class="line">    cryptsize 4096</span><br><span class="line">      cryptid 0</span><br></pre></td></tr></table></figure>

<p>至此，你就得到了一个脱壳成功的 ipa 了。有了它之后才可以进行后面的分析。</p>
<h1 id="安装-Theos-创建抢红包-tweak-项目"><a href="#安装-Theos-创建抢红包-tweak-项目" class="headerlink" title="安装 Theos 创建抢红包 tweak 项目"></a>安装 Theos 创建抢红包 tweak 项目</h1><p>在 iOS 越狱环境中，”tweak” 通常指的是对系统或应用进行修改的小程序或插件。这些修改可以改变应用的外观、功能或行为。Tweaks 通常通过 Cydia、Sileo 等包管理器安装，允许用户自定义他们的设备。例如，有些 tweak 可以添加新的功能到现有的应用，或者移除一些系统限制。</p>
<p>编写 tweak 需要用到 Theos，Theos 最初是一个名为 “iphone-framework” 的项目，旨在简化命令行下的代码构建，主要用于越狱的 iOS 设备。后来，它经历了重大改进，成为 Theos —— 一个基于 Make 的灵活构建系统，专注于越狱软件开发，同时也支持为其他多个平台构建项目。安装 Theos 需要安装 Xcode 和 Homebrew。具体的安装方法可以查看 <a href="https://theos.dev/docs/installation-macos">官方文档</a></p>
<p>Theos 安装好之后，打开终端输入以下命令 <code>nic.pl</code> 创建 tweak 项目，然后按照提示输入相关信息：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> ~/ nic.pl</span><br><span class="line">NIC 2.0 - New Instance Creator</span><br><span class="line">------------------------------</span><br><span class="line">  [1.] iphone/activator_event</span><br><span class="line">  [2.] iphone/activator_listener</span><br><span class="line">  [3.] iphone/application</span><br><span class="line">  [4.] iphone/application_swift</span><br><span class="line">  [5.] iphone/application_swiftui</span><br><span class="line">  [6.] iphone/control_center_module-11up</span><br><span class="line">  [7.] iphone/cydget</span><br><span class="line">  [8.] iphone/flipswitch_switch</span><br><span class="line">  [9.] iphone/framework</span><br><span class="line">  [10.] iphone/library</span><br><span class="line">  [11.] iphone/notification_center_widget</span><br><span class="line">  [12.] iphone/notification_center_widget-7up</span><br><span class="line">  [13.] iphone/null</span><br><span class="line">  [14.] iphone/preference_bundle</span><br><span class="line">  [15.] iphone/preference_bundle_swift</span><br><span class="line">  [16.] iphone/theme</span><br><span class="line">  [17.] iphone/tool</span><br><span class="line">  [18.] iphone/tool_swift</span><br><span class="line">  [19.] iphone/tweak</span><br><span class="line">  [20.] iphone/tweak_swift</span><br><span class="line">  [21.] iphone/tweak_with_simple_preferences</span><br><span class="line">  [22.] iphone/xpc_service</span><br><span class="line">  [23.] iphone/xpc_service_modern</span><br><span class="line">Choose a Template (required): 19</span><br><span class="line">Project Name (required): redEnveloper</span><br><span class="line">Package Name [com.yourcompany.redenveloper]:</span><br><span class="line">Author/Maintainer Name [franky]:</span><br><span class="line">[iphone/tweak] MobileSubstrate Bundle filter [com.apple.springboard]: com.tencent.xin</span><br><span class="line">[iphone/tweak] List of applications to terminate upon installation (space-separated, <span class="string">&#x27;-&#x27;</span> <span class="keyword">for</span> none) [SpringBoard]: WeChat</span><br><span class="line">Instantiating iphone/tweak <span class="keyword">in</span> redEnveloper/...</span><br><span class="line">Done.</span><br></pre></td></tr></table></figure>

<p>这里我们填写了工程名为 redEnveloper</p>
<p>然后在 <code>[iphone/tweak] MobileSubstrate Bundle filter [com.apple.springboard]:</code> 这一栏输入的 <code>com.tencent.xin</code> 是微信的唯一标识，也就是 CFBundleIdentifier，至于如何知道微信的 CFBundleIdentifier 是这个的，其实有很多方法。。。</p>
<p>然后在 <code>[iphone/tweak] List of applications to terminate upon installation (space-separated, &#39;-&#39; for none) [SpringBoard]: </code> 这一栏输入 <code>WeChat</code> 这是微信的进程名。</p>
<p>其他项都可以直接回车使用默认值就行了。我们先认识一下 tweak 项目都有哪些文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> ~/redEnveloper/ tree</span><br><span class="line">.</span><br><span class="line">├── Makefile</span><br><span class="line">├── Tweak.xm</span><br><span class="line">├── control</span><br><span class="line">└── redEnveloper.plist</span><br><span class="line"></span><br><span class="line">1 directory, 4 files</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>tree</code> 命令默认是没有的，可以使用 <code>brew install tree</code> 安装。</p>
</blockquote>
<p>在 iOS Tweak 项目中，这些文件和文件夹的作用如下：</p>
<ol>
<li><p><strong>Makefile</strong>：用于编译和构建你的 tweak。它定义了如何将源代码（如 Tweak.x）编译成动态库，包括所需的编译器选项和依赖关系。</p>
</li>
<li><p><strong>Tweak.x</strong>：这是你的插件主要源代码文件，通常包含了你想要实现的功能的代码。你可以在这里编写用于修改系统行为或应用程序功能的代码。</p>
</li>
<li><p><strong>control</strong>：这个文件包含关于你的 tweak 的元数据，例如名称、版本、作者、依赖关系等。它通常用于生成一个可安装的包。</p>
</li>
<li><p><strong>packages</strong>：这个文件夹通常用于存放编译后的 deb 包，方便发布和安装。</p>
</li>
<li><p><strong>redEnveloper.plist</strong>：这是一个属性列表文件，这个部分用于定义哪些应用程序的行为会受到你的 tweak 影响。</p>
</li>
</ol>
<h1 id="实现抢红包插件的-UI-代码"><a href="#实现抢红包插件的-UI-代码" class="headerlink" title="实现抢红包插件的 UI 代码"></a>实现抢红包插件的 UI 代码</h1><p>实现微信自动抢红包功能可以完全不提供 UI 界面，这样每个红包消息过来的时候就自动拆开了。但这样不太好，而且实际的情况下不合适的红包自动抢了会很尴尬，另外从学习逆向开发的角度来说，多练习下也是不错的。但这个功能 UI 不是重点，所以我们还是尽可能的简单处理，只在微信的设置页面添加一个 cell 左边显示自动抢红包功能，右边显示一个开关用来控制该功能。</p>
<p>现在很多人可能会好奇，Tweak.x 编写什么代码呢？.x 文件里面写 Logos 语法的代码。Logos 是一个基于 Perl 语言的正则表达式的预处理器，它通过优雅的类似 Objective-C 的语法简化了为 Objective-C 方法和 C 函数创建 hook 所需的模板代码。如果熟悉 Objective-C 的 runtime 的话，就可以理解为 Logos 语法将平时我们自己通过 runtime 编写的 hook 代码简化了。Logos 语法也没有很多，官方文档在<a href="https://theos.dev/docs/logos-syntax">这里</a>。</p>
<p>了解或熟悉 Logos 语法之后，接下来就是考虑对哪些类，哪些方法进行 hook 了，至于什么是 hook，<a href="hook/hook.md">这篇文章</a> 有介绍。按照刚刚所说的 UI 需求的话，就需要分析微信的设置界面所用的类，和实现的逻辑了。这里会用到界面分析工具 <a href="%E8%BF%99%E9%87%8C%E5%86%99%E8%BF%87%E6%96%87%E7%AB%A0">Reveal</a> 或者 Lookin 等类似工具用于查看设置界面的控制器类，也可以用 <a href="%E8%BF%99%E9%87%8C%E5%86%99%E8%BF%87%E6%96%87%E7%AB%A0">cycript</a>，<a href="%E8%BF%99%E9%87%8C%E4%B9%9F%E6%9C%89%E6%96%87%E7%AB%A0%E4%BA%86">lldb</a> 等命令行工具查看。知道了是哪个控制器类之后，就可以使用 <a href="%E9%9C%80%E8%A6%81%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0">class-dump</a> 工具对前面脱壳过的微信可执行文件导出所有的头文件，阅读对应的控制器类的头文件了。再结合正向开发的经验，分析应该 hook 哪些类的哪些方法。</p>
<p>这里我们以 Reveal 为例，作者使用的是 Reveal46，因为 Reveal47 要求 iOS13 以上了，老版本可以在<a href="https://revealapp.com/updates/46/">官网下载</a>。</p>
<p>在手机上的 Cydia 搜索安装 Reveal2Loader 并安装。安装成功之后还需要再去设置中，找到 Reveal 项，进入 Enabled Applications 打开微信的右侧开关，这样才会在启动微信的时候注入 Reveal 服务。Reveal2Loader 自带的 RevealServer.framework 很古老了，大概率和你 Mac 上的 Reveal 是不匹配的，但是不用担心，可以将 Mac 上 Reveal 的 RevealServer.framework 复制到越狱设备的 &#x2F;Library&#x2F;Frameworks 文件夹下。可以使用任何你熟悉的方式，如：使用 iFunBox，使用 scp 命令。这里以 scp 命令为例子：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> ~/ scp -r -P 2222 /Applications/Reveal.app/Contents/SharedSupport/iOS-Libraries/RevealServer.framework root@localhost:/Library/Frameworks</span><br><span class="line">CodeResources                                                                                                                                                100% 2754     1.1MB/s   00:00</span><br><span class="line">RevealServer.h                                                                                                                                               100%  309   197.0KB/s   00:00</span><br><span class="line">RevealServer                                                                                                                                                 100%   12MB  38.1MB/s   00:00</span><br><span class="line">copy_and_codesign_revealserver.sh                                                                                                                            100% 1399   700.3KB/s   00:00</span><br><span class="line">module.modulemap                                                                                                                                             100%  105    59.6KB/s   00:00</span><br><span class="line">Info.plist</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：需要提前进行端口转发 iproxy 2222:22</p>
</blockquote>
<p>RevealServer.framework 的路径可以通过下图中的方式找到</p>
<p><img src="Xnip2024-10-13_00-59-11.jpg"></p>
<p>如果你使用的是较新的 iOS 版本，可能 Reveal2Loader 或者 LookinLoader 都无法正常使用了，没关系，作者都已经发布了适配 rootless 越狱的和较新版本的 <a href="https://github.com/masterKing/RevealLoader2">RevealLoader2</a> 和 <a href="https://github.com/masterKing/LookinLoader2">LookinLoader2</a>。</p>
<p>最终，越狱设备打开微信进入到设置页面并且 Mac 打开 Reveal，就可以在 Reveal 中看到微信 APP 了。我们选择带有 USB 图标的微信，这是通过 USB 进行数据传输的方式，另一个是通过 WiFi 传输数据，在网络不好的情况下会比较慢。</p>
<p>Reveal 的显示如下图：</p>
<p><img src="Xnip2024-10-13_13-09-41.jpg"></p>
<p>如果 <code>WCTableView</code> 对象的数据源就是 <code>NewSettingViewController</code> 对象那就可以直接对 <code>NewSettingViewController</code> 进行 hook 了。但如果不是的话，就没有必要对 <code>NewSettingViewController</code> 进行 hook 了没有意义。Reveal 无法进行命令交互，给我们提供更多的信息，这一点 Lookin 做的更好。这时，可以使用 cycript 或 lldb 进行验证。这里以 cycript 为例：</p>
<p>在越狱设备上进入 Cydia，搜索 Cycript 并安装，之后我们远程登录到越狱设备就可以使用 Cycript 了。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> ~/ ssh root@localhost -p 2222</span><br><span class="line">iPhone5s:~ root# cycript -p WeChat</span><br><span class="line">cy# <span class="comment">#0x117f56e00</span></span><br><span class="line"><span class="comment">#&quot;&lt;WCTableView: 0x117f56e00; baseClass = UITableView; frame = (0 0; 320 568); clipsToBounds = YES; gestureRecognizers = &lt;NSArray: 0x286cee370&gt;; layer = &lt;CALayer: 0x2827e89e0&gt;; contentOffset: &#123;0, -64&#125;; contentSize: &#123;320, 942&#125;; adjustedContentInset: &#123;64, 0, 0, 0&#125;&gt;&quot;</span></span><br><span class="line">cy# <span class="comment">#0x117f56e00.dataSource</span></span><br><span class="line"><span class="comment">#&quot;&lt;WCTableViewManager: 0x286cef9f0&gt;&quot;</span></span><br><span class="line">cy#</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示：0x117f56e00 这个内存地址是从 Reveal 中获取的</p>
</blockquote>
<p>结果发现 <code>WCTableView</code> 对象 0x117f56e00 的 <code>dataSource</code> 并不是控制器 <code>NewSettingViewController</code> 而是一个 <code>WCTableViewManager</code> 类的对象。那么接下来就是对 <code>WCTableViewManager</code> 类的头文件进行分析了。其实知道了 <code>WCTableView</code> 的数据源是 <code>WCTableViewManager</code> 之后也可以不用再分析下去了，<code>WCTableViewManager</code> 一定会实现 <code>UITableView</code> 的数据源方法的。但是为了方便后面编写 tweak 代码，我们这里还是要介绍一下 class-dump。</p>
<p><a href="https://github.com/nygard/class-dump">class-dump</a> 是一个用于从 macOS 和 iOS 应用的 Mach-O 可执行文件中提取 Objective-C 类、协议和方法声明的工具。它不进行完整的反汇编或反编译，而是专注于提取头文件（.h 文件）中的结构信息，从而帮助开发者和逆向工程师了解应用的类结构和接口。</p>
<p>使用 class-dump 提取微信的头文件的命令如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> ~/frida-ios-dump/ [master*] class-dump -H Payload/WeChat.app/WeChat -o WeChatHeaders</span><br><span class="line">2024-10-06 20:38:38.536 class-dump[80038:3372682] Unknown load <span class="built_in">command</span>: 0x00000032</span><br><span class="line">2024-10-06 20:38:52.655 class-dump[80038:3372682] Warning: Parsing instance variable <span class="built_in">type</span> failed, ready_</span><br><span class="line">2024-10-06 20:38:58.673 class-dump[80038:3372682] Warning: Parsing instance variable <span class="built_in">type</span> failed, scheme</span><br><span class="line">2024-10-06 20:38:58.673 class-dump[80038:3372682] Warning: Parsing instance variable <span class="built_in">type</span> failed, queue</span><br><span class="line">2024-10-06 20:38:58.676 class-dump[80038:3372682] Warning: Parsing instance variable <span class="built_in">type</span> failed, svrID</span><br><span class="line">...</span><br><span class="line">省略很多打印</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这里我们需要用到刚刚砸壳成功的微信，否则是无法成功提取头文件的。使用 <code>la</code> 查看当前文件夹下的内容，可以看到多了一个 WeChatHeaders 的文件，里面有接近3万个的头文件。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> ~/frida-ios-dump/ [master*] la</span><br><span class="line">total 526064</span><br><span class="line">-rw-r--r--@     1 Franky  staff   6.0K Jul  2 16:39 .DS_Store</span><br><span class="line">drwxr-xr-x     13 Franky  staff   416B Oct  6 18:57 .git</span><br><span class="line">-rw-r--r--      1 Franky  staff    30B May  4  2023 .gitignore</span><br><span class="line">-rw-r--r--      1 Franky  staff   1.0K May  4  2023 LICENSE</span><br><span class="line">drwxr-xr-x      3 Franky  staff    96B Oct  6 20:29 Payload</span><br><span class="line">-rw-r--r--@     1 Franky  staff   3.2K May  4  2023 README.md</span><br><span class="line">drwxr-xr-x  29607 Franky  staff   925K Oct  6 20:39 WeChatHeaders</span><br><span class="line">-rw-r--r--      1 Franky  staff    11K May  4  2023 dump.js</span><br><span class="line">-rwxr-xr-x@     1 Franky  staff    11K Apr  2  2024 dump.py</span><br><span class="line">-rwxr-xr-x      1 Franky  staff   2.0K May  4  2023 process.sh</span><br><span class="line">-rw-r--r--@     1 Franky  staff   157B May  4  2023 requirements.txt</span><br><span class="line">-rw-r--r--      1 Franky  staff   255M Oct  6 20:30 微信.ipa</span><br></pre></td></tr></table></figure>

<p>使用 Sublime Text 打开这个 WeChatHeaders 文件夹，Sublime 是一个编辑器，对于这种上万份的头文件不推荐用 Xcode 打开，会很卡顿。当然也可以用你熟悉的其他编辑器打开。搜索 <code>WCTableViewManager</code> 就可以看到对应的头文件内容了。</p>
<p><img src="Xnip2024-10-06_20-49-33.png"></p>
<p>有了这个头文件之后，我们在编写 tweak 的时候，就可以方便的进行复制粘贴了，而不是每一行每一句代码，如这里的 <code>UITableView</code> 的数据源方法都自己敲一遍。</p>
<p>最后同样是使用 Sublime 打开我们之前创建 tweak 项目，选择 Tweak.x 文件删掉默认生成的代码进行编辑，代码如下：</p>
<figure class="highlight objective-c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"><span class="comment">// 界面代码</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WCTableViewManager</span></span></span><br><span class="line">- (<span class="type">long</span> <span class="type">long</span>)numberOfSectionsInTableView:(<span class="type">id</span>)arg1;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">%hook WCTableViewManager</span><br><span class="line"></span><br><span class="line">- (<span class="type">double</span>)tableView:(<span class="built_in">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class="type">id</span>)indexPath&#123;</span><br><span class="line">    <span class="keyword">if</span>([tableView.nextResponder.nextResponder isKindOfClass:%c(NewSettingViewController)]</span><br><span class="line">       &amp;&amp;([indexPath section] == [<span class="keyword">self</span> numberOfSectionsInTableView:tableView] - <span class="number">1</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">44</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> %orig;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">id</span>)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="type">id</span>)indexPath&#123;</span><br><span class="line">    <span class="keyword">if</span>([tableView.nextResponder.nextResponder isKindOfClass:%c(NewSettingViewController)]</span><br><span class="line">       &amp;&amp;([indexPath section] == [<span class="keyword">self</span> numberOfSectionsInTableView:tableView] - <span class="number">1</span>))&#123;</span><br><span class="line">        <span class="built_in">UITableViewCell</span> * cell = [[<span class="built_in">UITableViewCell</span> alloc] initWithStyle:(<span class="built_in">UITableViewCellStyleDefault</span>) reuseIdentifier:<span class="literal">nil</span>];</span><br><span class="line">        cell.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">        <span class="keyword">if</span>([indexPath row] == <span class="number">0</span>)&#123;</span><br><span class="line">            cell.textLabel.text = <span class="string">@&quot;自动抢红包&quot;</span>;</span><br><span class="line">            <span class="built_in">UISwitch</span> * switchView = [[<span class="built_in">UISwitch</span> alloc] init];</span><br><span class="line">            switchView.on = [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] boolForKey:<span class="string">@&quot;RESWITCHKEY&quot;</span>];</span><br><span class="line">            [switchView addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(switchChang:) forControlEvents:(<span class="built_in">UIControlEventValueChanged</span>)];</span><br><span class="line">            cell.accessoryView = switchView;</span><br><span class="line">            <span class="built_in">NSBundle</span> *bundle = [<span class="built_in">NSBundle</span> bundleWithPath:<span class="string">@&quot;/Library/MobileSubstrate/DynamicLibraries/redEnveloper.bundle/&quot;</span>];</span><br><span class="line">            <span class="built_in">NSString</span> *imageName = ([[<span class="built_in">NSUserDefaults</span> standardUserDefaults] boolForKey:<span class="string">@&quot;RESWITCHKEY&quot;</span>] == <span class="number">1</span>) ? <span class="string">@&quot;locked.png&quot;</span> : <span class="string">@&quot;unlocked.png&quot;</span>;</span><br><span class="line">            <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:imageName inBundle:bundle compatibleWithTraitCollection:<span class="literal">nil</span>];</span><br><span class="line">            cell.imageView.image = image;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cell;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> %orig;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">long</span> <span class="type">long</span>)tableView:(<span class="built_in">UITableView</span> *)tableView numberOfRowsInSection:(<span class="type">long</span> <span class="type">long</span>)section&#123;</span><br><span class="line">    <span class="keyword">if</span>([tableView.nextResponder.nextResponder isKindOfClass:%c(NewSettingViewController)]</span><br><span class="line">       &amp;&amp;(section == [<span class="keyword">self</span> numberOfSectionsInTableView:tableView] - <span class="number">1</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> %orig;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">long</span> <span class="type">long</span>)numberOfSectionsInTableView:(<span class="built_in">UITableView</span> *)tableView&#123;</span><br><span class="line">    <span class="keyword">if</span>([tableView.nextResponder.nextResponder isKindOfClass:%c(NewSettingViewController)])&#123;</span><br><span class="line">        <span class="keyword">return</span> %orig+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> %orig;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">%new</span><br><span class="line">-(<span class="type">void</span>)switchChang:(<span class="built_in">UISwitch</span> *)switchView&#123;</span><br><span class="line">    [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] setBool:switchView.isOn forKey:<span class="string">@&quot;RESWITCHKEY&quot;</span>];</span><br><span class="line">    [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] synchronize];</span><br><span class="line">    [MSHookIvar&lt;<span class="built_in">UITableView</span> *&gt;(<span class="keyword">self</span>,<span class="string">&quot;_tableView&quot;</span>) reloadData];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">%end</span><br></pre></td></tr></table></figure>

<p>这段代码对于有经验的 iOS 应用开发者来说，即很熟悉又有点陌生，陌生的是一些 Logos 语法，而熟悉的是这代码基本就像是 Objective-C。这段代码中的<code>[MSHookIvar&lt;UITableView *&gt;(self,&quot;_tableView&quot;) reloadData];</code>用到了 Objective-C++ 的语法，直接编译会不通过。需要将 tweak.x 改为 tweak.xm，同时修改 Makefile 中的 <code>redEnveloper_FILES = Tweak.x</code> 为 <code>redEnveloper_FILES = Tweak.xm</code>。这样才能通过编译。同时我们使用了两张图片作为开关的状态显示。最终项目的结构如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> ~/redEnveloper/ tree</span><br><span class="line">.</span><br><span class="line">├── Makefile</span><br><span class="line">├── Tweak.xm</span><br><span class="line">├── control</span><br><span class="line">├── layout</span><br><span class="line">│   └── Library</span><br><span class="line">│       └── MobileSubstrate</span><br><span class="line">│           └── DynamicLibraries</span><br><span class="line">│               └── redEnveloper.bundle</span><br><span class="line">│                   ├── locked.png</span><br><span class="line">│                   └── unlocked.png</span><br><span class="line">└── redEnveloper.plist</span><br><span class="line"></span><br><span class="line">6 directories, 6 files</span><br></pre></td></tr></table></figure>

<p>其中 layout 及下面的子文件夹是我们自己创建的，在编译的时候，Thoes 会将这个文件夹下面的内容移动到越狱设备的对应文件路径下。意思就是在编译安装之后，越狱设备的 <code>/Library/MobileSubstrate/DynamicLibraries/redEnveloper.bundle</code> 路径下放了两张图片。这个 layout 文件夹相当于 iOS 文件系统的根目录一样。</p>
<p>这样界面相关的代码就全部完成了。我们编译打包安装看看效果：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> ~/iOSREProject/redEnveloper/ make clean &amp;&amp; make package &amp;&amp; make install</span><br><span class="line">==&gt; Cleaning…</span><br><span class="line">&gt; Making all <span class="keyword">for</span> tweak redEnveloper…</span><br><span class="line">==&gt; Preprocessing Tweak.xm…</span><br><span class="line">==&gt; Preprocessing Tweak.xm…</span><br><span class="line">==&gt; Compiling Tweak.xm (arm64)…</span><br><span class="line">==&gt; Compiling Tweak.xm (arm64e)…</span><br><span class="line">==&gt; Linking tweak redEnveloper (arm64)…</span><br><span class="line">ld: warning: -multiply_defined is obsolete</span><br><span class="line">==&gt; Generating debug symbols <span class="keyword">for</span> redEnveloper…</span><br><span class="line">==&gt; Linking tweak redEnveloper (arm64e)…</span><br><span class="line">ld: warning: -multiply_defined is obsolete</span><br><span class="line">==&gt; Generating debug symbols <span class="keyword">for</span> redEnveloper…</span><br><span class="line">==&gt; Merging tweak redEnveloper…</span><br><span class="line">==&gt; Signing redEnveloper…</span><br><span class="line">&gt; Making stage <span class="keyword">for</span> tweak redEnveloper…</span><br><span class="line">dm.pl: building package `com.yourcompany.redenveloper:iphoneos-arm<span class="string">&#x27; in `./packages/com.yourcompany.redenveloper_0.0.1-15+debug_iphoneos-arm.deb&#x27;</span></span><br><span class="line">==&gt; Installing…</span><br><span class="line">(Reading database ... 7856 files and directories currently installed.)</span><br><span class="line">Preparing to unpack /tmp/_theos_install.deb ...</span><br><span class="line">Unpacking com.yourcompany.redenveloper (0.0.1-15+debug) over (0.0.1-14+debug) ...</span><br><span class="line">Setting up com.yourcompany.redenveloper (0.0.1-15+debug) ...</span><br><span class="line">Processing triggers <span class="keyword">for</span> org.coolstar.sileo (2.5) ...</span><br><span class="line">Not running <span class="keyword">in</span> Sileo. Trigger UICache</span><br><span class="line">==&gt; Unloading WeChat…</span><br></pre></td></tr></table></figure>

<p>这里使用了 <code>&amp;&amp;</code> 符号将多个命令合并一起执行了。命令运行时，手机上的微信会被杀死。命令完成后我们打开微信，进入设置页面，滑倒最底部就会看到新增的界面了。 </p>
<img src="IMG_0002.PNG" alt="IMG_0002.PNG" width="50%">



<h1 id="实现抢红包插件的功能代码"><a href="#实现抢红包插件的功能代码" class="headerlink" title="实现抢红包插件的功能代码"></a>实现抢红包插件的功能代码</h1><p>实现自动抢红包功能的思路就是，在我们收到消息的时候，判断是红包消息，就调用打开红包的代码。完整的分析流程会十分耗时耗力，这里只大概的讲述一下。实际完成抢红包功能之后就会发现，实际所写的代码并不多，但是分析出如何写才是真正耗费时间精力的地方。</p>
<h2 id="1-定位收到微信消息的方法"><a href="#1-定位收到微信消息的方法" class="headerlink" title="1.定位收到微信消息的方法"></a>1.定位收到微信消息的方法</h2><p>为了定位收到微信消息的方法，我们可以从聊天页面出发，hook 聊天页面的所有方法，然后让对方发送消息过来，从而发现接收消息时调用了哪些方法。</p>
<p>Theos 附带了一个 logify.pl 命令行程序，它将 Objective-C 头文件（或任何包含 @interface 和方法定义的文件）转换为 Logos 输入文件，以便记录和打印所有函数调用。先使用 Reveal 查看微信聊天页面，可以知道是 <code>BaseMsgContentViewController</code> 类。然后将使用 logify.pl 将这个类的头文件转成 xm 文件并添加到我们抢红包的 tweak 工程中。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> ~/frida-ios-dump/ [master*] <span class="built_in">cd</span> ~/redEnveloper</span><br><span class="line"> ~/redEnveloper/ logify.pl ~/frida-ios-dump/WeChatHeaders/BaseMsgContentViewController.h &gt; ./BaseMsgContentViewController.xm</span><br><span class="line"> ~/redEnveloper/ <span class="built_in">ls</span></span><br><span class="line">BaseMsgContentViewController.xm Tweak.xm                        layout                          redEnveloper.plist</span><br><span class="line">Makefile                        control                         packages</span><br></pre></td></tr></table></figure>

<p>可以看到使用 logify.pl 之后多出了一个 <code>BaseMsgContentViewController.xm</code> 文件。还需要在 Makefile 文件中添加这个文件，Theos 才会在编译时处理这个文件。makefile 文件内容如下所示:</p>
<figure class="highlight objective-c++"><table><tr><td class="code"><pre><span class="line">TARGET := iphone:clang:latest:<span class="number">7.0</span></span><br><span class="line">INSTALL_TARGET_PROCESSES = WeChat</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">include $(THEOS)/makefiles/common.mk</span><br><span class="line"></span><br><span class="line">TWEAK_NAME = redEnveloper</span><br><span class="line"></span><br><span class="line">redEnveloper_FILES = Tweak.xm BaseMsgContentViewController.xm</span><br><span class="line">redEnveloper_CFLAGS = -fobjc-arc</span><br><span class="line"></span><br><span class="line">include $(THEOS_MAKE_PATH)/tweak.mk</span><br></pre></td></tr></table></figure>

<p>这个时候<code>make package</code>会报很多错误，主要是 logify.pl 生成的文件并不能直接使用，我们一起解决:</p>
<ul>
<li>添加 <code>UIKit</code> 头文件</li>
<li>声明用到的类和协议</li>
<li>移除 <code>- (void).cxx_destruct &#123; %log; %orig; &#125;</code> 方法</li>
<li>将 <code>CDUnknownBlockType</code> 改为 id</li>
<li>删掉 <code>inout</code> </li>
<li>Makefile 中给 redEnveloper_CFLAGS &#x3D; -fobjc-arc 后面添加 -Wno-ignored-qualifiers 编译器标记</li>
</ul>
<p>再次<code>make package</code>就可以成功编译了。之后<code>make install</code>安装到越狱设备上。我们在微信的聊天页面等待接收消息，然后打开 Mac 的控制台程序，选择我们的越狱设备，右侧搜索框输入 WeChat 过滤其他不关心的打印信息。接下来就可以给我们的越狱设备发生微信消息了，查看控制器台的打印信息，可以发现每次收到新消息的时候，都会调用以下这些方法，而高亮选中的方法带有一个 <code>addMessageNode:</code> 参数令人感到兴奋。</p>
<p><img src="Xnip2024-10-13_15-09-33.jpg"></p>
<p>尝试对这个方法下断点，打印它的调用堆栈，看能否看到有用的信息。这里运用到了 lldb+debugserver 远程调试</p>
<p>debugserver 和 lldb 是可以通过无线网络进行连接的，但是为了速度考虑，我们还是通过 USB 进行连接会更好，所以我们先进行端口映射，将越狱设备的 3333 端口和 Mac 电脑的 3333 端口关联。然后都通过访问本机的 3333 端口就可以通过 USB 建立连接了。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> ~/ iproxy 3333:3333</span><br><span class="line">Creating listening port 3333 <span class="keyword">for</span> device port 3333</span><br><span class="line">waiting <span class="keyword">for</span> connection</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>越狱设备打开包管理器 Sileo 或 Cydia 搜索 debugserver 并安装。安装好之后，我们就可以在 iOS 上运行 debugserver 了。远程登录到越狱设备，然后运行 debugserver 程序附加到微信进程。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> ~/ ssh root@localhost -p 2222</span><br><span class="line">iPhone5s:~ root# debugserver-10 localhost:3333 --attach=WeChat</span><br><span class="line">debugserver-@(#)PROGRAM:LLDB  PROJECT:lldb-10.0.0</span><br><span class="line"> <span class="keyword">for</span> arm64.</span><br><span class="line">Attaching to process WeChat...</span><br><span class="line">Listening to port 3333 <span class="keyword">for</span> a connection from localhost...</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>然后再新建一个终端窗口，进入 lldb 交互，进行连接：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> ~/ lldb</span><br><span class="line">(lldb) process connect connect://localhost:3333</span><br><span class="line">Process 11908 stopped</span><br><span class="line">* thread <span class="comment">#1, queue = &#x27;com.apple.main-thread&#x27;, stop reason = signal SIGSTOP</span></span><br><span class="line">    frame <span class="comment">#0: 0x000000018b5840f4 libsystem_kernel.dylib`mach_msg_trap + 8</span></span><br><span class="line">libsystem_kernel.dylib`mach_msg_trap:</span><br><span class="line">-&gt;  0x18b5840f4 &lt;+8&gt;: ret</span><br><span class="line"></span><br><span class="line">libsystem_kernel.dylib`mach_msg_overwrite_trap:</span><br><span class="line">    0x18b5840f8 &lt;+0&gt;: mov    x16, <span class="comment">#-0x20</span></span><br><span class="line">    0x18b5840fc &lt;+4&gt;: svc    <span class="comment">#0x80</span></span><br><span class="line">    0x18b584100 &lt;+8&gt;: ret</span><br><span class="line">Target 0: (WeChat) stopped.</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure>

<p>此时，我们就可以像在 Xcode 控制台里 po 一样调试微信了。从上面控制台的打印中或者 Reveal 里面，我们可以得到 <code>BaseMsgContentViewController</code> 的内存地址。调用对象的一个隐藏私有方法 <code>__methodDescriptionForClass:</code> 来获取它所有的方法。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(lldb) po [0x117dad600 __methodDescriptionForClass:(<span class="built_in">id</span>)[0x117dad600 class]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> BaseMsgContentViewController:</span><br><span class="line">	Class Methods:</span><br><span class="line">		+ (void) reload:(<span class="built_in">id</span>)arg1 sections:(<span class="built_in">id</span>)arg2 withRowAnimation:(long)arg3; (0x118372ef4)</span><br><span class="line">	Properties:</span><br><span class="line">		@property (weak, nonatomic) MMPageSheetAdapter* pageSheetAdapter;</span><br><span class="line">		@property (<span class="built_in">readonly</span>) unsigned long <span class="built_in">hash</span>;</span><br><span class="line">		@property (<span class="built_in">readonly</span>) Class superclass;</span><br><span class="line">		@property (<span class="built_in">readonly</span>, copy) NSString* description;</span><br><span class="line">		@property (<span class="built_in">readonly</span>, copy) NSString* debugDescription;</span><br><span class="line">		@property (<span class="built_in">readonly</span>) unsigned long <span class="built_in">hash</span>;</span><br><span class="line">		@property (<span class="built_in">readonly</span>) Class superclass;</span><br><span class="line">		@property (<span class="built_in">readonly</span>, copy) NSString* description;</span><br><span class="line">		@property (<span class="built_in">readonly</span>, copy) NSString* debugDescription;</span><br><span class="line">		@property (retain, nonatomic) MMMsgContentNavBar* tipsNavBar;  (@synthesize tipsNavBar = _tipsNavBar;)</span><br><span class="line">		@property (retain, nonatomic) MMNewMsgContentNavBar* tipsNewNavBar;  (@synthesize tipsNewNavBar = _tipsNewNavBar;)</span><br><span class="line">		@property (retain, nonatomic) MessageTipView* messageTipView;  (@synthesize messageTipView = _messageTipView;)</span><br><span class="line">		@property (retain, nonatomic) UIScreenEdgePanGestureRecognizer* popBackInteractivePopGesture;  (@synthesize popBackInteractivePopGesture = _popBackInteractivePopGesture;)</span><br><span class="line">		@property (retain, nonatomic) UIColor* chatroomBkgColor;  (@synthesize chatroomBkgColor = _chatroomBkgColor;)</span><br><span class="line">		@property (retain, nonatomic) CMessageWrap* locateMsg;  (@synthesize locateMsg = _locateMsg;)</span><br><span class="line">		@property (weak, nonatomic) &lt;BaseMsgContentDelgate&gt;* m_delegate;  (@synthesize m_delegate = m_delegate;)</span><br><span class="line">		@property (weak, nonatomic) &lt;BaseMsgContentInBackgroundThreadDelgate&gt;* m_backgroundThreadDelegate;  (@synthesize m_backgroundThreadDelegate = m_backgroundThreadDelegate;)</span><br><span class="line">		@property (retain, nonatomic) MMInputToolView* toolView;  (@synthesize toolView = _inputToolView;)</span><br><span class="line">		@property (retain, nonatomic) MMTimer* m_LockerTimer;  (@synthesize m_LockerTimer = m_LockerTimer;)</span><br><span class="line">		@property (retain, nonatomic) UIView* m_msgReceivingTipsView;  (@synthesize m_msgReceivingTipsView = m_msgReceivingTipsView;)</span><br><span class="line">		@property (retain, nonatomic) NSMutableArray* m_shareContacts;  (@synthesize m_shareContacts = m_shareContacts;)</span><br><span class="line">		@property (nonatomic) BOOL m_bIsInMainFrame;  (@synthesize m_bIsInMainFrame = _m_bIsInMainFrame;)</span><br><span class="line">		@property (nonatomic) unsigned long m_searchScene;  (@synthesize m_searchScene = m_searchScene;)</span><br><span class="line">		@property (retain, nonatomic) BadRoomLogicController* m_badRoomLogicController;  (@synthesize m_badRoomLogicController = _m_badRoomLogicController;)</span><br><span class="line">		@property (retain, nonatomic) MMRichTextCoverView* richTextCoverView;  (@synthesize richTextCoverView = _richTextCoverView;)</span><br><span class="line">		@property (retain, nonatomic) RichTextView* richTextView;  (@synthesize richTextView = _richTextView;)</span><br><span class="line">		@property (weak, nonatomic) MMInputMsgReferView* msgReferView;  (@synthesize msgReferView = _msgReferView;)</span><br><span class="line">		@property (nonatomic) unsigned int uiMultiSelectMaxCount;  (@synthesize uiMultiSelectMaxCount = _uiMultiSelectMaxCount;)</span><br><span class="line">		@property (nonatomic) unsigned int uiMultiSelectMaxMegaBytes;  (@synthesize uiMultiSelectMaxMegaBytes = _uiMultiSelectMaxMegaBytes;)</span><br><span class="line">		@property (retain, nonatomic) ChatRoomHistoryShareStat* oRoomHistoryStat;  (@synthesize oRoomHistoryStat = _oRoomHistoryStat;)</span><br><span class="line">		@property (retain, nonatomic) UIView* chatRoomDismissedView;  (@synthesize chatRoomDismissedView = _chatRoomDismissedView;)</span><br><span class="line">		@property (nonatomic) BOOL dismissWithoutReset;  (@synthesize dismissWithoutReset = _dismissWithoutReset;)</span><br><span class="line">		@property (<span class="built_in">readonly</span>) unsigned long <span class="built_in">hash</span>;</span><br><span class="line">		@property (<span class="built_in">readonly</span>) Class superclass;</span><br><span class="line">		@property (<span class="built_in">readonly</span>, copy) NSString* description;</span><br><span class="line">		@property (<span class="built_in">readonly</span>, copy) NSString* debugDescription;</span><br><span class="line">	Instance Methods:</span><br><span class="line">		- (Class) superclass; (0x11838d270)</span><br><span class="line">		- (unsigned long) <span class="built_in">hash</span>; (0x11838d204)</span><br><span class="line">		- (<span class="built_in">id</span>) description; (0x11838d144)</span><br><span class="line">		- (<span class="built_in">id</span>) debugDescription; (0x11838d084)</span><br><span class="line">		...</span><br><span class="line">		...</span><br><span class="line">		方法太多，后续都省略了</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用搜索功能，找到我们需要的方法 addMessageNode ：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">		- (void) MoreMsgBtnUpdate:(unsigned int)arg1 unReadCount:(unsigned int)arg2; (0x118382ec0)</span><br><span class="line">		- (void) setM_searchScene:(unsigned long)arg1; (0x1183744a0)</span><br><span class="line">		- (void) addNoMoreMessageNode:(<span class="built_in">id</span>)arg1 addMoreMsg:(BOOL)arg2; (0x1183837f4)</span><br><span class="line">		- (void) addMessageNode:(<span class="built_in">id</span>)arg1 layout:(BOOL)arg2 addMoreMsg:(BOOL)arg3; (0x11838347c)</span><br><span class="line">		- (void) updateBanner; (0x11837a644)</span><br><span class="line">		- (long) getTextViewMarkedLength; (0x118385bb8)</span><br><span class="line">		- (void) CancelRecording; (0x11837f898)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>后面的地址就是方法实现的内存地址。对它下断点，然后让程序继续运行</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(lldb) breakpoint <span class="built_in">set</span> --address 0x11838347c</span><br><span class="line">Breakpoint 1: <span class="built_in">where</span> = redEnveloper.dylib`_logos_method$_ungrouped$BaseMsgContentViewController$addMessageNode$layout$addMoreMsg$(BaseMsgContentViewController*, objc_selector*, objc_object*, bool, bool) at BaseMsgContentViewController.xm:491, address = 0x000000011838347c</span><br><span class="line">(lldb) c</span><br><span class="line">Process 12265 resuming</span><br></pre></td></tr></table></figure>

<p>再次发送一条新的消息过来，就可以看到断点被命中了：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Process 12265 stopped</span><br><span class="line">* thread <span class="comment">#1, queue = &#x27;com.apple.main-thread&#x27;, stop reason = breakpoint 1.1</span></span><br><span class="line">    frame <span class="comment">#0: 0x000000011838347c redEnveloper.dylib` _logos_method$_ungrouped$BaseMsgContentViewController$addMessageNode$layout$addMoreMsg$(self=0x0000000128322860, _cmd=&quot;\xa7\xb4\xba\U00000012\xa1%&quot;, arg1=0x000000010f1a96fa, arg2=false, arg3=false)  at BaseMsgContentViewController.xm:491</span></span><br><span class="line">   488 	- (void)onLoadMoreMessage &#123; %<span class="built_in">log</span>; %orig; &#125;</span><br><span class="line">   489 	- (void)initHistroyMessageNodeData &#123; %<span class="built_in">log</span>; %orig; &#125;</span><br><span class="line">   490 	- (void)replaceMessageNode:(<span class="built_in">id</span>)arg1 withMessageNodeList:(<span class="built_in">id</span>)arg2 &#123; %<span class="built_in">log</span>; %orig; &#125;</span><br><span class="line">-&gt; 491 	- (void)addMessageNode:(<span class="built_in">id</span>)arg1 layout:(_Bool)arg2 addMoreMsg:(_Bool)arg3 &#123; %<span class="built_in">log</span>; %orig; &#125;</span><br><span class="line">   492 	- (void)addChatViewModel:(<span class="built_in">id</span>)arg1 addMoreMsg:(_Bool)arg2 &#123; %<span class="built_in">log</span>; %orig; &#125;</span><br><span class="line">   493 	- (void)tryAddTipsNodeForInviteHistory:(<span class="built_in">id</span>)arg1 addMoreMsg:(_Bool)arg2 &#123; %<span class="built_in">log</span>; %orig; &#125;</span><br><span class="line">   494 	- (unsigned int)getNeedAddTimeWithMsgWrap:(<span class="built_in">id</span>)arg1 time:(unsigned int)arg2 &#123; %<span class="built_in">log</span>; unsigned int r = %orig; NSLog(@<span class="string">&quot; = %u&quot;</span>, r); <span class="built_in">return</span> r; &#125;</span><br><span class="line">Target 0: (WeChat) stopped.</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure>

<p>奇怪的是，断点怎么跑到了 redEnveloper.dylib 的 _logos_method… 中去了，其实这就是 Theos 的原理，它将我们写的代码制作成一个 dylib 文件，然后在启动目标进程的时候，注入到目标进程中去，所以我们在 tweak 中写的代码才会被执行。而断点断在这里的原因是 BaseMsgContentViewController.xm 中对 BaseMsgContentViewController 的所有方法进行了 hook 。</p>
<p>断点命中后，接下来使用 bt 命令查看调用堆栈信息：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(lldb) bt</span><br><span class="line">* thread <span class="comment">#1, queue = &#x27;com.apple.main-thread&#x27;, stop reason = breakpoint 1.1</span></span><br><span class="line">  * frame <span class="comment">#0: 0x000000011838347c redEnveloper.dylib` _logos_method$_ungrouped$BaseMsgContentViewController$addMessageNode$layout$addMoreMsg$(self=0x0000000128322860, _cmd=&quot;\xa7\xb4\xba\U00000012\xa1%&quot;, arg1=0x000000010f1a96fa, arg2=false, arg3=false)  at BaseMsgContentViewController.xm:491</span></span><br><span class="line">    frame <span class="comment">#1: 0x0000000100f83ac8 WeChat` ___lldb_unnamed_symbol12406  + 800</span></span><br><span class="line">    frame <span class="comment">#2: 0x000000010374b558 WeChat` ___lldb_unnamed_symbol184229  + 64</span></span><br><span class="line">    frame <span class="comment">#3: 0x0000000100f62ee4 WeChat` ___lldb_unnamed_symbol12051  + 624</span></span><br><span class="line">    frame <span class="comment">#4: 0x000000010df9bb70 WeChat` ___lldb_unnamed_symbol875987  + 244</span></span><br><span class="line">    frame <span class="comment">#5: 0x000000010df31348 WeChat` ___lldb_unnamed_symbol874420  + 168</span></span><br><span class="line">    frame <span class="comment">#6: 0x00000001030a7ea8 WeChat` ___lldb_unnamed_symbol157924  + 648</span></span><br><span class="line">    frame <span class="comment">#7: 0x000000010df52fd4 WeChat` ___lldb_unnamed_symbol874880  + 180</span></span><br><span class="line">    frame <span class="comment">#8: 0x000000018c47a690 Foundation` __NSThreadPerformPerform  + 336</span></span><br><span class="line">    frame <span class="comment">#9: 0x000000018b984f1c CoreFoundation` __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__  + 24</span></span><br><span class="line">    frame <span class="comment">#10: 0x000000018b984e9c CoreFoundation` __CFRunLoopDoSource0  + 88</span></span><br><span class="line">    frame <span class="comment">#11: 0x000000018b984784 CoreFoundation` __CFRunLoopDoSources0  + 176</span></span><br><span class="line">    frame <span class="comment">#12: 0x000000018b97f6c0 CoreFoundation` __CFRunLoopRun  + 1004</span></span><br><span class="line">    frame <span class="comment">#13: 0x000000018b97efb4 CoreFoundation` CFRunLoopRunSpecific  + 436</span></span><br><span class="line">    frame <span class="comment">#14: 0x000000018db8179c GraphicsServices` GSEventRunModal  + 104</span></span><br><span class="line">    frame <span class="comment">#15: 0x00000001b8211c38 UIKitCore` UIApplicationMain  + 212</span></span><br><span class="line">    frame <span class="comment">#16: 0x0000000106bc8968 WeChat` ___lldb_unnamed_symbol399385  + 956</span></span><br><span class="line">    frame <span class="comment">#17: 0x000000018b4428e0 libdyld.dylib` start  + 4</span></span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure>

<p>堆栈中出现了很多 ___lldb_unnamed_symbol 未命名的符号，导致我们无法知道具体的调用关系。有几种方式都可以让我们得到想要的信息。</p>
<ul>
<li><p>第一种：使用调用栈帧中的地址减去当前可执行文件在内存中的地址，就得到了这段代码在 MachO 文件中的位置，然后通过反汇编工具，Hopper，ida，ghidra 等就可以找到这段代码所属的方法是什么了。</p>
</li>
<li><p>第二种：使用 sbt，如果一次 sbt 的结果没有成功，那么多试几次，总会有些成功的。sbt 是这个 LLDB <a href="https://github.com/DerekSelander/LLDB">插件</a>中添加的，按照提示安装之后就有了。</p>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(lldb) sbt</span><br><span class="line">frame <span class="comment">#0 : 0x11838347c redEnveloper.dylib`_logos_method$_ungrouped$BaseMsgContentViewController$addMessageNode$layout$addMoreMsg$(BaseMsgContentViewController*, objc_selector*, objc_object*, bool, bool)</span></span><br><span class="line">frame <span class="comment">#1 : 0x100f83ac8 WeChat`-[BaseMsgContentLogicController DidAddMsg:] + 800</span></span><br><span class="line">frame <span class="comment">#2 : 0x10374b558 WeChat`-[RoomContentLogicController DidAddMsg:] + 64</span></span><br><span class="line">frame <span class="comment">#3 : 0x100f62ee4 WeChat`-[BaseMsgContentLogicController OnAddMsg:MsgWrap:] + 624</span></span><br><span class="line">frame <span class="comment">#4 : 0x10df9bb70 WeChat`-[MMExtensionCenter callExtension:selector:block:] + 244</span></span><br><span class="line">frame <span class="comment">#5 : 0x10df31348 WeChat`-[MMContext callExtension:selector:block:] + 168</span></span><br><span class="line">frame <span class="comment">#6 : 0x1030a7ea8 WeChat`-[CMessageMgr MainThreadNotifyToExt:] + 648</span></span><br><span class="line">frame <span class="comment">#7 : 0x10df52fd4 WeChat`___lldb_unnamed_symbol874880 ... unresolved womp womp + 180</span></span><br><span class="line">frame <span class="comment">#8 : 0x18c47a690 Foundation`__NSThreadPerformPerform + 336</span></span><br><span class="line">frame <span class="comment">#9 : 0x18b984f1c CoreFoundation`__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 24</span></span><br><span class="line">frame <span class="comment">#10: 0x18b984e9c CoreFoundation`__CFRunLoopDoSource0 + 88</span></span><br><span class="line">frame <span class="comment">#11: 0x18b984784 CoreFoundation`__CFRunLoopDoSources0 + 176</span></span><br><span class="line">frame <span class="comment">#12: 0x18b97f6c0 CoreFoundation`__CFRunLoopRun + 1004</span></span><br><span class="line">frame <span class="comment">#13: 0x18b97efb4 CoreFoundation`CFRunLoopRunSpecific + 436</span></span><br><span class="line">frame <span class="comment">#14: 0x18db8179c GraphicsServices`GSEventRunModal + 104</span></span><br><span class="line">frame <span class="comment">#15: 0x1b8211c38 UIKitCore`UIApplicationMain + 212</span></span><br><span class="line">frame <span class="comment">#16: 0x106bc8968 WeChat`___lldb_unnamed_symbol399385 ... unresolved womp womp + 956</span></span><br><span class="line">frame <span class="comment">#17: 0x18b4428e0 libdyld.dylib`start + 4</span></span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure>

<p>从调用堆栈中，看到了一个 <code>CMessageMgr</code> 类。从名称来看它叫消息管理者，一定可以从中得到更多信息。继续使用 logify.pl 将 <code>CMessageMgr</code> 类的全部方法进行 hook 并查看打印。会发现消息发送过来的时候，很多方法会执行，但是以下这个方法是比较合适的，因为能拿到消息参数。</p>
<p><img src="Xnip2024-10-13_15-21-40.jpg"></p>
<p>最终找到 -[CMessageMgr onNewSyncAddMessage:] 方法。当然不是一定要这个方法，其他任何合适的方法都可以进行抢红包的。定位到收到微信消息的方法之后，自然就是分析如何开红包了，其实从正向开发的经验可以猜测，一定是点击红包的按钮之后，发生网络请求打开红包了。</p>
<h2 id="2-定位打开红包的方法"><a href="#2-定位打开红包的方法" class="headerlink" title="2.定位打开红包的方法"></a>2.定位打开红包的方法</h2><p>这个相对来说简单一点，从 UI 入手。越狱设备点开一个红包，使用 Reveal 查看开按钮，复制按钮的内存地址，如下图:</p>
<p><img src="Xnip2024-10-10_10-30-57.png"><br><img src="Xnip2024-10-13_15-34-23.jpg"></p>
<p>我发现新版本的 Reveal 还没有老版本的好用呢，明明老版本的 Reveal 可以显示到具体的拆红包按钮，新版本却只能显示一个整体。</p>
<p>然后使用 lldb+debugserver 进行远程调试：</p>
<p>先远程登录越狱设备，使用 debugserver 附加到微信进程：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> ~/ ssh root@localhost -p 2222</span><br><span class="line">iPhone5s:~ root# debugserver-10 localhost:3333 --attach=WeChat</span><br><span class="line">debugserver-@(#)PROGRAM:LLDB  PROJECT:lldb-10.0.0</span><br><span class="line"> <span class="keyword">for</span> arm64.</span><br><span class="line">Attaching to process WeChat...</span><br><span class="line">Listening to port 3333 <span class="keyword">for</span> a connection from localhost...</span><br><span class="line">Waiting <span class="keyword">for</span> debugger instructions <span class="keyword">for</span> process 0.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示：这里进行了两个端口转发，一个 2222:22，另一个是 3333:3333，所以才能正常运行。<code>iproxy 2222:22 3333:3333</code></p>
</blockquote>
<p>然后进入 lldb 并调试这个按钮的 target 和 action ：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> ~/ lldb</span><br><span class="line">(lldb) process connect connect://localhost:3333</span><br><span class="line">Process 12437 stopped</span><br><span class="line">* thread <span class="comment">#1, queue = &#x27;com.apple.main-thread&#x27;, stop reason = signal SIGSTOP</span></span><br><span class="line">    frame <span class="comment">#0: 0x000000018b5840f4 libsystem_kernel.dylib` mach_msg_trap  + 8</span></span><br><span class="line">libsystem_kernel.dylib`mach_msg_trap:</span><br><span class="line">-&gt;  0x18b5840f4 &lt;+8&gt;: ret</span><br><span class="line">libsystem_kernel.dylib<span class="string">&#x27;mach_msg_overwrite_trap:    0x18b5840f8 &lt;+0&gt;: mov    x16, #-0x20</span></span><br><span class="line"><span class="string">    0x18b5840fc &lt;+4&gt;: svc    #0x80</span></span><br><span class="line"><span class="string">    0x18b584100 &lt;+8&gt;: ret</span></span><br><span class="line"><span class="string">libsystem_kernel.dylib&#x27;</span>semaphore_signal_trap:    0x18b584104 &lt;+0&gt;: mov    x16, <span class="comment">#-0x21</span></span><br><span class="line">    0x18b584108 &lt;+4&gt;: svc    <span class="comment">#0x80</span></span><br><span class="line">    0x18b58410c &lt;+8&gt;: ret</span><br><span class="line">libsystem_kernel.dylib<span class="string">&#x27;semaphore_signal_all_trap:    0x18b584110 &lt;+0&gt;: mov    x16, #-0x22</span></span><br><span class="line"><span class="string">Target 0: (WeChat) stopped.</span></span><br><span class="line"><span class="string">(lldb) po [0x1476a1000 allTargets]</span></span><br><span class="line"><span class="string">&#123;(</span></span><br><span class="line"><span class="string">    &lt;WCRedEnvelopesReceiveHomeView: 0x147693670; frame = (0 0; 320 568); clipsToBounds = YES; autoresize = W+H; layer = &lt;CALayer: 0x2829f1480&gt;&gt;</span></span><br><span class="line"><span class="string">)&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">(lldb) po [0x1476a1000 actionsForTarget:0x147693670 forControlEvent:64]</span></span><br><span class="line"><span class="string">&lt;__NSArrayM 0x286397990&gt;(</span></span><br><span class="line"><span class="string">OnOpenRedEnvelopes</span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">(lldb)</span></span><br></pre></td></tr></table></figure>

<p>找到了 <code>-[WCRedEnvelopesReceiveHomeView OnOpenRedEnvelopes]</code> 方法。找到这个方法就能成功实现抢红包功能了吗？当然没有那么简单。我们在收到微信消息的时候，很可能连聊天页面都没有进入，更不可能存在 <code>WCRedEnvelopesReceiveHomeView</code> 对象了，所以无法调用这个方法。有人会想，我自己创建一个 <code>WCRedEnvelopesReceiveHomeView</code> 对象调用 <code>OnOpenRedEnvelopes</code> 方法能不能行呢。前提是你得知道 <code>WCRedEnvelopesReceiveHomeView</code> 正确的初始化方法啊。微信开发人员在创建 <code>WCRedEnvelopesReceiveHomeView</code> 对象的时候肯定给了其他的参数，你不能认为调用一个 <code>initWithFrame:</code> 方法创建一个 <code>WCRedEnvelopesReceiveHomeView</code> 对象之后就万事大吉了。所以还得继续分析开红包的具体代码。这就需要静态分析反汇编代码了，从汇编代码尝试还原出源码。关于 iOS 的 arm64 汇编的文章，也在准备当中。。。敬请期待</p>
<h2 id="3-静态分析开红包的方法"><a href="#3-静态分析开红包的方法" class="headerlink" title="3.静态分析开红包的方法"></a>3.静态分析开红包的方法</h2><p>定位到开红包的方法之后，需要反编译分析这个方法，看看是如何打开红包的，这就需要用到常见的反编译工具如：IDA Pro，Ghidra，Hopper Disassembler 等。这里以 Hopper 为例:</p>
<p><img src="Xnip2024-10-10_13-16-08.png"></p>
<p><code>OnOpenRedEnvelopes</code> 方法的倒数第三个 bl 跳转指令，后面指向的是 objc_msgSend 函数，如果知道了它的参数是什么，也就知道了方法最后的走向是什么。所以我们给它下一个断点，但是这个地址 0x10556c8ac 只是在 MachO 文件中的地址，实际内存中的地址，还需要加上 MachO 文件在内存中的首地址，可以使用 <code>image list -o -f WeChat</code> 来获取。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(lldb) image list -o -f WeChat</span><br><span class="line">[  0] 0x000000000093c000 /var/containers/Bundle/Application/E51AA5D1-C65C-4E5B-A4AB-34C88E760D49/WeChat.app/WeChat(0x000000010093c000)</span><br></pre></td></tr></table></figure>

<p>接下来将两者相加，就可以用来下内存断点了</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(lldb) p/x 0x10556c8ac+0x000000000093c000</span><br><span class="line">(long) 0x0000000105ea88ac</span><br><span class="line">(lldb) breakpoint <span class="built_in">set</span> --address 0x0000000105ea88ac</span><br><span class="line">Breakpoint 1: <span class="built_in">where</span> = WeChat`___lldb_unnamed_symbol363752 + 304, address = 0x0000000105ea88ac</span><br><span class="line">(lldb) c</span><br><span class="line">Process 12437 resuming</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure>

<p>断点下好之后，c 让程序继续执行，然后我们点击开红包按钮，此时断点命中，我们读取寄存器的内容：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Process 12437 stopped</span><br><span class="line">* thread <span class="comment">#1, queue = &#x27;com.apple.main-thread&#x27;, stop reason = breakpoint 1.1</span></span><br><span class="line">    frame <span class="comment">#0: 0x0000000105ea88ac WeChat` ___lldb_unnamed_symbol363752  + 304</span></span><br><span class="line">WeChat`___lldb_unnamed_symbol363752:</span><br><span class="line">-&gt;  0x105ea88ac &lt;+304&gt;: bl     0x10853ffe4               ; ___lldb_unnamed_symbol518292</span><br><span class="line">    0x105ea88b0 &lt;+308&gt;: mov    x0, x19</span><br><span class="line">    0x105ea88b4 &lt;+312&gt;: bl     0x10853ffcc               ; ___lldb_unnamed_symbol518286</span><br><span class="line">    0x105ea88b8 &lt;+316&gt;: mov    x0, x20</span><br><span class="line">    0x105ea88bc &lt;+320&gt;: ldp    x29, x30, [sp, <span class="comment">#0x60]</span></span><br><span class="line">    0x105ea88c0 &lt;+324&gt;: ldp    x20, x19, [sp, <span class="comment">#0x50]</span></span><br><span class="line">    0x105ea88c4 &lt;+328&gt;: ldp    x22, x21, [sp, <span class="comment">#0x40]</span></span><br><span class="line">    0x105ea88c8 &lt;+332&gt;: ldp    x24, x23, [sp, <span class="comment">#0x30]</span></span><br><span class="line">Target 0: (WeChat) stopped.</span><br><span class="line">(lldb) register <span class="built_in">read</span> x0</span><br><span class="line">      x0 = 0x0000000281d49a40</span><br><span class="line">(lldb) po 0x0000000281d49a40</span><br><span class="line">&lt;WCRedEnvelopesReceiveControlLogic: 0x281d49a40&gt;</span><br><span class="line"></span><br><span class="line">(lldb) register <span class="built_in">read</span> x1</span><br><span class="line">      x1 = 0x000000010f1c6cc5  <span class="string">&quot;WCRedEnvelopesReceiveHomeViewOpenRedEnvelopes&quot;</span></span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure>

<p>通过对寄存器的读取，我们得知此时，调用了 <code>-[WCRedEnvelopesReceiveControlLogic WCRedEnvelopesReceiveHomeViewOpenRedEnvelopes]</code> 方法。终于来到了真正开红包的地方了！以及红包相关的逻辑处理的类 <code>WCRedEnvelopesReceiveControlLogic</code>。</p>
<p>继续查看反汇编之后的代码，可以看出这个方法中，拼接了一个字典参数，然后通过调用 <code>OpenRedEnvelopesRequest:</code> 方法发送了请求。</p>
<p>使用 logify.pl 将 <code>WCRedEnvelopesReceiveControlLogic</code> 的所有方法进行 hook，这下我们可以清晰的看到开红包的过程了。在聊天界面点击红包的时候，首先会调用查红包的接口 <code>ReceiverQueryRedEnvelopesRequest:</code> 它返回了一个重要的参数 <code>timingIdentifier</code>，之后显示了开红包的界面，点击开按钮才是开红包的请求 <code>OpenRedEnvelopesRequest:</code>，用到了这个参数。</p>
<h2 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h2><p>此时，我们的需要做的就是将逻辑完善。在收到微信消息的时候，判断是红包消息就发送一个查红包的请求，在它的响应回来的时候，判断是否开了自动抢红包，开了就调用开红包的请求。这就是自动抢红包的完整逻辑了。还有判断是否是红包消息，是否是未拆开的红包等判断逻辑也不用我们自己去猜，微信肯定有它自己的判断，我们只需要找到对应的代码拿过来用就行了，但这都是些小细节了就不再深入了。</p>
<p>最终的完整代码下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WCTableViewManager</span></span></span><br><span class="line">- (<span class="type">long</span> <span class="type">long</span>)numberOfSectionsInTableView:(<span class="type">id</span>)arg1;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSMutableDictionary</span> (<span class="title">safeSetObject</span>)</span></span><br><span class="line">- (<span class="type">void</span>)safeSetObject:(<span class="type">id</span>)arg1 forKey:(<span class="type">id</span>)arg2;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WCBizUtil</span></span></span><br><span class="line">+ (<span class="type">id</span>)dictionaryWithDecodedComponets:(<span class="type">id</span>)arg1 separator:(<span class="type">id</span>)arg2;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SKBuiltinBuffer_t</span></span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">retain</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSData</span> *buffer; <span class="comment">// @dynamic buffer;</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="type">unsigned</span> <span class="type">int</span> iLen; <span class="comment">// @dynamic iLen;</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">BaseRequest</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">HongBaoReq</span></span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">retain</span>, <span class="keyword">nonatomic</span>) BaseRequest *baseRequest; <span class="comment">// @dynamic baseRequest;</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="type">unsigned</span> <span class="type">int</span> cgiCmd; <span class="comment">// @dynamic cgiCmd;</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="type">unsigned</span> <span class="type">int</span> outPutType; <span class="comment">// @dynamic outPutType;</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">retain</span>, <span class="keyword">nonatomic</span>) <span class="built_in">SKBuiltinBuffer_t</span> *reqText; <span class="comment">// @dynamic reqText;</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">HongBaoRes</span></span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="type">int</span> cgiCmdid; <span class="comment">// @dynamic cgiCmdid;</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">retain</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *errorMsg; <span class="comment">// @dynamic errorMsg;</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="type">int</span> errorType; <span class="comment">// @dynamic errorType;</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">retain</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *platMsg; <span class="comment">// @dynamic platMsg;</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="type">int</span> platRet; <span class="comment">// @dynamic platRet;</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">retain</span>, <span class="keyword">nonatomic</span>) <span class="built_in">SKBuiltinBuffer_t</span> *retText; <span class="comment">// @dynamic retText;</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CContact</span></span></span><br><span class="line">- (<span class="type">id</span>)getContactDisplayName;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">retain</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *m_nsHeadImgUrl;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CContactMgr</span></span></span><br><span class="line">- (<span class="type">id</span>)getSelfContact;</span><br><span class="line">- (<span class="type">id</span>)getContactByNameFromCache:(<span class="type">id</span>)cache;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WCRedEnvelopesLogicMgr</span></span></span><br><span class="line">- (<span class="type">void</span>)ReceiverQueryRedEnvelopesRequest:(<span class="type">id</span>)arg1;</span><br><span class="line">- (<span class="type">void</span>)OpenRedEnvelopesRequest:(<span class="type">id</span>)arg1;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MMContext</span></span></span><br><span class="line">+ (<span class="type">id</span>)currentContext;</span><br><span class="line">- (<span class="type">id</span>)getService:(Class)arg1;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MMMsgLogicManager</span></span></span><br><span class="line">- (<span class="built_in">UIViewController</span> *)GetCurrentLogicController;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WCPayInfoItem</span></span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">retain</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *m_c2cNativeUrl;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CMessageWrap</span></span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">retain</span>, <span class="keyword">nonatomic</span>) WCPayInfoItem *m_oWCPayInfoItem;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">retain</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *m_nsRealChatUsr;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">retain</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *m_nsFromUsr;</span><br><span class="line">- (<span class="type">void</span>)parseWCPayInfoItemIfNeed;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WCPayC2CMessageViewModel</span></span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">retain</span>, <span class="keyword">nonatomic</span>) <span class="built_in">CMessageWrap</span> *messageWrap;</span><br><span class="line">+ (<span class="type">BOOL</span>)canCreateMessageViewModelWithMessageWrap:(<span class="type">id</span>)wrap;</span><br><span class="line">+ (<span class="type">id</span>)createMessageViewModelWithMessageWrap:(<span class="type">id</span>)arg1 contact:(<span class="type">id</span>)arg2 chatContact:(<span class="type">id</span>)arg3;</span><br><span class="line">- (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)bubbleType;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 界面代码</span></span><br><span class="line">%hook WCTableViewManager</span><br><span class="line">- (<span class="type">double</span>)tableView:(<span class="built_in">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class="type">id</span>)indexPath&#123;</span><br><span class="line">    <span class="keyword">if</span>([tableView.nextResponder.nextResponder isKindOfClass:%c(NewSettingViewController)]</span><br><span class="line">       &amp;&amp;([indexPath section] == [<span class="keyword">self</span> numberOfSectionsInTableView:tableView] - <span class="number">1</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">44</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> %orig;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">id</span>)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="type">id</span>)indexPath&#123;</span><br><span class="line">    <span class="keyword">if</span>([tableView.nextResponder.nextResponder isKindOfClass:%c(NewSettingViewController)]</span><br><span class="line">       &amp;&amp;([indexPath section] == [<span class="keyword">self</span> numberOfSectionsInTableView:tableView] - <span class="number">1</span>))&#123;</span><br><span class="line">        <span class="built_in">UITableViewCell</span> * cell = [[<span class="built_in">UITableViewCell</span> alloc] initWithStyle:(<span class="built_in">UITableViewCellStyleDefault</span>) reuseIdentifier:<span class="literal">nil</span>];</span><br><span class="line">        cell.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">        <span class="keyword">if</span>([indexPath row] == <span class="number">0</span>)&#123;</span><br><span class="line">            cell.textLabel.text = <span class="string">@&quot;自动抢红包&quot;</span>;</span><br><span class="line">            <span class="built_in">UISwitch</span> * switchView = [[<span class="built_in">UISwitch</span> alloc] init];</span><br><span class="line">            switchView.on = [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] boolForKey:<span class="string">@&quot;RESWITCHKEY&quot;</span>];</span><br><span class="line">            [switchView addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(switchChang:) forControlEvents:(<span class="built_in">UIControlEventValueChanged</span>)];</span><br><span class="line">            cell.accessoryView = switchView;</span><br><span class="line">            <span class="built_in">NSBundle</span> *bundle = [<span class="built_in">NSBundle</span> bundleWithPath:<span class="string">@&quot;/Library/MobileSubstrate/DynamicLibraries/redEnveloper.bundle/&quot;</span>];</span><br><span class="line">            <span class="built_in">NSString</span> *imageName = ([[<span class="built_in">NSUserDefaults</span> standardUserDefaults] boolForKey:<span class="string">@&quot;RESWITCHKEY&quot;</span>] == <span class="number">1</span>) ? <span class="string">@&quot;locked.png&quot;</span> : <span class="string">@&quot;unlocked.png&quot;</span>;</span><br><span class="line">            <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:imageName inBundle:bundle compatibleWithTraitCollection:<span class="literal">nil</span>];</span><br><span class="line">            cell.imageView.image = image;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cell;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> %orig;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">long</span> <span class="type">long</span>)tableView:(<span class="built_in">UITableView</span> *)tableView numberOfRowsInSection:(<span class="type">long</span> <span class="type">long</span>)section&#123;</span><br><span class="line">    <span class="keyword">if</span>([tableView.nextResponder.nextResponder isKindOfClass:%c(NewSettingViewController)]</span><br><span class="line">       &amp;&amp;(section == [<span class="keyword">self</span> numberOfSectionsInTableView:tableView] - <span class="number">1</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> %orig;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">long</span> <span class="type">long</span>)numberOfSectionsInTableView:(<span class="built_in">UITableView</span> *)tableView&#123;</span><br><span class="line">    <span class="keyword">if</span>([tableView.nextResponder.nextResponder isKindOfClass:%c(NewSettingViewController)])&#123;</span><br><span class="line">        <span class="keyword">return</span> %orig+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> %orig;</span><br><span class="line">&#125;</span><br><span class="line">%new</span><br><span class="line">-(<span class="type">void</span>)switchChang:(<span class="built_in">UISwitch</span> *)switchView&#123;</span><br><span class="line">    [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] setBool:switchView.isOn forKey:<span class="string">@&quot;RESWITCHKEY&quot;</span>];</span><br><span class="line">    [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] synchronize];</span><br><span class="line">    [MSHookIvar&lt;<span class="built_in">UITableView</span> *&gt;(<span class="keyword">self</span>,<span class="string">&quot;_tableView&quot;</span>) reloadData];</span><br><span class="line">&#125;</span><br><span class="line">%end</span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能实现代码</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AutoGrabRedEnvelopeMgr</span> : <span class="title">NSObject</span></span>&#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *_array;<span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)shared;</span><br><span class="line">- (<span class="type">BOOL</span>)isEmpty;</span><br><span class="line">- (<span class="type">void</span>)enqueueDictionary:(<span class="built_in">NSDictionary</span> *)parameter;</span><br><span class="line">- (<span class="built_in">NSDictionary</span> *)dequeueDictionary;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AutoGrabRedEnvelopeMgr</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)shared&#123;</span><br><span class="line">    <span class="keyword">static</span> AutoGrabRedEnvelopeMgr *mgr = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        mgr = [[[<span class="keyword">self</span> <span class="keyword">class</span>] alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> mgr;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">instancetype</span>)init&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="variable language_">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _array = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">BOOL</span>)isEmpty &#123;</span><br><span class="line">    <span class="keyword">return</span> _array.count == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)enqueueDictionary:(<span class="built_in">NSDictionary</span> *)parameter &#123;</span><br><span class="line">    [_array addObject:parameter];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">NSDictionary</span> *)dequeueDictionary &#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> isEmpty]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSDictionary</span> *dict = [_array firstObject];</span><br><span class="line">        [_array removeObjectAtIndex:<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> dict;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初步分析每次收到消息的时候,都会调用到这个方法,那么就可以在这个方法里面进行抢红包;</span></span><br><span class="line">%hook <span class="built_in">CMessageMgr</span></span><br><span class="line">- (<span class="type">void</span>)onNewSyncAddMessage:(<span class="type">id</span>)arg1 &#123; <span class="comment">//CMessageWrap</span></span><br><span class="line">    <span class="comment">// 需要判断一下是否是红包消息,不然每次一有消息过来就去拆红包开红包不合理</span></span><br><span class="line">    <span class="keyword">if</span> ([%c(WCPayC2CMessageViewModel) canCreateMessageViewModelWithMessageWrap:arg1]) &#123; <span class="comment">// 这里确定是红包消息</span></span><br><span class="line">        WCPayC2CMessageViewModel *model = [%c(WCPayC2CMessageViewModel) createMessageViewModelWithMessageWrap:arg1 contact:<span class="literal">nil</span> chatContact:<span class="literal">nil</span>];</span><br><span class="line">        [model.messageWrap parseWCPayInfoItemIfNeed];</span><br><span class="line">        <span class="keyword">if</span> (model.bubbleType == <span class="number">4</span>) &#123; <span class="comment">// 未打开的红包</span></span><br><span class="line">            <span class="keyword">if</span> ([[<span class="built_in">NSUserDefaults</span> standardUserDefaults] boolForKey:<span class="string">@&quot;RESWITCHKEY&quot;</span>]) &#123; <span class="comment">// 打开了自动抢红包</span></span><br><span class="line">                <span class="built_in">NSString</span> *m_c2cNativeUrl = model.messageWrap.m_oWCPayInfoItem.m_c2cNativeUrl;</span><br><span class="line">                <span class="built_in">NSUInteger</span> len = [<span class="string">@&quot;wxpay://c2cbizmessagehandler/hongbao/receivehongbao?&quot;</span> length];</span><br><span class="line">                <span class="built_in">NSString</span> * substring = [m_c2cNativeUrl substringFromIndex:len];</span><br><span class="line">                <span class="built_in">NSDictionary</span> * dict = [%c(WCBizUtil) dictionaryWithDecodedComponets:substring separator:<span class="string">@&quot;&amp;&quot;</span>];</span><br><span class="line">                <span class="built_in">NSMutableDictionary</span> * parameter = [%c(<span class="built_in">NSMutableDictionary</span>) dictionary];</span><br><span class="line">                [parameter safeSetObject:<span class="string">@&quot;1&quot;</span> forKey:<span class="string">@&quot;msgType&quot;</span>];</span><br><span class="line">                [parameter safeSetObject:[dict objectForKey:<span class="string">@&quot;sendid&quot;</span>] forKey:<span class="string">@&quot;sendId&quot;</span>];</span><br><span class="line">                [parameter safeSetObject:[dict objectForKey:<span class="string">@&quot;channelid&quot;</span>] forKey:<span class="string">@&quot;channelId&quot;</span>];</span><br><span class="line">                [parameter safeSetObject:m_c2cNativeUrl forKey:<span class="string">@&quot;nativeUrl&quot;</span>];</span><br><span class="line">                MMMsgLogicManager *msgLogicMgr = [[%c(MMContext) currentContext] getService:[%c(MMMsgLogicManager) <span class="keyword">class</span>]];</span><br><span class="line">                <span class="built_in">UIViewController</span> * vc = [msgLogicMgr GetCurrentLogicController];</span><br><span class="line">                <span class="built_in">NSString</span> *inWay;</span><br><span class="line">                <span class="keyword">if</span> (vc == <span class="literal">nil</span> || [vc valueForKey:<span class="string">@&quot;m_contact&quot;</span>] == <span class="literal">nil</span> || ![[vc valueForKey:<span class="string">@&quot;m_contact.isChatroom&quot;</span>] boolValue]) &#123;</span><br><span class="line">                    inWay = <span class="string">@&quot;1&quot;</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    inWay = <span class="string">@&quot;0&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                [parameter safeSetObject:inWay forKey:<span class="string">@&quot;inWay&quot;</span>];</span><br><span class="line">                [parameter safeSetObject:<span class="string">@&quot;0&quot;</span> forKey:<span class="string">@&quot;agreeDuty&quot;</span>];</span><br><span class="line">                WCRedEnvelopesLogicMgr *mgr = [[%c(MMContext) currentContext] getService:[%c(WCRedEnvelopesLogicMgr) <span class="keyword">class</span>]];</span><br><span class="line">                [mgr ReceiverQueryRedEnvelopesRequest:[parameter <span class="keyword">copy</span>]];</span><br><span class="line">                [parameter safeSetObject:model.messageWrap.m_nsFromUsr forKey:<span class="string">@&quot;sessionUserName&quot;</span>];</span><br><span class="line">                [AutoGrabRedEnvelopeMgr.shared enqueueDictionary:parameter];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    %orig;</span><br><span class="line">&#125;</span><br><span class="line">%end</span><br><span class="line"></span><br><span class="line">%hook WCRedEnvelopesLogicMgr</span><br><span class="line">- (<span class="type">void</span>)OnWCToHongbaoCommonResponse:(HongBaoRes *)arg1 Request:(HongBaoReq *)arg2&#123;</span><br><span class="line">    %orig;</span><br><span class="line">    <span class="built_in">NSError</span> *error;</span><br><span class="line">    <span class="built_in">NSDictionary</span> *response = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:arg1.retText.buffer options:<span class="built_in">NSJSONReadingMutableContainers</span> error:&amp;error];</span><br><span class="line">    <span class="keyword">if</span> (arg1.cgiCmdid == <span class="number">3</span>) &#123; <span class="comment">// 表示拆红包,开红包的前一个步骤</span></span><br><span class="line">        <span class="keyword">if</span> (![AutoGrabRedEnvelopeMgr.shared isEmpty] &amp;&amp; [response[<span class="string">@&quot;timingIdentifier&quot;</span>] length] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">NSMutableDictionary</span> *dic = [AutoGrabRedEnvelopeMgr.shared dequeueDictionary].mutableCopy;</span><br><span class="line">            dic[<span class="string">@&quot;timingIdentifier&quot;</span>] = response[<span class="string">@&quot;timingIdentifier&quot;</span>];</span><br><span class="line">            MMContext *context = [%c(MMContext) currentContext];</span><br><span class="line">            CContactMgr *contactMgr = [context getService:[%c(CContactMgr) <span class="keyword">class</span>]];</span><br><span class="line">            CContact *contact = [contactMgr getSelfContact];</span><br><span class="line">            <span class="built_in">NSString</span> *displayName = [contact getContactDisplayName];</span><br><span class="line">            [dic setObject:displayName forKey:<span class="string">@&quot;nickName&quot;</span>];</span><br><span class="line">            <span class="built_in">NSString</span> *headImgUrl = [contact m_nsHeadImgUrl];</span><br><span class="line">            [dic setObject:headImgUrl forKey:<span class="string">@&quot;headImg&quot;</span>];</span><br><span class="line">            <span class="keyword">if</span> ([dic objectForKey:<span class="string">@&quot;agreeDuty&quot;</span>]) [dic removeObjectForKey:<span class="string">@&quot;agreeDuty&quot;</span>];</span><br><span class="line">            <span class="keyword">if</span> ([dic objectForKey:<span class="string">@&quot;inWay&quot;</span>]) [dic removeObjectForKey:<span class="string">@&quot;inWay&quot;</span>];</span><br><span class="line">            dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">0.5</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                [<span class="keyword">self</span> OpenRedEnvelopesRequest:dic]; </span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">%end</span><br></pre></td></tr></table></figure>

<p>代码完成之后，我们进入终端，cd 到项目的文件夹下，编译打包安装之后，再次进入微信，找到自动抢红包的开关，打开之后，给这个微信账号发送一个红包试试有没有成功！</p>
<p>可以看到实现自动抢红包的 UI 和功能的代码并不是很多，仅仅 200 多行，但是这 200 多行的代码要能自己写出来也是真的挺不容易的。</p>
]]></content>
      <categories>
        <category>iOS 逆向与安全</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>逆向</tag>
        <tag>微信</tag>
        <tag>插件</tag>
      </tags>
  </entry>
</search>
