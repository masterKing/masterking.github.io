<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>OC与iOS混编</title>
    <url>/2019/04/12/2019-04-12-OC%E4%B8%8EiOS%E6%B7%B7%E7%BC%96/</url>
    <content><![CDATA[<h1 id="记录一下-OC和Swift混编的问题"><a href="#记录一下-OC和Swift混编的问题" class="headerlink" title="记录一下,OC和Swift混编的问题"></a>记录一下,OC和Swift混编的问题</h1><p>在OC项目中,需要使用Swift的时候,一般情况下,在你的OC项目中新建一个Swift文件的时候,系统会自动提示你是否需要配置一个Objective-C桥接头文件,如下图:<img src="https://github.com/masterKing/markDownPictures/blob/master/Snip20190412_4.png?raw=true"><br>点击最右侧的创建桥接头文件,系统就会帮你配置创建并配置好一个桥接头文件…这个桥接头文件的作用是,让你可以在Swift代码中使用OC中的类;只需要将你需要在Swift代码中使用的类的头文件在桥接头文件中导入一下就可以使用了;如果一不小心点击了Don’t Create按钮,那就需要你自己再手动创建一个头文件,将它配置成桥接头文件,才可以使用.配置步骤如下:</p>
<ol>
<li>创建一个头文件<br> <img src="https://github.com/masterKing/markDownPictures/blob/master/Snip20190412_5.png?raw=true"><br> <img src="https://github.com/masterKing/markDownPictures/blob/master/Snip20190412_6.png?raw=true"></li>
<li>配置成为OC桥接头文件<br> <img src="https://github.com/masterKing/markDownPictures/blob/master/Snip20190412_7.png?raw=true"><br>在里面导入OC的头文件,就可以在Swift代码中使用了</li>
</ol>
<p>如果是想要在OC的代码中使用Swift的类的话,这个就更加简单了,只需要导入一个系统自动生成的头文件就可以访问了,这个头文件在项目目录中看不到;但是在上图标记③的框框下面你可以看到它的名字,直接导入这个头文件就可以使用了,需要注意的是系统并不会自动补全这个头文件…没有提示,需要你自己一个一个字母敲进去</p>
<hr/>

<p>再来说一下,在Swift项目中,想要使用OC代码;跟上面的步骤是一样的,第一次在Swift项目中创建OC类的时候,系统就会提示你是否创建Objective-C桥接头文件;这个头文件的作用跟上是一样的,让你可以在Swift代码中使用OC的类,只需在这个头文件导入OC类就行了…在OC代码中想要使用Swift类也跟上面一样,导入系统自动生成的那个头文件就可以使用了</p>
]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一个报错</title>
    <url>/2019/04/25/2019-04-25-%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%AA%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<h1 id="Undefined-symbols-for-architecture-arm64"><a href="#Undefined-symbols-for-architecture-arm64" class="headerlink" title="Undefined symbols for architecture arm64"></a>Undefined symbols for architecture arm64</h1><p><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/master/Snip20190425_23.png">上面这个报错经常会遇到…但是一直不知道是为啥出现的…今天碰巧知道了出现的原因</p>
<p>错误出现的步骤是这样的</p>
<ul>
<li><ol>
<li>首先我新建了Director和ConcreteBuild两个类</li>
</ol>
</li>
<li><ol start="2">
<li>在viewController.m中我使用这两个类写了一些代码</li>
</ol>
</li>
<li><ol start="3">
<li>这个时候我觉得这两个类写的不好不想要了,于是全部删除了…</li>
</ol>
</li>
</ul>
<p>但此时在viewController.m中的代码还没有移除掉;再次编译运行的时候就会报<br>Undefined symbols for architecture arm64:<br>“_OBJC_CLASS_$_Director”, referenced from:<br>objc-class-ref in ViewController.o<br>知道了错误产生的原因之后,再解决问题就很容易了…去viewController.m文件中把相关的代码全删了就好了…<br>只是有点儿疑惑为什么xcode不报找不到头文件Director或ConcreteBuild错误,而报这个Undefined symbols for architecture arm64:错误…一脸懵</p>
]]></content>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2019/04/04/2019-04-04-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>#关于设计模式</p>
<table>
<thead>
<tr>
<th>*</th>
<th>*</th>
<th align="left">创建型</th>
<th align="left">结构型</th>
<th align="left">行为型</th>
</tr>
</thead>
<tbody><tr>
<td>范围</td>
<td>类</td>
<td align="left">Factory Method</td>
<td align="left">Adapter(类)</td>
<td align="left">Interpreter<br/>Template Method</td>
</tr>
<tr>
<td>*</td>
<td>对象</td>
<td align="left">Abstract Factory<br/>Builder<br/>Prototype<br/>Singleton</td>
<td align="left">Adapter(对象)<br/>Bridge<br/>Composite<br/>Decorator<br/>Facade<br/>Flyweight<br/>Proxy<br/></td>
<td align="left">Chain of Responsibility<br/>Command<br/>Iterator<br/>Mediator<br/>Memento<br/>Observer<br/>State<br/>Stragegy<br/>Visitor</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>MBProgressHUD源码解析</title>
    <url>/2020/06/24/2020-06-24-MBProgressHUD%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="MBProgressHUD"><a href="#MBProgressHUD" class="headerlink" title="MBProgressHUD"></a>MBProgressHUD</h1><p>从入行以来,就经常听说,学习编程进步最快的方式,就是阅读优秀作品的源码…</p>
<p>那么,今天我来阅读一下MBProgressHUD这个库的源码…</p>
<p>查看一下文件,非常简单的俩个MBProgressHUD.h和MBProgressHUD.m文件</p>
<p>没什么说的,从MBProgressHUD.h文件开始看吧;</p>
<p>头文件首先声明了一个自定义的类 <code>MBBackgroundView</code> 和 一个协议 <code>MBProgressHUDDelegate</code>,自定义类放在这里声明一下,应该是因为<code>MBProgressHUD</code>里面使用到了<code>MBBackgroundView</code>类,且<code>MBProgressHUD</code>的声明与实现都放在了<code>MBBackgroundView</code>的前面,将<code>MBBackgroundView</code>的位置挪到比<code>MBProgressHUD</code>靠前的地方就不需要提前声明了,这个很简单,不需要多说了吧;而代理协议<code>MBProgressHUDDelegate</code>,对于做过iOS的开发人来说,应该说是再熟悉不过了…</p>
<p>接下来声明了一个供外部使用的变量<code>extern CGFloat const MBProgressMaxOffset;</code>,使用<code>extern</code>修饰了的变量能够在其他文件也可以访问到;往下查看头文件的时候,发现是为了给属性<code>offset</code>使用的,注释里面写到可以使用CGPointMake(0.f, MBProgressMaxOffset)来使HUD的位置处于底部边缘的中心位置</p>
<p>然后是4个自定义类型,<code>MBProgressHUDMode``MBProgressHUDAnimation``MBProgressHUDBackgroundStyle``MBProgressHUDCompletionBlock</code>;这四个类型也都比较简单,见名字大概就知道是什么意思了,简单提一下;<br><code>MBProgressHUDMode</code>mode翻译过来叫(设备的)模式,方式,风格,样式…在这里取风格或者样式应该更加恰当;它有6种不同的样式:</p>
<ul>
<li><code>MBProgressHUDModeIndeterminate </code>	&#x2F;&#x2F;iOS系统原生的UIActivityIndicatorView</li>
<li><code>MBProgressHUDModeDeterminate </code>	&#x2F;&#x2F;一个圆形的饼状进度视图样式</li>
<li><code>MBProgressHUDModeDeterminateHorizontalBar </code>	&#x2F;&#x2F;一个水平的条状进度视图样式</li>
<li><code>MBProgressHUDModeAnnularDeterminate </code>	&#x2F;&#x2F;圆环形的进度视图样式</li>
<li><code>MBProgressHUDModeCustomView </code>	&#x2F;&#x2F;自定义视图样式</li>
<li><code>MBProgressHUDModeText </code> &#x2F;&#x2F;纯文字样式</li>
</ul>
<p><code>MBProgressHUDAnimation</code>动画类型</p>
<ul>
<li><code>MBProgressHUDAnimationFade</code> &#x2F;&#x2F;淡入淡出</li>
<li><code>MBProgressHUDAnimationZoom</code> &#x2F;&#x2F;出现时放大,消失时缩小</li>
<li><code>MBProgressHUDAnimationZoomOut</code> &#x2F;&#x2F;缩小</li>
<li><code>MBProgressHUDAnimationZoomIn</code> &#x2F;&#x2F;放大</li>
</ul>
<p><code>MBProgressHUDBackgroundStyle</code>背景风格</p>
<ul>
<li><code>MBProgressHUDBackgroundStyleSolidColor</code> &#x2F;&#x2F;纯色</li>
<li><code>MBProgressHUDBackgroundStyleBlur</code> &#x2F;&#x2F;模糊,毛玻璃效果</li>
</ul>
<p><code>MBProgressHUDCompletionBlock</code>是一个无返回值无参数的block</p>
<p>接来下是<code>MBProgressHUD</code>的正式声明了<br>首先是7个方法声明</p>
<p>前三个为类方法:</p>
<p><code>+ (instancetype)showHUDAddedTo:(UIView *)view animated:(BOOL)animated;</code></p>
<p><code>+ (BOOL)hideHUDForView:(UIView *)view animated:(BOOL)animated;</code></p>
<p><code>+ (nullable MBProgressHUD *)HUDForView:(UIView *)view;</code></p>
<p>后面为对象方法:</p>
<p><code>- (instancetype)initWithView:(UIView *)view;</code></p>
<p><code>- (void)showAnimated:(BOOL)animated;</code></p>
<p><code>- (void)hideAnimated:(BOOL)animated;</code></p>
<p><code>- (void)hideAnimated:(BOOL)animated afterDelay:(NSTimeInterval)delay;</code></p>
<p>每个方法的注释都很详细,不需要多介绍什么的,接下来看看属性</p>
<p><code>@property (weak, nonatomic) id&lt;MBProgressHUDDelegate&gt; delegate;</code><br><code>@property (copy, nullable) MBProgressHUDCompletionBlock completionBlock;</code><br>这两个属性都是用来回传HUD消失事件的,代理协议里面也只有一个HUD已经隐藏的方法</p>
<p><code>@property (assign, nonatomic) NSTimeInterval graceTime;</code>这个属性很有意思,一开始我理解成下面那个属性<code>minShowTime</code>了,往下看到<code>minShowTime</code>之后,我才发现理解错了;这个属性的意思是:如果有graceTime,那么HUD在graceTime之后才显示.作用就是不让时间非常短的任务显示HUD(嗯,用处好像不是很大,我看了下我们项目,没有一个地方使用…)举个例子:我们一般会在网络请求发起之前显示HUD,在网络请求返回时隐藏HUD,在不考虑下面<code>minShowTime</code>属性的情况下,如果这个时间间隔非常短,就会出现显示了HUD瞬间就消失了的尴尬情况,那么这个时候,设置一个graceTime,对于那些时间非常短的异步任务就根本不会显示也没有必要显示HUD了</p>
<p><code>@property (assign, nonatomic) NSTimeInterval minShowTime;</code>这个属性的作用就容易理解多了,最小显示时间;同样也是为了解决时间间隔很短的异步任务问题,你还察觉不到就结束了,那么这个HUD压根就看不见…所以加上这么一个时间</p>
<p><code>@property (assign, nonatomic) BOOL removeFromSuperViewOnHide;</code>这个也是非常好理解,隐藏的时候是否从父视图移除</p>
<h6 id="下面的属性时跟外观-Appearance-相关的"><a href="#下面的属性时跟外观-Appearance-相关的" class="headerlink" title="下面的属性时跟外观(Appearance)相关的"></a>下面的属性时跟外观(Appearance)相关的</h6><p><code>@property (assign, nonatomic) MBProgressHUDMode mode;</code> 样式<br><code>@property (strong, nonatomic, nullable) UIColor *contentColor</code> 内容颜色<br><code>@property (assign, nonatomic) MBProgressHUDAnimation animationType</code> 显示或隐藏时的动画类型<br><code>@property (assign, nonatomic) CGPoint offset</code> 相对于视图中心的边框偏移量<br><code>@property (assign, nonatomic) CGFloat margin</code> HUD边缘和HUD元素之间的间距<br><code>@property (assign, nonatomic) CGSize minSize</code> HUD边框的最小尺寸<br><code>@property (assign, nonatomic, getter = isSquare) BOOL square</code> 如果可能的话，强制HUD尺寸相等。<br><code>@property (assign, nonatomic, getter=areDefaultMotionEffectsEnabled) BOOL defaultMotionEffectsEnabled</code> 当启用时，bezel center会受到设备加速计数据的轻微影响</p>
<h6 id="进度相关属性-Progress"><a href="#进度相关属性-Progress" class="headerlink" title="进度相关属性(Progress)"></a>进度相关属性(Progress)</h6><p><code>@property (assign, nonatomic) float progress;</code> 进度指示器的进度,取值0.0~1.0,默认为0.0</p>
<h6 id="进度对象相关属性-ProgressObject"><a href="#进度对象相关属性-ProgressObject" class="headerlink" title="进度对象相关属性(ProgressObject)"></a>进度对象相关属性(ProgressObject)</h6><p><code>@property (strong, nonatomic, nullable) NSProgress *progressObject;</code> 不是太明白干什么的</p>
<h6 id="视图相关属性-Views"><a href="#视图相关属性-Views" class="headerlink" title="视图相关属性(Views)"></a>视图相关属性(Views)</h6><p><code>@property (strong, nonatomic, readonly) MBBackgroundView *bezelView;</code> 包含文本标签和指示器(或者自定义视图)的边框视图<br><code>@property (strong, nonatomic, readonly) MBBackgroundView *backgroundView;</code> 覆盖整个HUD区域，放置在bezelView后面的视图<br><code>@property (strong, nonatomic, nullable) UIView *customView;</code> 当HUD样式为MBProgressHUDModeCustomView的时候,显示的视图;视图应该实现intrinsicContentSize方法已显示正确的大小,为了得到最好的效果,建议使用37x37像素<br><code>@property (strong, nonatomic, readonly) UILabel *label;</code> 显示在活动指示器下方的文本标签,HUD会自动调整大小以适应整个文本<br><code>@property (strong, nonatomic, readonly) UILabel *detailsLabel;</code> 一个标签，其中包含一个可选的详细信息消息，显示在labelText消息下面。细节文本可以跨越多行。<br><code>@property (strong, nonatomic, readonly) UIButton *button;</code> 放在标签下面的按钮。只有在添加target和action后才可见。</p>
<p>好了,MBProgressHUD的方法属性就这些了…<br>接下来看看MBProgressHUD头文件里,其他的类的声明;</p>
<p>首先是<code>MBRoundProgressView</code>这个应该是饼图样式时使用到的视图,只有4个属性<br><code>@property (nonatomic, assign) float progress;</code> 进度<br><code>@property (nonatomic, strong) UIColor *progressTintColor;</code> 指示器进度的颜色<br><code>@property (nonatomic, strong) UIColor *backgroundTintColor;</code> 指示器背景色<br><code>@property (nonatomic, assign, getter = isAnnular) BOOL annular;</code> 是否环形,不是很清楚什么效果…</p>
<p>然后是<code>MBBarProgressView</code>,这个应该是一个扁平的进度条视图<br><code>@property (nonatomic, assign) float progress;</code> 进度<br><code>@property (nonatomic, strong) UIColor *lineColor;</code> 条状边框线颜色<br><code>@property (nonatomic, strong) UIColor *progressRemainingColor;</code> 条状背景色<br><code>@property (nonatomic, strong) UIColor *progressColor;</code> 条状进度颜色</p>
<p>最后是<code>MBBackgroundView</code>,这个是背景视图<br><code>@property (nonatomic) MBProgressHUDBackgroundStyle style;</code> 背景样式,毛玻璃或者纯色,iOS7和它之后都是毛玻璃效果,之前是纯色<br><code>@property (nonatomic) UIBlurEffectStyle blurEffectStyle;</code> 模糊效果样式<br><code>@property (nonatomic, strong) UIColor *color;</code> 背景色</p>
<p>以上就是MBProgressHUD.h文件的全部内容了,其实还有一部分,是遗弃的旧版本的代码就不看了</p>
<p>下面,我来看看.m文件源码,这才是重点啊</p>
]]></content>
  </entry>
  <entry>
    <title>2023年10月了黑苹果还香吗？性价比超高黑苹果台式机搭配&amp;黑苹果安装教程</title>
    <url>/2023/10/19/2023-10-19-2023%E5%B9%B410%E6%9C%88%E4%BA%86%E9%BB%91%E8%8B%B9%E6%9E%9C%E8%BF%98%E9%A6%99%E5%90%97%EF%BC%9F%E6%80%A7%E4%BB%B7%E6%AF%94%E8%B6%85%E9%AB%98%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%8F%B0%E5%BC%8F%E6%9C%BA%E6%90%AD%E9%85%8D-%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h1><p>最近一段时间对 iOS 逆向开发进行了一定的研究，之前也更新过一段时间的相关文章（后续由于搬家，不幸感染病毒🦠等一些原因断更了个把月），在学习和探索过程中，非常明显的感受到逆向分析对电脑的性能要求很高尤其是 CPU，在使用逆向分析工具 ghidra，hopper 等程序对 MachO 文件进行分析的时候，常常一分析就要等上大几个小时，而且我使用了 n 年的 MacBook Pro 在分析过程中 CPU 温度总是会飙升到 90 度以上，同时 CPU 散热风扇转速也高达 4500 转以上，甚至经常满转速 6000 转运行，噪音可想而知。等待的时间，加上风扇的噪音真的会让人失去耐性，忍无可忍之下决定购买一台性能强劲的，性价比超高的 Mac 电脑。</p>
<span id="more"></span>

<p>翻到苹果官网查看，动辄 3 万，5 万，甚至高达 10 万+ 的 iMac，Mac Pro，随随便便几千元的选配，让人直呼**，好奇是什么配置居然敢卖到如此价格，研究一番配置才发现价格真的是太离谱了。。。呃，苹果产品从来就不是主打一个性价比的啊。于是让人想到何不自己动手组装一台台式电脑，既能安装 windows 打打游戏娱乐放松，又能安装黑苹果日常学习工作使用。但是要注意安装黑苹果并不是一件简单，方便，快速，愉悦的事情。而且不建议在公司使用黑苹果，网上看到会收到 Apple 的律师函，尤其是一些大公司。个人作为兴趣爱学习交流使用倒也不必担心那么多。</p>
<p>对组装电脑配置和苹果 Mac 产品有些了解的人应该都知道，苹果的产品毫无性价比，尤其是台式电脑，同等配置的产品，苹果卖的贵很多，的确不可否认的是苹果的产品做的非常优秀，不论是电脑还是手机，从硬件，软件到外观设计，都属于一流的水平。笔记本电脑的确没有几家公司能做到像 MacBook 这样的水平，所以你不想要台式电脑，MacBook 还是可以推荐上车的，台式机是真的不推荐购买。但如果你是富哥想买台式机，有 MacOS 需求，对性能又没有特别高的要求，也不想折腾的，那还是直接去购买 iMac，Mac Pro 吧。但本人不是富哥，对性能还有一定的要求，还愿意折腾的选择自己组装台式机安装黑苹果就是最好的选择。</p>
<h1 id="黑苹果的现状与未来"><a href="#黑苹果的现状与未来" class="headerlink" title="黑苹果的现状与未来"></a>黑苹果的现状与未来</h1><p>最近这两年还能赶上黑苹果的末班车，再过个三五年，最多可能不超过 10 年，市面上所有 Intel + AMD 的白苹果被苹果公司抛弃，不再支持安装最新的 MacOS 系统的时候，应该就再也看不到黑苹果了。</p>
<p>今年 6 月 5 号，最后一代 Intel CPU （至强系列，属于服务器CPU） + AMD GPU 的 Mac Pro 停产了。而最后一代的家用桌面级 CPU 也就是 Intel 酷睿 10910 的 iMac （搭配的 GPU 是 RX 5700XT） 也已经早在 2022 年 3 月 8 号停产了。数据来源：<a href="https://everymac.com/">everymac</a> 。经过网上对黑苹果的一番研究，特别是 GitHub 上的一个开源项目 <a href="https://dortania.github.io/OpenCore-Install-Guide/">OpenCore</a>，感谢开源，感谢hacker，国内的大部分教程其实都是对这个项目的中文翻译加自己的整理，建议想要安装黑苹果的不管英文行的不行的都先看看这个（网页有翻译工具，阅读起来也没那么困难）得出以下一些结论：</p>
<p>到写这篇文章为止，目前能安装黑苹果的最顶级搭配，应该是：</p>
<ul>
<li>CPU i9 13900KS + GPU RX 6950XT，最近刚出的 14 代酷睿还不确定能不能安装黑苹果。</li>
</ul>
<p>最后一代能最完美实现黑苹果的顶级搭配：</p>
<ul>
<li>CPU i9 10910 + GPU RX 5700XT，这个是苹果 iMac 最后一代桌面级 Intel CPU + AMD GPU 产品，已于 2022 年 3 月 8 号停产，之后的 iMac 都是搭配苹果自研的 M 芯片了。购买跟这个同样的配置完全不担心黑苹果安装的问题，完美适配的问题。2022 年 3 月的机型配置，这个配置用个三五年也完全不成问题。</li>
</ul>
<p>个人经过对价格，性能一番分析之后认为，目前最具性价比的黑苹果搭配是：</p>
<ul>
<li>CPU i9 11900KF + GPU RX 6600XT。</li>
</ul>
<h1 id="配件选择"><a href="#配件选择" class="headerlink" title="配件选择"></a>配件选择</h1><p>组装一台台式电脑所需的配件大概是以下 8 个部分。其中对安装黑苹果影响最大的就是 CPU，GPU 了，其次是硬盘，最后稍微可能有点影响的就是内存了，最新的 DDR5 内存频率太高的不太推荐，听说是会影响黑苹果系统的稳定性。其余的就跟能否安装黑苹果没有任何关系了。我将有影响的配件放在前面讲，后续没有影响的配件都简单带过。</p>
<h2 id="CPU-的选择"><a href="#CPU-的选择" class="headerlink" title="CPU 的选择"></a>CPU 的选择</h2><p>原本以为 10 代的 CPU 会比 11 代的 CPU 会更便宜，毕竟是电子产品，年代又更久远一些，万万没有想到 10 代酷睿不知道是有哪些魔力，居然卖的比 11 代酷睿更贵。目前，11900KF 不过 ¥1200 出头，RX 6600XT 如果接受矿卡的话，也只需要 ¥1100 上下，不接受矿卡的可以选择 RX 6650XT。而且性能功耗也比 iMac 最后一代的 RX 5700XT 更加优秀。这样 CPU + GPU 买下来也只需要 ¥2300 左右。而如果买 10910 或者 10900K&#x2F;KF 的话光一个 CPU 就差不多要这个价钱了。其中 </p>
<ul>
<li>10910 价格在 ¥2050 左右。</li>
<li>10900KF 价格在 ¥1950 左右。</li>
<li>10900K 的价格要 ¥2300 以上。</li>
</ul>
<p>这样光一个 CPU 的价格就赶上 11900KF + RX 6600XT 的组合了，性能却还不如这个组合。当然如果你没有 GPU 的需求，购买 10900K 使用它的核显也是可以的。10900K 的核显理论上也能搭配 4k 显示器日常使用。</p>
<p>12 代 i5 12600 及以上等级的 CPU 和 13 代的 i5 13490F 及以上等级的 CPU 单核性能理论上都比 i9 11900KF 强一些（<a href="https://www.mydrivers.com/zhuanti/tianti/cpu/index.html">CPU性能天梯图</a>），但是这几代产品不像魔幻的 10 代酷睿，都是一分钱一分货，都要比 11900KF 贵上一些。如果不追求很高的性价比，希望性能更强一些的，也可以选择这两款或以上的 CPU。</p>
<p><img src="/../images/11900KF.jpg" alt="11900KF"></p>
<h2 id="GPU-的选择"><a href="#GPU-的选择" class="headerlink" title="GPU 的选择"></a>GPU 的选择</h2><p>其实本来是打算照着苹果的最后一代 Intel iMac 的配置去搭配台式机的，这样不用担心能不能成功安装黑苹果，MacOS 系统能不能完美支持。也就是 10 代 i9 搭配 RX 5700XT。但是 10 代酷睿 i9 的价格让我放弃了这个想法，发现了更具性价比的 11 代 i9，于是想着既然 CPU 提升了一个等级，那么显卡要不也提升一下等级吧，RX 6600XT 性能略强于 RX 5700XT（<a href="https://www.mydrivers.com/zhuanti/tianti/gpu/index.html">显卡性能天梯图</a>），功耗却比 RX 5700XT 更低，价格也只贵了两三百元左右，这就是电子产品技术的进步吧，新出的产品性能比老产品强，功耗还要比老产品低。</p>
<p>至于为什么不选择更好的 RX 6800，RX 6800XT，RX 6900XT 的原因（6700系列目前不支持黑苹果），一个是由于价格原因，这几张显卡都不是 1k+ 能够拿得下来的。第二是由于本人对显卡的需求也不是那么高，RX 6600XT 在 1k 分辨率下也能无压力的运行。甚至在 2k 分辨率下也可以流畅运行满足大部分需求。搭配 4k，5k 显示器日常使用也完全没有问题，iMac 搭配的显卡 RX 5700XT 性能差不多就是配置的 5k 显示器，日常使用肯定没问题，当然如果你想要这张显卡搭配 4k 及以上分辨率显示器在 Windows 下愉快玩大型3A游戏，那可能还是有点强卡所难了，要么降低游戏的分辨率，要么直接上最顶级的 RX 6900XT&#x2F;6950XT。</p>
<h2 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h2><p>硬盘部分不是我这篇文章的重点，大部分硬盘都是没问题的，只有某些 nvme 硬盘无法安装，推荐看一下 <a href="https://hpglw.com/cdc6109c.html">这篇文章</a>。本人选择的前段时间性价比很高的宏碁掠夺者 GM7000 2T 带独立缓存，对于开发者来说应该是特别适合的。实测安装黑苹果没有问题。</p>
<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>本人选择的是金百达银爵 16g * 2 3200 Mhz DDR4。搭配后面的主板开启 XMP 之后轻轻松松上到 3600 Mhz。虽然我也不甚了解现在越来越高的内存频率有什么特别大的实际作用。。。</p>
<h2 id="主板"><a href="#主板" class="headerlink" title="主板"></a>主板</h2><p>已经上到 i9 处理器了，主板毫无疑问推荐 Z 系列主板。Intel CPU 和主板搭配有个规律，就是 CPU 代数和主板芯片组有一个 6 的差距，比如：</p>
<ul>
<li>10 代 i9，那么搭配的主板芯片组应该是 Z490，但其实大部分 Z490 芯片组更新 BIOS 之后也能安装 11 代 CPU。</li>
<li>11 代 i9，那么搭配的主板芯片组应该是 Z590，Z590 芯片组可以安装 10 代和 11 代的 CPU。</li>
<li>12 代 i9，推荐搭配的主板芯片组是 Z690，大部分 Z690 芯片组更新 BIOS 也能安装 13 代 CPU。</li>
<li>13 代 i9，推荐搭配的主板芯片组是 Z790</li>
</ul>
<p>大概这样理解是没有问题的，只是有一些主板的兼容性好一点，多兼容几代 CPU，其实关键的地方在于 CPU 的针脚是否发生变化。主板个人选择的是某爱国嘉的 Z590M GAMING X，选择 MATX 主板的原因是不想要那么大的机箱。但是目前这款主板已经不好买到了，二手市场也几乎见不到几块了，不在乎机箱尺寸的可以选择常规 ATX 大小主板 Z590 GAMING X，这款市面上还是有不少在售卖的。</p>
<h2 id="CPU散热器"><a href="#CPU散热器" class="headerlink" title="CPU散热器"></a>CPU散热器</h2><p>CPU散热器的选择大体上分为两种，风冷和水冷。本人并不喜欢和信任水冷所以优先考虑的是风冷，11900KF 这种 11 代顶级 CPU 在满载的时候的发热量巨大，原本考虑的是利民风冷之王 FC140 ，无奈在准备购买的时候听客服说，这款产品会挡住 Z590M GAMING X 这款主板的内存，无法考证客服的说法。但按客服的推荐，选择了一款新出的利民 PS120 综合比较下来散热不输 FC140 ，尺寸也较小一圈不挡内存。</p>
<p>遗憾的是，经过实测这款散热器即使换上了台达的 12cm 3000 转暴力风扇也无法让 11900KF 不降频通过烤机测试。不过这是在开启了 AVX512 指令集的情况下。实测关闭了 AVX512 指令集之后，可以不降频通过烤机测试，温度在 80 多度左右。说实话我也一直想尝试搞懂这个 AVX512 指令集的实际作用，奈何太专业了，没搞明白。所以如果你不介意的话，关闭它之后 PS120 完全可以压制住 11900KF 这个 CPU。</p>
<p>但如果你实在介意买了这颗 CPU ，还不能完全使用它的功能，还要关闭这个虽然不知道有什么实际用途的 AVX512 指令集。那么还是建议上顶级的 240 水冷，或者 360 水冷吧。由于我机箱的限制，最多只能上到 240 水冷。不过目前并没有换的打算，因为我实在想不到除了烤机测试，还有哪些场景下能够让 CPU 满载运行很长时间。实在有这个需求了，关掉 AVX512 指令集在 PS120 的压制下也能长期满载运行。</p>
<h2 id="电源"><a href="#电源" class="headerlink" title="电源"></a>电源</h2><p>电源的选择最重要的是功率。根据你的 CPU 和 GPU 的搭配选择适合的功率，不然你的电脑可能连开机都成问题。一开始本人并不是特别了解，随便看到几篇抖音说 RX 6600XT 显卡搭配 600W 电源就行了。于是一开始买了个 600W 的长城 V6 600W 金牌全模组电源，结果在装机的时候常常发生显示器点不亮的情况，有时候重新开机几次又能点亮，有时候开机多次也无法点亮。甚至一度怀疑是显卡，或者主板的问题去了。。。后来在 <a href="https://seasonic.com/wattage-calculator">SEASONIC<em>海韵电源</em></a> 和 <a href="https://www.msi.cn/power-supply-calculator">MSI 微星</a> 的官网找到了电源功率计算器这个工具，计算下来才发现，我的配置 i9 11900KF + RX 6600XT 最低要求的电源功率也要 650W ，推荐上 700W 及以上功率的电源更好，这样可以应对以后配件升级的情况。至于其他的什么电容啊，80PLUS认证，模组化啊，本人倒觉得不是那么必要，功率才是必须要选择对的。由于本人并没有后期升级的打算，于是就换成了长城的 V7 700W 金牌全模组电源。</p>
<h2 id="机箱"><a href="#机箱" class="headerlink" title="机箱"></a>机箱</h2><p>机箱之前说过，本人不喜欢特别大的机箱，电脑的发展历史，就是越做越小的一段历史。现在的商家为了把产品卖出更高的价格，往往高配置的电脑喜欢搭配巨大的机箱。。。本人真的是接受不了。所以选择了一块 mATX 主板，那么机箱自然也是选择搭配 mATX 主板的小机箱。本人选择的是旅行者，机箱上方附带一个把手，可以很方便的一只手提起来。机箱不自带风扇，本人额外购买了两把台达 12cm 3000转静音温控风扇，只要 ¥17 元人民币1把。真的是物美价廉，风量比太多所谓的品牌风扇大多了。</p>
<h1 id="安装-Hackintosh"><a href="#安装-Hackintosh" class="headerlink" title="安装 Hackintosh"></a>安装 Hackintosh</h1><p>硬件都选配好了，接下来就是安装系统了。如果你选择的是 10 代酷睿 CPU，那么按照 OpenCore 官方文档的步骤来进行黑苹果安装，会十分的顺利，因为 OpenCore 目前对 10 代及以内的 CPU 的文档都特别详细。10 代之后的 CPU 有一些官方文档没有明确写明的地方需要自己摸索。</p>
<p>安装黑苹果的步骤，概括的来说，跟安装 window 没有太大区别，多了一个自己配置 EFI 文件的步骤。</p>
<h2 id="1-将-U-盘制作成系统安装盘"><a href="#1-将-U-盘制作成系统安装盘" class="headerlink" title="1. 将 U 盘制作成系统安装盘"></a>1. 将 U 盘制作成系统安装盘</h2><p>制作 U 盘系统安装盘的方式多种多样，这里我只讲诉我自己的使用过的方式，就是在 MacOS 上制作。其他的方式自己参考 <a href="https://dortania.github.io/OpenCore-Install-Guide/installer-guide/">OpenCore文档</a>。</p>
<h3 id="1-1-下载-macOS-安装程序"><a href="#1-1-下载-macOS-安装程序" class="headerlink" title="1.1 下载 macOS 安装程序"></a>1.1 下载 macOS 安装程序</h3><p>使用 App Store 搜索你想要安装的 Mac OS 系统，下面以 macOS Ventura 为例。</p>
<p><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/4af03ee077ece3249a40d34b6003ff43c1809189/20231019/01.png" alt="image.png"></p>
<p>点击获取就可以等待下载完成了。。。下载完成之后可以在启动台中看到，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/4af03ee077ece3249a40d34b6003ff43c1809189/20231019/02.png" alt="Xnip2023-10-18_14-58-49.png"></p>
<p>在等待下载的过程中，可以先执行下一步格式化 U 盘。</p>
<h3 id="1-2-格式化-U-盘"><a href="#1-2-格式化-U-盘" class="headerlink" title="1.2 格式化 U 盘"></a>1.2 格式化 U 盘</h3><p>U 盘大小建议至少是 16G 以上的。<br><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/4af03ee077ece3249a40d34b6003ff43c1809189/20231019/03.png" alt="image.png"></p>
<p>然后点击右上角的抹掉，之后按照下图的选择进行抹掉操作。</p>
<p><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/4af03ee077ece3249a40d34b6003ff43c1809189/20231019/04.png" alt="Xnip2023-10-18_16-52-01.png"></p>
<p>这里的名称一定要记住，后面还要用到的。我的建议是改成 OpenCoreUSB，当然这个无所谓，只要记得后面要用到就行。</p>
<h3 id="1-3-将-U-盘制作成系统安装盘"><a href="#1-3-将-U-盘制作成系统安装盘" class="headerlink" title="1.3 将 U 盘制作成系统安装盘"></a>1.3 将 U 盘制作成系统安装盘</h3><p>等到 macOS 安装程序下载好了之后，也即是在 1.1 中的第二张图片那样，在启动台中能看到安装 macOS Ventura 了。打开系统自带的终端app，输入以下指令（友情提示，太长的指令可以输入前几个字母之后按 TAB 键自动补全）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo /Applications/Install\ macOS\ Ventura.app/Contents/Resources/createinstallmedia --volume /Volumes/OpenCoreUSB</span><br></pre></td></tr></table></figure>
<p>输入电脑开机密码之后，再输入 y 按回车确认。安装时间有点慢，取决于你的 U 盘读写速度。如下图所示</p>
<p><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/4af03ee077ece3249a40d34b6003ff43c1809189/20231019/05.png" alt="Xnip2023-10-18_17-33-34.png"></p>
<p>跟上面结果一样就表示你的U盘系统安装盘制作好了</p>
<h2 id="2-配置-EFI-文件夹"><a href="#2-配置-EFI-文件夹" class="headerlink" title="2. 配置 EFI 文件夹"></a>2. 配置 EFI 文件夹</h2><p>安装黑苹果的步骤当中，最麻烦的就是这一步了。很多人会去网上搜索跟自己配置相同的人分享出来的 EFI 文件。但是实际上往往很难搜到完全相同的配置，或者即使是完全相同的配置依然是无法成功安装黑苹果。所以还是推荐照着 OpenCore 官方文档的步骤一步步自己动手配置 EFI 文件最靠谱。我这里会大概讲一下我自己配置的过程，具体的很多细节可以查阅官方文档中。</p>
<h3 id="2-1-下载-OpenCore-最新的版本"><a href="#2-1-下载-OpenCore-最新的版本" class="headerlink" title="2.1 下载 OpenCore 最新的版本"></a>2.1 下载 OpenCore <a href="https://github.com/acidanthera/OpenCorePkg/releases/">最新的版本</a></h3><p>这里会有 Debug 和 Release 两个版本，虽然官方推荐第一次使用选择 Debug 版本，但是我个人的经验来看还是建议直接选择 Release 版本，因为只要是按照教程一步步来的，基本不会出现问题，而就算你使用 Debug 版本出现了报错，也基本上看不懂任何一点报错的代码。。。太抽象了，反正我的确是用过 Debug 版本也遇到无法安装的情况，结果就是完全看不懂一点报错信息，也搜不到任何相关的资料。反而是认认真真照着教程又重新配置了几遍，才成功安装上的，最后还要回过头将所有 Debug 版本文件替换为 Release 版本。</p>
<p>我们将要使用的 EFI 文件夹：</p>
<p><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/4af03ee077ece3249a40d34b6003ff43c1809189/20231019/06.png" alt="image.png"></p>
<h3 id="2-2-挂载-U-盘上的-EFI-分区"><a href="#2-2-挂载-U-盘上的-EFI-分区" class="headerlink" title="2.2 挂载 U 盘上的 EFI 分区"></a>2.2 挂载 U 盘上的 EFI 分区</h3><p>在前面格式化 U 盘的过程中，我们选择的格式化方案会在 U 盘上自动创建一个隐藏的没有挂载到系统的 EFI 分区，现在需要将这个分区挂载到系统上，以便我们操作这个分区。挂载的方式有很多种</p>
<ul>
<li>有通过终端纯命令行的方式 <a href="https://github.com/corpnewt/MountEFI">MountEFI</a>。</li>
<li>也有通过使用一个 app 的图形化的方式 <a href="https://mackie100projects.altervista.org/download-opencore-Configurator/">OpenCore Configurator</a>。</li>
</ul>
<p>以下是使用 OpenCore Configurator 的截图。</p>
<p><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/4af03ee077ece3249a40d34b6003ff43c1809189/20231019/07.png" alt="image.png"></p>
<p>挂载之后就可以看到 U 盘的隐藏 EFI 分区了。然后将上一步中下载的 EFI 文件夹复制到这个 EFI 分区中。注意 EFI 分区下有一个 EFI 文件夹不要搞糊涂了。</p>
<h3 id="2-3-添加文件到各个子文件中"><a href="#2-3-添加文件到各个子文件中" class="headerlink" title="2.3 添加文件到各个子文件中"></a>2.3 添加文件到各个子文件中</h3><p>从现在开始，要确保我们所有的操作都是对 U 盘 EFI 分区的 EFI 文件夹进行操作。现在，先简单认识一下 EFI 文件夹里的子文件夹：</p>
<p><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/4af03ee077ece3249a40d34b6003ff43c1809189/20231019/08.png" alt="image.png"></p>
<ul>
<li><p>ACPI：说实话，这个文件夹我一直没有完全搞明白，翻译的内容，英文的缩写太多了，只知道这里面的内容大概跟 CPU 架构和电源管理等内容相关，官方文档只讲到了 10 代酷睿，后面的 11，12，13 以及刚出的 14 代酷睿并不在官方文档中，但我从其他资料中看到，10 代之后的酷睿 CPU 都可以按照 10 代酷睿的那样配置。所以按照我的配置，我们需要以下三个文件：</p>
<p>  <img src="https://raw.githubusercontent.com/masterKing/markDownPictures/4af03ee077ece3249a40d34b6003ff43c1809189/20231019/09.png" alt="image.png"></p>
<ul>
<li><a href="https://github.com/dortania/Getting-Started-With-ACPI/blob/master/extra-files/compiled/SSDT-AWAC.aml">SSDT-AWAC.aml</a></li>
<li><a href="https://github.com/dortania/Getting-Started-With-ACPI/blob/master/extra-files/compiled/SSDT-EC-USBX-DESKTOP.aml">SSDT-EC-USBX-DESKTOP.aml</a> </li>
<li><a href="https://github.com/dortania/Getting-Started-With-ACPI/blob/master/extra-files/compiled/SSDT-PLUG-DRTNIA.aml">SSDT-PLUG-DRTNIA.aml</a></li>
</ul>
</li>
<li><p>Drivers：固件驱动程序是 OpenCore 在 UEFI 环境中使用的驱动程序。大部分情况下我们只需要两个文件</p>
<p>  <img src="https://raw.githubusercontent.com/masterKing/markDownPictures/4af03ee077ece3249a40d34b6003ff43c1809189/20231019/10.png" alt="image.png"></p>
<ul>
<li><a href="https://github.com/acidanthera/OcBinaryData/blob/master/Drivers/HfsPlus.efi">HfsPlus.efi</a></li>
<li><a href="https://github.com/acidanthera/OpenCorePkg/releases">OpenRuntime.efi</a></li>
</ul>
<p>  虽然下载的 OpenCore 自带的 Drivers 里面会有很多文件，其中也包括上面这些文件，但我个人还是建议删掉自带的所有 efi 文件，点击上面的链接自己下载。因为自带的文件有些名字都改了，搞的人不知道该怎么处理。</p>
</li>
<li><p>Kexts：kext 是一个内核扩展，您可以将其视为 macOS 的驱动程序。大多数 kext 都可以在 <a href="https://dortania.github.io/builds/">构建存储库</a> 中找到已编译好的。每次有新提交时都会编译此处的 Kext。对于我的配置，需要以下这些文件</p>
<p>  <img src="https://raw.githubusercontent.com/masterKing/markDownPictures/4af03ee077ece3249a40d34b6003ff43c1809189/20231019/11.png" alt="image.png"></p>
<ul>
<li><a href="https://dortania.github.io/builds/?product=Lilu&viewall=true">Lilu.kext</a> 用于修补许多处理器的补丁，也是很多其他内核扩展的基础。</li>
<li><a href="https://github.com/acidanthera/VirtualSMC/releaseshttps://github.com/acidanthera/VirtualSMC/releases">SMCProcessor.kext</a> 用于监控 Intel CPU 温度</li>
<li><a href="https://github.com/ChefKissInc/RadeonSensor/releases">SMCRadeonGPU.kext</a> 用于监控 GPU 温度</li>
<li><a href="https://github.com/ChefKissInc/RadeonSensor/releases">RadeonSensor.kext</a> 还有一个 RadeonGadget 是一个 app 用于在右上角显示 GPU 温度的，需要搭配当前内核扩展使用，所以并不需要放在 Kexts 下。</li>
<li><a href="https://github.com/acidanthera/VirtualSMC/releaseshttps://github.com/acidanthera/VirtualSMC/releases">SMCSuperIO.kext</a> 这个和 SMCProcessor.kext 在一块</li>
<li><a href="https://dortania.github.io/builds/?product=WhateverGreen&viewall=true">WhateverGreen.kext</a> 显卡驱动，可以从构建存储库中下载最新版本。</li>
<li><a href="https://dortania.github.io/builds/?product=AppleALC&viewall=true">AppleeAlc.kext</a> 声卡驱动，还需要在配置文件中添加一个配置。在官方文档上可以看到。</li>
<li><a href="https://www.insanelymac.com/forum/files/file/1004-lucyrtl8125ethernet/">LucyRTL8125Ethernet.kext</a> 有线网卡驱动</li>
<li><a href="https://github.com/USBToolBox/kext/releases">USBToolBox.kext</a> 用于修复 USB 端口连接的</li>
<li>UTBMap.kext 这个扩展需要借助这个<a href="https://github.com/USBToolBox/tool/releases">工具</a>自己制作自己的。</li>
<li><a href="https://github.com/acidanthera/NVMeFix/releases">NVMeFix.kext</a> 用于修复非 Apple NVMe 上的电源管理和初始化</li>
<li><a href="https://github.com/acidanthera/RestrictEvents/releases">RestrictEvents.kext</a> 这个对我来说主要是为了修复在模仿使用 MacPro7,1 机型的时候，右上角会弹出“内存模块配置错误”的问题的。<!--但是我使用了一段时间后才发现，右上角有一个小的矩形区域无法点击的bug，不知道是不是它导致的。其实不要这个扩展也没什么问题，要么换成 iMacPro1.1 机型就不会有这个提示，要么不在乎提示，每次启动后出现的时候点击关闭就好了。--></li>
</ul>
</li>
<li><p>Resources：这里主要是美化 OpenCore 启动时的外观界面的，如果不配置就使用纯字母的形式显示，配置了会有图标，好看一点，就像白苹果里那样显示。感兴趣的可以去官网搜索自行配置。不影响安装。</p>
</li>
<li><p>Tools：工具类的文件，可以放在这里，不过不懂如何使用的也没什么必要放了，毕竟也不影响安装。</p>
</li>
</ul>
<p>这里我并没有添加无线网卡蓝牙相关的驱动，因为我没有 macOS 上能驱动的无线网卡，如果有这个需要打算购置的话可以查看 <a href="https://dortania.github.io/Wireless-Buyers-Guide/">无线网卡购买指南</a>。</p>
<h3 id="2-4-配置-config-plist-文件"><a href="#2-4-配置-config-plist-文件" class="headerlink" title="2.4 配置 config.plist 文件"></a>2.4 配置 config.plist 文件</h3><p>plist 文件对于 iOS 开发者来说并不陌生，对其他开发者来说可以理解成一种特殊的 XML 文件。上一步添加需要的文件麻烦，这一步则可能是最麻烦的了。需要按照 <a href="https://dortania.github.io/OpenCore-Install-Guide/config.plist/comet-lake.html">官方文档</a> 仔细比对每个需要的键。先从下载的 OpenCore 文件夹中找到 Sample.plist 文件，然后复制到 U 上 EFI 分区的 OC 文件夹下并重命名为 config.plist。</p>
<p><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/4af03ee077ece3249a40d34b6003ff43c1809189/20231019/12.png" alt="image.png"></p>
<p>虽然可以直接通过 Xcode 对 config.plist 进行编辑，不过由于大多数人对这个文件的修改都不熟悉，不知道哪些能不能删，如何修改，所以还是建议使用一些专门的工具进行编辑，就比如我们之前挂载 EFI 分区使用到的 <a href="https://mackie100projects.altervista.org/download-opencore-Configurator/">OpenCore Configurator</a>。这个 plist 文件主要的工作其实就是对当前文件夹下的其他文件，建立一个关联，当然还有它本身自带一个配置需要修改。</p>
<p>绝大部分的配置，官方文档都写的很清楚了，我不再重复，只有以下几点，官方文档没有写明的：</p>
<ol>
<li><p>Kernel -&gt; Emulate<br> 也就是仿冒 CPU。 对于 10 代酷睿之后的 CPU 都需要配置这个键。其实这个配置可以在 OpenCore 下载的文档里可以找到。Rocket Lake 就是 11 代酷睿的 CPU 代号</p>
<p> <img src="https://raw.githubusercontent.com/masterKing/markDownPictures/4af03ee077ece3249a40d34b6003ff43c1809189/20231019/13.png" alt="image.png"></p>
<p> 在 OpenCore Configurator 中的设置如下：</p>
<p> <img src="https://raw.githubusercontent.com/masterKing/markDownPictures/4af03ee077ece3249a40d34b6003ff43c1809189/20231019/14.png" alt="image.png"></p>
</li>
<li><p>如何使用 OpenCore Configurator。用它打开你 OC 文件夹下的 config.plist 可能会有一些默认的配置，使用右下角的 - 号全部删除。点击快照&#x2F;浏览会自动添加对应的文件夹下的文件。修改完成后记得保存，最后可以用 Xcode 或预览查看刚刚的修改是否真的保存了。</p>
</li>
</ol>
<p>如果你有足够的耐心，照着官方的文档，一步步完成了所有应该的配置。那么恭喜🎉你可以进入下一步，安装系统了</p>
<h2 id="3-安装系统"><a href="#3-安装系统" class="headerlink" title="3. 安装系统"></a>3. 安装系统</h2><h3 id="3-1-调整主板-BIOS"><a href="#3-1-调整主板-BIOS" class="headerlink" title="3.1 调整主板 BIOS"></a>3.1 调整主板 BIOS</h3><p>在正式开始安装之前，还需要对主板的 BIOS 进行一些设置。<a href="https://dortania.github.io/OpenCore-Install-Guide/config.plist/comet-lake.html#cleaning-up">官网</a> 和 <a href="https://apple.sqlsec.com/3-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/3-1/">国光</a> 的教程都很全面了，我这里只讲一下自己的主板 z590m gaming x 有的一些设置。这里我已经将 BIOS 更新到最新的 F8 版本了，在技嘉官网下载并更新最新版本的 <a href="https://www.gigabyte.com/Motherboard/Z590M-GAMING-X-rev-10/support#support-dl-bios">BIOS</a> ，这一步可能不是必须的。因为即使是最新的版本，依然有很多设置没有出现在 BIOS 中。以下是我这个主板的一些 BIOS 设置。</p>
<h4 id="禁用"><a href="#禁用" class="headerlink" title="禁用"></a>禁用</h4><ul>
<li>Fast Boot 这个有，在 Boot 选项下</li>
<li>Secure Boot 这个有，在 Boot 选项下</li>
<li>Serial&#x2F;COM Port 有，在 Settings -&gt; IO Ports -&gt; Super IO Configuration 下</li>
<li>Parallel Port 没找到</li>
<li>VT-d 有，Favorites 下就有，同样出现在 Settings -&gt; Miscellaneous 下</li>
<li>Compatibility Support Module (CSM) 有，在 Boot 下</li>
<li>Thunderbolt 没找到</li>
<li>Intel SGX 没找到</li>
<li>Intel Platform Trust 有，在 Setting -&gt; Miscellaneous 下</li>
<li>CFG Lock (MSR 0xE2 write protection) 有，在 Boot 下</li>
</ul>
<h4 id="开启"><a href="#开启" class="headerlink" title="开启"></a>开启</h4><ul>
<li>VT-x 没找到</li>
<li>Above 4G Decoding 有，在 Settings -&gt; IO Ports 下</li>
<li>Hyper-Threading 有，在 Tweaker -&gt; Advanced CPU Setings 下</li>
<li>Execute Disable Bit 没找到</li>
<li>EHCI&#x2F;XHCI Hand-off 有，在 Settings -&gt; IO Ports -&gt; USB Configuration 下</li>
<li>OS type: Windows 8.1&#x2F;10 UEFI Mode (some motherboards may require “Other OS” instead) 没有一样的，但是将 Boot 下的 Windows 10 Features 设置为 Other OS 了</li>
<li>DVMT Pre-Allocated(iGPU Memory): 64MB or higher 没找到，对于11900KF不带核显的 CPU 应该是没有这个设置的。</li>
<li>SATA Mode: AHCI 有，在 Settings -&gt; IO Ports -&gt; SATA And RST Configuration 下</li>
</ul>
<h3 id="3-2-开始安装"><a href="#3-2-开始安装" class="headerlink" title="3.2 开始安装"></a>3.2 开始安装</h3><p>终于来到了这激动人心的安装步骤。确保 U 盘插入主板后面的 USB3 插口上，我试过插在机箱面板的插口上会有些问题，开机按 F12 选择 U 盘启动。就会进入到 OpenCore 的选择页面，选择 Install macOS Ventura (external) ，进入后先选择磁盘工具格式化硬盘，选择 APFS 格式和 GUID 分区图方案。完成之后，退出磁盘工具，选择安装 macOS Ventura 接下来的操作就是按照提示一步步操作了，中间会重启多次，直到进入选择语言界面，那么恭喜你，你做到了！</p>
<h1 id="实测"><a href="#实测" class="headerlink" title="实测"></a>实测</h1><p>安装完后看看关于本机，和 Geekbench 的信息</p>
<p><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/4af03ee077ece3249a40d34b6003ff43c1809189/20231019/15.png" alt="image.png"></p>
<p>先上一下 Geekbench 5 的跑分。</p>
<p><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/4af03ee077ece3249a40d34b6003ff43c1809189/20231019/16.png" alt="image.png"></p>
<p>可能很多人并不知道，这个跑分的水平在哪里。所以我找了几款 Mac 机型的跑分作为对比。</p>
<ol>
<li><p>同为 MacPro7,1 型号的白苹果，在今年 6 月 5 号刚停产。搭配的是 Intel Xeon 处理器。选用28核的这款作为对比。可以看到 11900KF 的单核性能远超这款配置。多核性能由于 11900KF 只有 8 个核心，的确比不上 28 核心的 Xeon，但也有一个不错的分数。但是考虑到这款配置的 MacPro 的售价 RMB 103,379 。这点多核心性能的差距简直不值一提。</p>
<p> <img src="https://raw.githubusercontent.com/masterKing/markDownPictures/4af03ee077ece3249a40d34b6003ff43c1809189/20231019/17.png" alt="image.png"></p>
<p> 如果选用同样是 8 个核心的 Xeon 处理器那款 MacPro7,1 则无论是单核性能还是多核性能都会被 11900KF 吊打。恐怖的是 8 核心的这款 MacPro 7,1 售价也高达 RMB 51,999。对比我自己配置的这台 5000 块都不到的 11900KF 真的是太香了。</p>
</li>
<li><p>最新款的 MacPro14,8 搭载的是 Apple 自研的 M2 Ultra 芯片。M2 芯片分为 M2，M2 Pro，M2 Max，M2 Ultra，性能依次上升。11900 KF 的性能介于 M2 和 M2 Pro 之间。再考虑到 M2 芯片的最便宜的机型 MacBookAir 最低也要 1w 以上。自己配的 11900KF 还是还是很香的，只是没有上面那么香😄罢了。M2 芯片作为 2022 年的产品的确还是要比 2021 年上市的 11900KF 性能强劲，而且功耗更低。当然，如果一定要用 Intel 来对比 M 芯片，可能依然是 13900KS 更加强劲。但用 13900KS 性价比就没有 11900KF 那么高了。</p>
<p> <img src="https://raw.githubusercontent.com/masterKing/markDownPictures/4af03ee077ece3249a40d34b6003ff43c1809189/20231019/18.png" alt="image.png"></p>
</li>
</ol>
<p>说完了跑分上面的测试，说说自己实际的体验吧。用 ghidra 分析同一份 MachO 文件的耗时，老电脑依旧是好几个小时以至于我都没有测完就放弃了，而新电脑也用了快 1 个小时。这可能是由于 ghidra 为了通用性跨多个平台都能使用，所以并没有完全利用每个平台的完整性能，导致都比较慢吧。</p>
<p>用 hopper 分析同一份 MachO 文件的耗时，hopper 在分析完之后会给出后台分析的耗时，新电脑只有 7 分钟左右，老电脑分析了接近 30 分钟，提升还是很明显的。免费的 hopper 每次只有 30 分钟的体验时间，以前每次分析完，就到时间了，多难受。。。</p>
<p>显卡方面的测试，由于我目前并没有剪辑，制图方面的需求，所以就没有测试了。。。</p>
<p>编译了一个以前非常耗时的 Xcode 项目对比，也快了许多。总的来说，性能提升非常的明显。自己组装台式电脑安装黑苹果真的是太香了，趁着现在黑苹果所剩不多的几年，有需要的人可以赶紧上车了。</p>
]]></content>
  </entry>
  <entry>
    <title>Error Domain=NSURLErrorDomain Code=-999 已取消</title>
    <url>/2018/04/03/Error-Domain-NSURLErrorDomain-Code-999-%E5%B7%B2%E5%8F%96%E6%B6%88/</url>
    <content><![CDATA[<p>今天遇到这么一个问题,在使用SDWebimage设置UIImageView的图片的时候,发现这个图片<br><code>http://img4.imgtn.bdimg.com/it/u=132600321,3123081067&amp;fm=27&amp;gp=0.jpg</code>怎么也设置不成功,后来调试一看发现<img src="https://raw.githubusercontent.com/masterKing/markDownPictures/master/Snip20180403_4.png">说是什么已取消,我是一脸懵逼啊,谁TM取消了啊???百思不得其解之后网上搜了一下;<br>嘿,还有人写了个总结<img src="https://raw.githubusercontent.com/masterKing/markDownPictures/master/Snip20180403_5.png"></p>
<p>然而看了上面的总结后发现貌似都没有关系…所以说这个总结也并不全面…后来想想用浏览器打开这个图片试试看,发现浏览器上能正常打开;这下我估计是请求图片的请求头有问题了;于是我将浏览器的请求头和从APP发出的请求头都列出来了;如下<br><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/master/Snip20180403_1.png"></p>
<p><em>浏览器上的请求头</em></p>
<p><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/master/Snip20180403_2.png"></p>
<p><em>使用Charles抓取APP发出的请求头</em></p>
<p>其实一下子也看不出什么东西出来,那就先从都有的请求头开始试吧,再将APP发出的请求头的User-Agent设置之后发现能够设置成功了…那么问题就可以这么解释了,这个图片所在的服务器会对请求的User-Agent进行判断,具体判断规则是怎样的那我就不得而知了;如果不符合它的规则那么就会请求失败,在上图Charles抓包的响应里面可以看到一段403 Forbidden的html代码,而在APP中,就是报的<code>Error Domain=NSURLErrorDomain Code=-999 &quot;已取消&quot;</code>的错误<br><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/master/Snip20180403_6.png"></p>
<p>其实吧,这个问题根本不重要,因为实际我根本不可能使用这个URL;重要的是解决问题的思路,你得学会一套方法去解决问题,而不是学会解决这个问题…</p>
]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>iPhoneX上pop回到根控制器上漂移的bug</title>
    <url>/2018/04/28/iPhoneX%E4%B8%8Apop%E5%9B%9E%E5%88%B0%E6%A0%B9%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B8%8A%E6%BC%82%E7%A7%BB%E7%9A%84bug/</url>
    <content><![CDATA[<p>记录一个在iPhone X上发生的诡异的bug…语言怎么描述都太苍白,那么直接看图<br><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/master/BrowserPreview_tmp201804281808.gif"></p>
<p>只有在滑动到最底部的时候,push到下一个页面,然后在pop回来就会出现contentOffset.y值自动偏移的现象…</p>
<p>视图的层次结构如图:<br><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/master/Snip20180428_1.png"></p>
<p>选中的视图控制器就是TabBarController的第二个子控制器,控制器的view就是一个UICollectionView;我是很懵逼的…同事说可能是iPhone X上的安全距离的原因(但我还是很懵逼)…于是我对视图层次结构做了下修改;</p>
<ul>
<li>取消修改控制器的view为UICollectionView</li>
<li>将UICollectionView作为控制器的view的子视图</li>
<li>设置collectionView的约束为,上左右等于控制器的view,下等于控制器的view的下面,但是偏移一个-34的高度(仅在iPhone X上)</li>
</ul>
<p>修改之后的视图层次结构如下:<br><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/master/Snip20180428_2.png"></p>
<p>这样,collectionView不再漂移了…对上述偏移的值进行修改测试可以发现,当这个值小于等于-34的时候就不会发生漂移,大于-34时就会发生漂移…换一句话的意思就是,如果collectionView距离底部的距离小于34的那么就会漂移,大于等于34不会发生漂移…</p>
]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>密码学概述</title>
    <url>/2024/04/24/%E5%AF%86%E7%A0%81%E5%AD%A6%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>密码学（来自希腊语kryptos，意思是隐藏）一词的核心是指使数据无法被窥探者读取的技术。当然，密码学也可以用于其他目的。密码学包括一系列技术，如验证数据的真实性（检测是否修改）、确定个人或其他实体的身份、确定谁发送了特定消息或创建了特定数据片段、通过网络安全地发送数据、用密码或口令安全地锁定文件等等。</p>
<p>计算机安全中使用的加密主要有两种类型，称为对称密钥加密和非对称密钥加密。</p>
<h1 id="对称密钥加密"><a href="#对称密钥加密" class="headerlink" title="对称密钥加密"></a>对称密钥加密</h1><p>对称密钥加密（也称为秘密密钥加密）是大多数人熟悉的密钥的经典用法：使用相同的密钥来加密和解密数据。经典且最容易破解的版本是凯撒密码（以朱利叶斯·凯撒命名），其中消息中的每个字母都被替换为字母表中固定位置数的字母（例如，“a”被“c”替换，“b”被替换为“d”等）。在凯撒密码中，用于加密和解密消息的密钥只是字母表旋转的位数以及旋转的方向。现代对称密钥算法更加复杂并且更难破解。</p>
<p>有许多不同的算法用于对称密钥加密，提供从最低限度到几乎牢不可破的安全性。其中一些算法提供了强大的安全性、易于代码实现以及快速的加密和解密。此类算法对于加密存储在计算机上的文件以保护它们以防未经授权的个人使用计算机等目的非常有用。但它们在从一台计算机向另一台计算机发送消息时用处不大，因为通信通道的两端都必须拥有相同的密钥并且必须保证其安全。此类密钥的分发和安全存储可能很困难，并且可能会造成安全漏洞。</p>
<p>虽然交换或创建对称密钥的安全技术可以在一定程度上克服这个问题（例如 Diffie-Hellman 密钥交换），但随着非对称密钥加密算法的发明，出现了一种用于计算机通信的更实用的解决方案。</p>
<p>常见的现代对称密钥加密算法有 DES，3DES，AES 等</p>
<h2 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h2><p>数据加密标准（英语：Data Encryption Standard，缩写为 DES）是一种对称密钥加密算法，1976 年被美国联邦政府的国家标准局确定为联邦资料处理标准，随后在国际上广泛流传开来。</p>
<p>DES 现在已经不是一种安全的加密方法，主要因为它使用的 56 位密钥过短。1999 年 1 月，distributed.net 与电子前哨基金会合作，在 22 小时 15 分钟内即公开破解了一个 DES 密钥。<br>也有一些分析报告提出了该算法的理论上的弱点，虽然在实际中难以应用。为了提供实用所需的安全性，可以使用 DES 的派生算法 3DES 来进行加密，虽然 3DES 也存在理论上的攻击方法。DES 标准和 3DES 标准已逐渐被高级加密标准（AES）所取代。</p>
<h2 id="3DES"><a href="#3DES" class="headerlink" title="3DES"></a>3DES</h2><p>三重数据加密算法（英语：Triple Data Encryption Algorithm，缩写为 TDEA，Triple DEA），或称 3DES（Triple DES），是一种对称密钥加密块密码，相当于是对每个数据块应用三次资料加密标准（DES）算法。由于计算机运算能力的增强，原版 DES 由于密钥长度过低容易被暴力破解；3DES 即是设计用来提供一种相对简单的方法，即通过增加 DES 的密钥长度来避免类似的攻击，而不是设计一种全新的块密码算法。</p>
<h2 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h2><p>高级加密标准（英语：Advanced Encryption Standard，缩写：AES），又称 Rijndael加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的 DES，已经被多方分析且广为全世界所使用。经过五年的甄选流程，高级加密标准由美国国家标准与技术研究院（NIST）于 2001 年 11 月 26 日发布于 FIPS PUB 197，并在 2002 年 5 月 26 日成为有效的标准。现在，高级加密标准已然成为对称密钥加密中最流行的算法之一。</p>
<p>该算法为比利时密码学家 Joan Daemen 和 Vincent Rijmen 所设计，结合两位作者的名字，以 Rijndael 为名投稿高级加密标准的甄选流程。</p>
<h2 id="加密模式"><a href="#加密模式" class="headerlink" title="加密模式"></a>加密模式</h2><p>对称加密算法的加密模式是指在对称加密过程中，明文如何被切分、填充和加密，以及密文如何被解密和还原成原始的明文。常见的对称加密算法包括 AES（高级加密标准）和 DES（数据加密标准），它们可以使用不同的加密模式来实现数据的保密性。</p>
<p>虽然加密模式通常应用于对称加密，它亦可以应用于公钥加密，例如在原理上对 RSA 进行处理，但在实用中，公钥密码学通常不用于加密较长的信息，而是使用结合对称加密和公钥加密的混合加密方案。</p>
<p>常见的对称加密模式包括：</p>
<ul>
<li>电子密码本模式（ECB）：是最简单的加密模式，将明文分成固定大小的块，然后每个块单独加密。这种模式的问题在于相同的明文块会加密成相同的密文块，可能导致安全性问题。</li>
<li>密码分组链接模式（CBC）：1976 年，IBM 发明了密码分组链接（CBC，Cipher-block chaining）模式。在 CBC 模式中，每个明文块先与前一个密文块进行异或后，再进行加密。在这种方法中，每个密文块都依赖于它前面的所有明文块。同时，为了保证每条消息的唯一性，在第一个块中需要使用初始化向量。</li>
<li>计数器模式（CTR）：将一个计数器与明文块进行加密，然后再将结果与明文进行异或操作，从而产生密文。这种模式可以并行处理，并且不需要对明文进行填充，因此在某些情况下更高效。</li>
<li>密文反馈模式（CFB）：将前一个密文块作为加密器的输入，然后将结果与明文进行异或操作，得到密文。这种模式可以进行流加密，即逐位地进行加密和解密。</li>
<li>输出反馈模式（OFB）：类似于CFB，但是加密器的输出用于生成密钥流，而不是直接与明文进行异或操作。</li>
</ul>
<p>这些加密模式的选择取决于应用场景、安全需求和性能要求。在实际应用中，需要根据具体情况选择最合适的加密方式和模式。</p>
<h2 id="对称加密的终端练习"><a href="#对称加密的终端练习" class="headerlink" title="对称加密的终端练习"></a>对称加密的终端练习</h2><p>MacOS 自带了一个叫 OpenSSL 的开源加密工具包，提供了一系列的加密算法和安全通信协议的实现，包括 SSL 和 TLS。它由一组函数库和命令行工具组成，可以用于处理数字证书、实现安全通信协议、进行加密和解密等任务。</p>
<p>由于 DES，3DES 目前都不太推荐了，所以这里仅使用 AES 算法演示。</p>
<p>使用 openssl 对明文 helloworld 进行 AES 算法 ECB 模式加密的命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;helloworld&quot;</span> | openssl enc -e -aes-256-ecb -a -pbkdf2 -K 123456</span><br></pre></td></tr></table></figure>

<p>会输出如下结果</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">bnPkNleniCxX5rE1JjnOYg==</span><br></pre></td></tr></table></figure>

<p>对以上结果解密的命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;bnPkNleniCxX5rE1JjnOYg==&quot;</span> | openssl enc -d -aes-256-ecb -a -pbkdf2 -K</span><br><span class="line"> 123456</span><br></pre></td></tr></table></figure>


<p>对明文 helloworld 进行 aes cbc 加密的命令是：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> helloworld | openssl enc -e -aes-256-cbc -a -pbkdf2 -K 123456</span><br><span class="line">U2FsdGVkX19TcP2WjEKOsVXGblFWLGMJM/1dDgvY/S8=</span><br></pre></td></tr></table></figure>

<p>这里 -k 后面的参数 123456 就是用到的密钥。对上面的输出进行解密的命令是：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> U2FsdGVkX19TcP2WjEKOsVXGblFWLGMJM/1dDgvY/S8= | openssl enc -d -aes-256</span><br><span class="line">-cbc -a -pbkdf2 -K 123456</span><br><span class="line">helloworld</span><br></pre></td></tr></table></figure>

<h2 id="iOS-中使用对称加密"><a href="#iOS-中使用对称加密" class="headerlink" title="iOS 中使用对称加密"></a>iOS 中使用对称加密</h2><p>iOS 系统提供了一个 CommonCrypto 库用于加密解密，生成消息摘要（hash）等功能。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;ViewController.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;CommonCrypto/CommonCrypto.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSData</span> *encryptAES256CBC(<span class="built_in">NSData</span> *data, <span class="built_in">NSData</span> *key, <span class="built_in">NSData</span> *iv) &#123;</span><br><span class="line">    size_t bufferSize = data.length + kCCBlockSizeAES128;</span><br><span class="line">    uint8_t buffer[bufferSize];</span><br><span class="line">    size_t numBytesEncrypted = <span class="number">0</span>;</span><br><span class="line">    CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt,</span><br><span class="line">                                          kCCAlgorithmAES,</span><br><span class="line">                                          kCCOptionPKCS7Padding,</span><br><span class="line">                                          key.bytes, key.length,</span><br><span class="line">                                          iv.bytes,</span><br><span class="line">                                          data.bytes, data.length,</span><br><span class="line">                                          buffer, bufferSize,</span><br><span class="line">                                          &amp;numBytesEncrypted);</span><br><span class="line">    <span class="keyword">if</span> (cryptStatus == kCCSuccess) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSData</span> dataWithBytes:buffer length:numBytesEncrypted];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Error: %d&quot;</span>, cryptStatus);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSData</span> *decryptAES256CBC(<span class="built_in">NSData</span> *data, <span class="built_in">NSData</span> *key, <span class="built_in">NSData</span> *iv) &#123;</span><br><span class="line">    size_t bufferSize = data.length + kCCBlockSizeAES128;</span><br><span class="line">    uint8_t buffer[bufferSize];</span><br><span class="line">    size_t numBytesDecrypted = <span class="number">0</span>;</span><br><span class="line">    CCCryptorStatus cryptStatus = CCCrypt(kCCDecrypt,</span><br><span class="line">                                          kCCAlgorithmAES,</span><br><span class="line">                                          kCCOptionPKCS7Padding,</span><br><span class="line">                                          key.bytes, key.length,</span><br><span class="line">                                          iv.bytes,</span><br><span class="line">                                          data.bytes, data.length,</span><br><span class="line">                                          buffer, bufferSize,</span><br><span class="line">                                          &amp;numBytesDecrypted);</span><br><span class="line">    <span class="keyword">if</span> (cryptStatus == kCCSuccess) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSData</span> dataWithBytes:buffer length:numBytesDecrypted];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Error: %d&quot;</span>, cryptStatus);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line">    <span class="built_in">NSString</span> *plaintext = <span class="string">@&quot;helloworld&quot;</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *key = <span class="string">@&quot;12345678123456781234567812345678&quot;</span>; <span class="comment">// 32字节长的密钥</span></span><br><span class="line">    <span class="built_in">NSString</span> *iv = <span class="string">@&quot;0123456789abcdef&quot;</span>; <span class="comment">// 16字节长的初始化向量</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSData</span> *plaintextData = [plaintext dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    <span class="built_in">NSData</span> *keyData = [key dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    <span class="built_in">NSData</span> *ivData = [iv dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSData</span> *encryptedData = encryptAES256CBC(plaintextData, keyData, ivData);</span><br><span class="line">    <span class="keyword">if</span> (encryptedData) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Encrypted data: %@&quot;</span>, [encryptedData base64EncodedStringWithOptions:<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSData</span> *decryptedData = decryptAES256CBC(encryptedData, keyData, ivData);</span><br><span class="line">    <span class="keyword">if</span> (decryptedData) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Decrypted data: %@&quot;</span>, [[<span class="built_in">NSString</span> alloc] initWithData:decryptedData encoding:<span class="built_in">NSUTF8StringEncoding</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>上面的 iOS 代码中使用的加密和解密函数，等价于以下 openssl 终端命令：</p>
<p>加密</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;helloworld&quot;</span> | openssl enc -e -aes-256-cbc -K <span class="string">&quot;3132333435363738313233343536373831323334353637383132333435363738&quot;</span> -iv <span class="string">&quot;30313233343536373839616263646566&quot;</span> -<span class="built_in">base64</span></span><br><span class="line">dMujh+yeGsbTA0xqdhae4Q==</span><br></pre></td></tr></table></figure>

<p>解密</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;dMujh+yeGsbTA0xqdhae4Q==&quot;</span> | openssl enc -d -aes-256-cbc -K <span class="string">&quot;3132333435363738313233343536373831323334353637383132333435363738&quot;</span> -iv <span class="string">&quot;30313233343536373839616263646566&quot;</span> -<span class="built_in">base64</span></span><br><span class="line">helloworld%</span><br></pre></td></tr></table></figure>

<p>openssl 的 -K 和 -iv 参数的类型是 16 进制编码的字符串。12345678123456781234567812345678 的 16 进制编码就是 3132333435363738313233343536373831323334353637383132333435363738，同样 0123456789abcdef 的 16 进制编码就是 30313233343536373839616263646566</p>
<h1 id="非对称密钥加密"><a href="#非对称密钥加密" class="headerlink" title="非对称密钥加密"></a>非对称密钥加密</h1><p>在非对称密钥加密中，不同的密钥用于加密和解密消息。最有用的非对称密钥算法是那些不能从另一个密钥推导出密钥的算法。在这种情况下，一个密钥可以公开，而另一个密钥则保持安全。这种安排通常称为公钥密码术，并且与对称加密相比具有一些明显的优势：消除了向大量用户分发密钥的必要性，并且该算法可用于身份验证以及加密。</p>
<p>第一个广泛使用的公钥算法由 Ron Rivest、Adi Shamir 和 Len Adleman 于 1977 年描述，被称为 RSA 加密，源自其缩写。尽管此后又创建了其他公钥算法，但 RSA 仍然是最常用的。该方法的数学原理超出了本文档的范围，可以在互联网和许多密码学书籍中找到。该算法基于两个大素数及其乘积的数学运算。人们认为它的强度与分解非常大的数的难度有关。以现代数字计算机当前和可预见的速度，在生成 RSA 密钥时选择足够长的素数应该可以使该算法无限期地安全。然而，这一观点尚未得到数学证明，并且快速分解算法或完全不同的破解 RSA 加密的方法是有可能的。此外，如果实用的量子计算机被开发出来，分解大数将不再是一个棘手的问题。</p>
<p>其他公钥算法基于与 RSA 具有同等复杂性的不同数学，包括 ElGamal 加密和椭圆曲线加密。它们的使用类似于 RSA 加密（尽管它们背后的数学原理不同），并且本文档不会进一步讨论它们。</p>
<h2 id="RSA-算法"><a href="#RSA-算法" class="headerlink" title="RSA 算法"></a>RSA 算法</h2><p>1977 年三位麻省理工学院的数学家 罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起设计了一种算法，可以实现非对称加密。这个算法用他们三个人的名字命名，叫做 RSA 算法。</p>
<h3 id="RSA-密钥生成过程"><a href="#RSA-密钥生成过程" class="headerlink" title="RSA 密钥生成过程"></a>RSA 密钥生成过程</h3><p>在 RSA 算法中，首先选择两个大质数 p 和 q，然后计算他们的乘积 n &#x3D; p * q。接下来，计算欧拉函数 φ(n) &#x3D; (p-1)(q-1)。在选择公钥 e 时，需要确保 e 和 φ(n) 互质。<br>然后找到一个整数 d，使得（e * d）mod φ(n) &#x3D; 1。这个 d 就是私钥。</p>
<h3 id="RSA-加密和解密"><a href="#RSA-加密和解密" class="headerlink" title="RSA 加密和解密"></a>RSA 加密和解密</h3><p>在 RSA 加密过程中，明文 m 经过公钥 e 进行加密得到密文 c ，计算公式为 c &#x3D; m<sup>e</sup> % n。在 RSA 解密过程中，密文 c 经过私钥 d 进行解密得到明文 m，计算公式为 m &#x3D; c<sup>d</sup> % n。</p>
<blockquote>
<p>一个问题？在 RSA 算法中，为什么 e 和 φ(n) 互质，d 是 e 的模反元素，就可以保证 M<sup>e * d</sup> % n &#x3D; M 呢？我听过某讲师说是基于欧拉定理，但是欧拉定理的推导中是要求 m 和 n 互质的，但是刚刚 RSA 密钥生成过程中并没有要求 m 和 n 互质，只需要 m 小于 n 就够了。</p>
</blockquote>
<h3 id="RSA-算法的终端练习"><a href="#RSA-算法的终端练习" class="headerlink" title="RSA 算法的终端练习"></a>RSA 算法的终端练习</h3><p>使用 openssl 生成 RSA 私钥的命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">openssl genrsa -out private_key.pem 2048</span><br></pre></td></tr></table></figure>

<p>这个命令会生成一个 2048 位长度的 RSA 私钥，并将其保存在名为 private_key.pem 的文件中。</p>
<p>将私钥转换成对应的公钥，可以使用以下命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">openssl rsa -pubout -<span class="keyword">in</span> private_key.pem -out public_key.pem</span><br></pre></td></tr></table></figure>

<p>现在在当前目录下就会存在两个文件，一个是公钥 <em>public_key.pem</em>，一个是私钥 <em>private_key.pem</em> 。</p>
<p>接下来我们使用这对密钥进行加密解密的演示，先创建一个文件 original.txt 存放明文数据，命令如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;密码是123456&quot;</span> &gt; original.txt</span><br></pre></td></tr></table></figure>

<p>使用公钥对 original.txt 文件进行加密并生成一个 encrypted.txt 文件的命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">openssl pkeyutl -encrypt -<span class="keyword">in</span> original.txt -out encrypted.txt -pubin -inkey public_key.pem</span><br></pre></td></tr></table></figure>

<p>可以使用 <code>cat encrypted.txt </code> 查看加密后的结果，发现是一堆乱码，啥也看不懂。。。接下来使用私钥对 encrypted.txt 文件进行解密并生成一个 decrypted.txt 文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">openssl pkeyutl -decrypt -<span class="keyword">in</span> encrypted.txt -out decrypted.txt -inkey private_key.pem</span><br></pre></td></tr></table></figure>

<p>使用 <code>cat decrypted.txt </code> 查看解密后的结果，可以看到跟 original.txt 的内容是一模一样的。</p>
<!--### RSA 的数学原理
理解 RSA 的密钥生成过程和加密解密需要一定的数学基础，欧拉函数，欧拉定理，模反元素。如果不感兴趣的也可以跳过本节内容。

了解欧拉函数之前，首先需要知道什么是两个数互质，如果两个正整数，除了 1 以外，没有其他公因数，那么这两个数就是互质的。

#### 欧拉函数

欧拉函数也称为欧拉 φ 函数（phi函数），通常用符号 φ(n) 表示，是一个与正整数 n 相关的算术函数。它表示小于或等于 n 的正整数中与 n 互质的数的个数。

欧拉函数的性质：

* 如果 n 为质数，那么 φ(n) = n - 1
* 如果 n 是两个互质的整数 a，b 之积，那么 φ(n) = φ(a) * φ(b)

结合上面两点可以得到以下结论，如果 n 是两个质数 p1，p2 之积，那么

φ(n) = φ(p1) * φ(p2) = (p1 - 1) * (p2 - 1)

#### 欧拉定理

如果两个正整数 m 和 n 互质，那么 m 的 φ(n) 次方减去 1，可以被 n 整除。即：

m<sup>φ(n)</sup> mod n = 1

这个是已经证明的数学定理，不需要怀疑它的正确性。将上式两边同时加上 k 次方可以得到

m<sup>k * φ(n)</sup> mod n = 1

再将两边同时乘以 m 可以得到：

m<sup>k * φ(n) + 1</sup> mod n = m

#### 模反元素-->

<h3 id="iOS-中使用非对称加密算法"><a href="#iOS-中使用非对称加密算法" class="headerlink" title="iOS 中使用非对称加密算法"></a>iOS 中使用非对称加密算法</h3><p>iOS 提供了 Security.framework 框架用于帮助开发者实现各种安全相关的功能。这个框架包含了处理加密、密钥管理、证书、信任策略和安全通信的基本功能。通过使用 Security 框架，开发者可以确保应用程序的数据保护、安全传输和用户身份验证等功能。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;ViewController.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;Security/Security.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"><span class="comment">// 生成密钥对</span></span><br><span class="line">- (<span class="built_in">NSDictionary</span> *)generateKeyPair &#123;</span><br><span class="line">    <span class="built_in">NSDictionary</span> *parameters = @&#123;</span><br><span class="line">        (__bridge <span class="type">id</span>)kSecAttrKeyType : (__bridge <span class="type">id</span>)kSecAttrKeyTypeRSA,</span><br><span class="line">        (__bridge <span class="type">id</span>)kSecAttrKeySizeInBits : @<span class="number">2048</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">CFErrorRef</span> createError = <span class="literal">NULL</span>;</span><br><span class="line">    SecKeyRef privateKeyRef = SecKeyCreateRandomKey((__bridge <span class="built_in">CFDictionaryRef</span>)parameters, &amp;createError);</span><br><span class="line">    SecKeyRef publicKeyRef  = SecKeyCopyPublicKey(privateKeyRef);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (privateKeyRef &amp;&amp; publicKeyRef &amp;&amp; createError == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">NSData</span> *publicKeyData = (__bridge_transfer <span class="built_in">NSData</span> *)SecKeyCopyExternalRepresentation(publicKeyRef, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">NSData</span> *privateKeyData = (__bridge_transfer <span class="built_in">NSData</span> *)SecKeyCopyExternalRepresentation(privateKeyRef, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">CFRelease</span>(privateKeyRef); <span class="comment">// 释放 privateKeyRef</span></span><br><span class="line">        <span class="built_in">CFRelease</span>(publicKeyRef); <span class="comment">// 释放 publicKeyRef</span></span><br><span class="line">        <span class="keyword">return</span> @&#123;</span><br><span class="line">            <span class="string">@&quot;publicKey&quot;</span>: publicKeyData,</span><br><span class="line">            <span class="string">@&quot;privateKey&quot;</span>: privateKeyData</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Failed to generate key pair: %@&quot;</span>, (__bridge <span class="built_in">NSError</span> *)createError);</span><br><span class="line">        <span class="keyword">if</span> (createError) &#123;</span><br><span class="line">            <span class="built_in">CFRelease</span>(createError); <span class="comment">// 释放错误对象</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (privateKeyRef) &#123;</span><br><span class="line">            <span class="built_in">CFRelease</span>(privateKeyRef); <span class="comment">// 释放 privateKeyRef</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (publicKeyRef) &#123;</span><br><span class="line">            <span class="built_in">CFRelease</span>(publicKeyRef); <span class="comment">// 释放 publicKeyRef</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用公钥加密数据</span></span><br><span class="line">- (<span class="built_in">NSData</span> *)encryptDataWithPublicKey:(SecKeyRef)publicKey data:(<span class="built_in">NSData</span> *)data &#123;</span><br><span class="line">    <span class="built_in">CFErrorRef</span> error = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">CFDataRef</span> encryptedData = SecKeyCreateEncryptedData(publicKey, kSecKeyAlgorithmRSAEncryptionPKCS1, (__bridge <span class="built_in">CFDataRef</span>)data, &amp;error);</span><br><span class="line">    <span class="keyword">if</span> (encryptedData &amp;&amp; error == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">NSData</span> *result = (__bridge_transfer <span class="built_in">NSData</span> *)encryptedData;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Encryption failed with error: %@&quot;</span>, (__bridge <span class="built_in">NSError</span> *)error);</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            <span class="built_in">CFRelease</span>(error);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (encryptedData) &#123;</span><br><span class="line">            <span class="built_in">CFRelease</span>(encryptedData);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用私钥解密数据</span></span><br><span class="line">- (<span class="built_in">NSData</span> *)decryptDataWithPrivateKey:(SecKeyRef)privateKey data:(<span class="built_in">NSData</span> *)data &#123;</span><br><span class="line">    <span class="built_in">CFErrorRef</span> error = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">CFDataRef</span> decryptedData = SecKeyCreateDecryptedData(privateKey, kSecKeyAlgorithmRSAEncryptionPKCS1, (__bridge <span class="built_in">CFDataRef</span>)data, &amp;error);</span><br><span class="line">    <span class="keyword">if</span> (error == <span class="literal">NULL</span> &amp;&amp; decryptedData) &#123;</span><br><span class="line">        <span class="built_in">NSData</span> *data = (__bridge <span class="built_in">NSData</span> *)decryptedData;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Decryption failed with error: %@&quot;</span>, (__bridge <span class="built_in">NSError</span> *)error);</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            <span class="built_in">CFRelease</span>(error);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (decryptedData) &#123;</span><br><span class="line">            <span class="built_in">CFRelease</span>(decryptedData);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line">    <span class="built_in">NSDictionary</span> *keyPair = [<span class="keyword">self</span> generateKeyPair];</span><br><span class="line">    <span class="built_in">NSData</span> *publicKeyData = keyPair[<span class="string">@&quot;publicKey&quot;</span>];</span><br><span class="line">    <span class="built_in">NSData</span> *privateKeyData = keyPair[<span class="string">@&quot;privateKey&quot;</span>];</span><br><span class="line">    <span class="keyword">if</span> (publicKeyData &amp;&amp; privateKeyData) &#123;</span><br><span class="line">        <span class="built_in">NSMutableDictionary</span> *attributes = @&#123;</span><br><span class="line">            (__bridge <span class="type">id</span>)kSecAttrKeyType : (__bridge <span class="type">id</span>)kSecAttrKeyTypeRSA,</span><br><span class="line">            (__bridge <span class="type">id</span>)kSecAttrKeyClass : (__bridge <span class="type">id</span>)kSecAttrKeyClassPublic</span><br><span class="line">        &#125;.mutableCopy;</span><br><span class="line">        SecKeyRef publicKeyRef = SecKeyCreateWithData((__bridge <span class="built_in">CFDataRef</span>)publicKeyData, (__bridge <span class="built_in">CFDictionaryRef</span>)attributes, <span class="literal">NULL</span>);</span><br><span class="line">        attributes[(__bridge <span class="type">id</span>)kSecAttrKeyClass] = (__bridge <span class="type">id</span>)kSecAttrKeyClassPrivate;</span><br><span class="line">        SecKeyRef privateKeyRef = SecKeyCreateWithData((__bridge <span class="built_in">CFDataRef</span>)privateKeyData, (__bridge <span class="built_in">CFDictionaryRef</span>)attributes, <span class="literal">NULL</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSString</span> *originalString = <span class="string">@&quot;Hello, World!&quot;</span>;</span><br><span class="line">        <span class="built_in">NSData</span> *originalData = [originalString dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSData</span> *encryptedData = [<span class="keyword">self</span> encryptDataWithPublicKey:publicKeyRef data:originalData];</span><br><span class="line">        <span class="keyword">if</span> (encryptedData) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;Encrypted Data: %@&quot;</span>, [encryptedData base64EncodedStringWithOptions:<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">NSData</span> *decryptedData = [<span class="keyword">self</span> decryptDataWithPrivateKey:privateKeyRef data:encryptedData];</span><br><span class="line">            <span class="keyword">if</span> (decryptedData) &#123;</span><br><span class="line">                <span class="built_in">NSString</span> *decryptedString = [[<span class="built_in">NSString</span> alloc] initWithData:decryptedData encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@&quot;Decrypted String: %@&quot;</span>, decryptedString);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h1 id="Hash-函数"><a href="#Hash-函数" class="headerlink" title="Hash 函数"></a>Hash 函数</h1><p>Hash，一般翻译做“散列”，也有直接音译为“哈希”的。哈希函数是一种将任意大小的输入数据转换为固定长度散列值的算法。哈希函数的主要作用是验证数据的完整性和唯一性，可以简单的理解为二进制数据的身份证或者指纹。常见的哈希函数包括 MD5、SHA-1 和 SHA-256 等。</p>
<p>哈希函数的特点：</p>
<ul>
<li>计算速度快</li>
<li>将任意长度的数据计算出固定长度的哈希值</li>
<li>对相同数据计算得到的结果是不变的</li>
<li>具备单向性，无法逆运算</li>
</ul>
<h2 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h2><p>即 Message Digest 5 的缩写，产生 128 位的哈希值。也就是 32 位 16 进制数。Mac 电脑终端一般自带 md5 命令，可以用于一些简单的计算。例如计算 “12345” 的 md5 值：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">md5 -s 12345</span><br><span class="line">MD5 (<span class="string">&quot;12345&quot;</span>) = 827ccb0eea8a706c4c34a16891f84e7b</span><br></pre></td></tr></table></figure>

<p>假设你有两份同名的文件，但是不确定内容是否是一样的。就可以使用 md5 查看两个文件的哈希值。</p>
<p>注意 md5 由于长度较短，目前已经不太安全，因为可以对明文和它的 md5 哈希值建立一个字典，比如 “12345” 的 md5 值是 827ccb0eea8a706c4c34a16891f84e7b 。目前某些解密网站已经建立了这样的字典，如 <a href="https://www.cmd5.com/">https://www.cmd5.com/</a> 所以如果你的需求对安全性要求较高的话，不推荐使用了。但如果是平时用来验证文件的唯一性倒也没什么太大问题。</p>
<h2 id="SHA"><a href="#SHA" class="headerlink" title="SHA"></a>SHA</h2><p>SHA 代表安全散列算法（Secure Hash Algorithm），是一种广泛使用的密码学哈希函数，用于生成数据的哈希值。哈希函数将输入数据转换为固定长度的数据串，通常是一串数字和字母的组合，该串称为哈希值或消息摘要。SHA 算法的哈希值长度可以根据具体的 SHA 版本而变化，比如 SHA-1 生成 160 位的哈希值，而 SHA-256 生成 256 位的哈希值。目前主流的 SHA 版本主要是 SHA-256 和 SHA-3。这两个版本都是较新的，并且在安全性和性能方面都得到了广泛认可。</p>
<h3 id="SHA-1"><a href="#SHA-1" class="headerlink" title="SHA-1"></a>SHA-1</h3><p>产生 160 位的散列值，目前已经不安全</p>
<h3 id="SHA-2"><a href="#SHA-2" class="headerlink" title="SHA-2"></a>SHA-2</h3><p>SHA-256，SHA-384，SHA-512，散列值长度分别是 256 位，384 位，512 位</p>
<h3 id="SHA-3"><a href="#SHA-3" class="headerlink" title="SHA-3"></a>SHA-3</h3><p>SHA-3 是 NIST 选定的一种新的哈希算法标准，也称为 Keccak。它是在 SHA-2 之后发布的，与 SHA-2 系列不同，SHA-3 提供了与之前版本不同的设计和性能特性。SHA-3 的最常见变体是 SHA-3-256，生成 256 位的哈希值。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul>
<li>HMAC（Hash-based Message Authentication Code）是一种用于验证消息完整性和真实性的加密方案。</li>
<li>拆词搜索</li>
<li>版权</li>
<li>数字签名</li>
</ul>
<h1 id="base64-编码"><a href="#base64-编码" class="headerlink" title="base64 编码"></a>base64 编码</h1><p>Base64 编码是一种将二进制数据转换成文本数据的编码方式。在 Base64 编码中，每个字符由 64 个字符中的一个表示，因此得名。Base64 编码常用于在网络传输中表示二进制数据，比如在电子邮件中传输附件、在网页中嵌入图片等场景。</p>
<p>Base64 编码的原理是将二进制数据每 6 位转换成一个字符，所以每 3 个字节（24 位）的二进制数据转换成 4 个 Base64 字符。如果原始数据长度不是 3 的倍数，则在末尾补上相应数量的 0，并用 “&#x3D;” 字符填充以保持长度是 4 的倍数。所以以后看到字符串的末尾是 “&#x3D;” 字符的时候，它有可能就是 Base64 编码后的字符串。</p>
<p>Base64 编码使用了 64 个字符，通常是大小写字母 a-z、A-Z、数字 0-9，以及两个额外的字符（通常是”+”和”&#x2F;“）作为基本字符集，不同的实现中有时候会用不同的字符集。</p>
<p>Base64 编码并不是加密算法，因为它可以轻松地被解码还原成原始数据。它的主要作用是在不支持二进制传输的环境中，将二进制数据表示为文本，便于传输和处理。</p>
<h1 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h1><p>数字签名是一种用于验证数据完整性和身份验证的技术。它使用非对称加密技术，结合了哈希函数和公钥加密算法，以确保数据的完整性、真实性和不可否认性。</p>
<p>数字签名通常由以下步骤组成：</p>
<ol>
<li>创建消息摘要：发送方使用哈希函数（如 SHA-256）生成消息的摘要或哈希值。这个摘要是一个固定长度的字符串，用于代表原始数据的内容。</li>
<li>使用私钥签名：发送方使用自己的私钥对消息摘要进行加密，形成数字签名。私钥只有发送方知道，因此只有发送方能够使用私钥进行签名。</li>
<li>传输数据：发送方将原始数据与数字签名一起发送给接收方。</li>
<li>验证签名：接收方收到数据后，使用发送方的公钥对数字签名进行解密，得到消息摘要。然后，接收方使用相同的哈希函数生成接收到的原始数据的摘要。如果两个摘要匹配，则表明数据未被篡改，签名有效；否则，数据可能已被篡改或签名无效。</li>
</ol>
<p>数字签名的主要目的是确保数据的完整性和真实性，同时提供身份验证和不可否认性，即发送方不能否认其曾经签署过数据。这使得数字签名在许多领域，如电子商务、数字文档、软件分发等方面发挥了重要作用。</p>
<p>简单的一句话概括，数字签名就是使用私钥对数据的哈希值进行加密。</p>
<h1 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h1><p>数字证书是一种用于加密和认证网络通信的安全工具。它是由一个权威的数字证书颁发机构（Certificate Authority，CA）签发的一种电子文档，用于确认特定实体的身份信息。数字证书包含了一些重要的信息，包括：</p>
<p>一个数字证书通常包含以下信息：</p>
<ul>
<li>主体信息：证书的主体是该证书所代表的实体，通常是一个个人、组织或网络设备。主体信息通常包括名称、电子邮件地址等。</li>
<li>公钥：证书包含了主体的公钥，用于加密和验证数字签名。这个公钥与主体的私钥配对，用于加密和解密通信数据。</li>
<li>证书序列号：每个证书都有一个唯一的序列号，用于标识该证书。</li>
<li>有效期：证书有一个有效期限，指定了证书的生效时间和到期时间。过期的证书不再可信。</li>
<li>数字签名：证书被 CA 用其私钥签名，以确保证书的真实性和完整性。客户端可以使用 CA 的公钥来验证数字签名。</li>
<li>颁发者信息：指定了颁发该证书的 CA 的信息。</li>
<li>扩展信息：可能包含一些其他信息，例如用途、策略等。</li>
</ul>
<p>数字证书在网络通信中广泛用于安全连接的建立，例如 HTTPS（安全的HTTP）、SSL&#x2F;TLS等。通过验证数字证书的真实性，可以确保与远程服务器之间的通信是安全的，并且可以防止中间人攻击等安全威胁。</p>
]]></content>
      <tags>
        <tag>iOS，密码学，hash，RSA，DES，AES</tag>
      </tags>
  </entry>
  <entry>
    <title>揭开神秘的iOS布局</title>
    <url>/2018/03/26/%E6%8F%AD%E7%A7%98iOS%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<p>翻译自: <a href="http://tech.gc.com/demystifying-ios-layout/">Demystifying iOS Layout</a></p>
<p>在你刚开始开发iOS应用时,最难避免或者说最难调试的是处理视图的布局和内容;通常这些事情的发生是因为对 <strong>视图更新</strong> 真实发生存在误解;了解 <strong>视图更新</strong> 的方式和时间需要更深入地了解iOS应用程序的主运行循环,以及它如何与<code>UIView</code>提供的某些方法关联;这篇博文将解释这些互动,希望澄清如何使用<code>UIView</code>的方法来获得你想要的行为;</p>
<h2 id="iOS应用程序的主运行循环"><a href="#iOS应用程序的主运行循环" class="headerlink" title="iOS应用程序的主运行循环"></a>iOS应用程序的主运行循环</h2><p>iOS应用程序的主运行循环用来处理所有用户输入事件并在您的应用程序中触发适当的响应;任何与应用程序的用户交互都会被添加到事件队列中;应用程序对象(如下图所示)将事件队列中的事件取出,并将它们分派给应用程序中的其他对象;<strong>它本质上是通过解释来自用户的输入事件并在应用程序的核心对象中为该输入调用相应的处理程序来执行运行循环</strong>;这些处理程序调用应用程序开发人员编写的代码;一旦这些方法调用返回,控制回到主运行循环并且开始更新周期;更新周期负责布局和重绘视图(在下一节中介绍);下面是应用程序如何与设备进行通信并处理用户输入的插图</p>
<p><img src="http://tech.gc.com/images/demystifying-ios-layout/main_event_loop.jpg" alt="Main Event Loop"></p>
<p><em><a href="https://developer.apple.com/library/content/documentation/General/Conceptual/Devpedia-CocoaApp/MainEventLoop.html">https://developer.apple.com/library/content/documentation/General/Conceptual/Devpedia-CocoaApp/MainEventLoop.html</a></em></p>
<h2 id="更新周期-Update-Cycle"><a href="#更新周期-Update-Cycle" class="headerlink" title="更新周期(Update Cycle)"></a>更新周期(Update Cycle)</h2><p>更新周期是应用程序完成运行所有事件处理代码后,控制权返回到主运行循环的点;就是在这个点,系统开始更新布局,显示和约束;如果您要求改变视图而它正在执行事件处理程序,系统会将此视图标记为需要重绘;在下一次更新周期,系统将执行这些视图上所有的变化;用户交互和布局更新之间的时间间隔对用户来说应该是感觉不到的;iOS应用程序通常以60fps动画,这意味着一个刷新周期只需要1&#x2F;60秒;由于这种情况发生的速度很快,用户不会注意到她与设备上的应用程序进行交互和看到内容和布局更新之间的UI的滞后;但是,由于事件被执行的时间和相应视图的重绘时间之间存在时间间隔,所以在运行循环过程中,视图可能不会按照您希望的方式更新;如果您有任何计算依赖视图最新的内容或布局,您有可能操作的是该视图的旧的内容或布局而不是最新的;了解运行循环,更新周期和某些的<code>UIView</code>方法能够帮助避免或者调试这类问题;</p>
<p>您可以在下图中看到更新周期在运行循环结束时如何发生<br><img src="http://tech.gc.com/images/demystifying-ios-layout/tech-blog-loop.png" alt="Update Cycle"></p>
<h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>视图的布局指的是它在屏幕上的大小和位置;每一个视图都有一个<code>frame</code>属性来描述它在父视图坐标系统中的位置以及它的大小;<code>UIView</code>提供了一些方法,可以让你通知系统一个视图的布局已经改变,同时为你提供了可以重写的方法,以便在重新计算视图的布局后定义要执行的操作</p>
<h3 id="layoutSubviews"><a href="#layoutSubviews" class="headerlink" title="layoutSubviews()"></a>layoutSubviews()</h3><p>这个<code>UIView</code>方法调整视图及其所有子视图的大小和位置;它给出当前视图和每个子视图的位置和大小;此方法很昂贵,因为它对视图的所有子视图起作用并调用其相应的<code>layoutSubviews</code>方法;系统会在任何需要重新计算视图的 frame 属性时调用此方法,因此当您想要设置 frame 属性指定视图位置和大小的时候您应该重写此方法;但是,当您的视图层次结构需要布局刷新时,您绝不应该显示的调用它;相反,在运行循环期间,您可以使用多种机制在不同点触发<code>layoutSubviews</code>调用,这比直接调用<code>layoutSubviews</code>方法要便宜的多;</p>
<p>当<code>layoutSubviews</code>方法完成时,将在拥有该视图的视图控制器中触发对<code>viewDidLayoutSubviews</code>的调用;<strong>由于<code>layoutSubviews</code>是更新视图布局后可靠调用的唯一方法,因此应该将任何取决于布局和大小的逻辑代码方法<code>viewDidLayoutSubviews</code>中,而不是放在<code>viewDidLoad</code>或<code>viewDidAppear</code>中</strong>;这是避免使用过时的布局或者位置变量的唯一方法。</p>
<h2 id="自动刷新触发器"><a href="#自动刷新触发器" class="headerlink" title="自动刷新触发器"></a>自动刷新触发器</h2><p>有多个事件会自动地将视图标记为布局已经改变,所以该视图的<code>layoutSubviews</code>方法将在下一次更新周期时被系统调用,不需要开发人员手动执行这个方法;</p>
<p>这些自动将视图标记为布局已经改变的方式有以下几种:</p>
<ul>
<li>改变视图的大小</li>
<li>添加子视图</li>
<li>用户滚动<code>UIScrollView</code>(<code>layoutSubviews</code>方法会被<code>UIScrollView</code>以及它的父视图调用)</li>
<li>用户旋转设备</li>
<li>更新视图的约束</li>
</ul>
<p>以上这些方式都告诉系统,视图的位置需要重新计算并且会自动导致最终的<code>layoutSubviews</code>方法的调用;当然,也有直接触发<code>layoutSubviews</code>方法调用的办法;</p>
<h3 id="setNeedsLayout"><a href="#setNeedsLayout" class="headerlink" title="setNeedsLayout()"></a>setNeedsLayout()</h3><p>触发<code>layoutSubviews</code>调用最省资源的方式就是在您的视图上调用<code>setNeedsLayout</code>方法;这将指示系统这个视图的布局需要重新计算;<code>setNeedsLayout</code>执行并立即返回,并且在返回之前并不实际更新视图;相反,视图将会在下一个更新周期(系统调用这些视图以及后续所有子视图的<code>layoutSubviews</code>方法)实际更新视图的布局;即使从<code>setNeedsLayout</code>返回后到视图被重新绘制布局之间有一段任意的时间间隔,但是这个延迟不会对用户造成影响,因为永远不会长到对界面造成卡顿;</p>
<h3 id="layoutIfNeeded"><a href="#layoutIfNeeded" class="headerlink" title="layoutIfNeeded()"></a>layoutIfNeeded()</h3><p><code>layoutIfNeeded</code>是<code>UIView</code>的另一个将会在不久后触发<code>layoutSubviews</code>调用的方法;与<code>setNeedsLayout</code>会让视图在下一个周期调用<code>layoutSubviews</code>更新视图不同,<code>layoutIfNeeded</code>会立即触发<code>layoutSubviews</code>方法调用,如果视图需要布局更新的话;如果你在调用<code>setNeedsLayout</code>方法或者触发上面描述的自动刷新触发器之后调用了<code>layoutIfNeeded</code>方法,<code>layoutSubviews</code>将会在视图上被调用;然而,如果你调用<code>layoutIfNeeded</code>之后没有动作指示系统视图需要重新刷新视图,那么<code>layoutSubviews</code>方法将不会被调用;<br>在一次运行循环中,两次调用视图的<code>layoutIfNeeded</code>方法之间,视图的布局并没有变化的话,那么第二次调用将不会触发<code>layoutSubviews</code>的调用;</p>
<p>与<code>setNeedsLayout</code>方法不同,使用<code>layoutIfNeeded</code>方法,布局和重绘会在函数返回之前立即发生改变(除非有正在运行中的动画);这个方法在你需要依赖新的布局而又无法等待视图的下次更新周期到来的时候特别有用;然而,除了这种情况外,你还是应该调用<code>setNeedsLayout</code>然后等待下次更新周期的到来,这样在每次运行循环中都只会更新一次布局;</p>
<p>动画更改约束时,此方法特别有用;您应该在动画的 block 开始之前调用一次<code>layoutIfNeeded</code>,以确保在动画开始之前通知所有的布局更新;配置新的约束,然后在动画 block 内,再次调用<code>layoutIfNeeded</code>以动画到最新的状态;</p>
<h2 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h2><p>视图的显示包含颜色,文本,图片和Core Graphics绘制等视图属性,但不包含它和它的子视图的大小和位置;和布局的方法类似,显示也有触发更新的方法,它们由系统在检测到更新时被自动调用,或者我们可以手动调用直接触发更新;</p>
<h3 id="draw"><a href="#draw" class="headerlink" title="draw(_:)"></a>draw(_:)</h3><p><code>UIView</code>的<code>draw</code>方法(Objective-C中的<code>drawRect</code>)对视图的显示内容的作用	就像 <code>layoutSubviews</code>方法对视图的位置和尺寸的作用;同<code>layoutSubviews</code>一样,你不应该在代码中直接调用<code>draw</code>方法,而应该在运行循环的不同点调用能触发<code>draw</code>方法调用的方法;然而,与<code>layoutSubviews</code>方法不同的是,<code>draw</code>方法不会触发后续子视图的调用;</p>
<h3 id="setNeedsDisplay"><a href="#setNeedsDisplay" class="headerlink" title="setNeedsDisplay()"></a>setNeedsDisplay()</h3><p>这个方法类似布局中的<code>setNeedsLayout</code>;它会给有显示内容更新的视图设置一个内部的标记之后返回,并不会真正的视图重绘;而是在接下来的更新周期中,系统会遍历所有已被标记的视图,调用它们的<code>draw</code>方法;如果你只想在下次更新时重绘部分的视图,你可以调用<code>setNeedsDisplay(_:)</code>(Objective-C中的<code>setNeedsDisplayInRect:</code>)方法,并把希望重绘的矩形部分传入参数;</p>
<p>大部分时候,在视图中更新任何 UI 组件都会通过自动设置内部的”显示内容更新”标记将视图标记为”dirty”的;导致在下一次更新周期中视图的内容就会重绘而不需要直接显示调用<code>setNeedsDisplay</code>;然而如果你有一个属性没有绑定到UI控件,但需要在属性值每次更新重绘视图,那么你可以实现该属性的<code>didSet</code>方法,并在里面调用<code>setNeedsDisplay</code>方法来触发视图的更新;</p>
<p>有时设置一个属性要求自定义绘制,这种情况下你需要重写<code>draw</code>方法;在下面的例子中,设置<code>numberOfPoints</code>会触发系统根据具体点数绘制不同的视图;在这个例子中,你需要在<code>draw</code>方法中实现自定义绘制,并在<code>numberOfPoints</code>的property observer里调用<code>setNeedsDisplay</code>;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class MyView: UIView &#123;</span><br><span class="line">	var numberOfPoints = 0 &#123;</span><br><span class="line">		didSet &#123;</span><br><span class="line">			setNeedsDisplay()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	override func draw(_ rect: CGRect) &#123;</span><br><span class="line">		switch numberOfPoints &#123;</span><br><span class="line">		case 0: </span><br><span class="line">			return</span><br><span class="line">		case 1: </span><br><span class="line">			drawPoint(rect)</span><br><span class="line">		case 2:</span><br><span class="line">			drawLine(rect)</span><br><span class="line">		case 3: </span><br><span class="line">			drawTriangle(rect)</span><br><span class="line">		case 4:</span><br><span class="line">			drawRectangle(rect)</span><br><span class="line">		case 5: </span><br><span class="line">			drawPentagon(rect)</span><br><span class="line">		default:</span><br><span class="line">			drawEllipse(rect)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>视图的显示方法里没有类似布局中的<code>layoutIfNeeded</code>这样可以触发立即更新的方法;通常情况下等到下一个更新周期再重新绘制视图也无所谓;</p>
<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>在自动布局技术中布局和重绘视图有三个步骤;第一步是更新约束,系统计算并设置视图上所有必需的约束条件;第二步是布局阶段,布局引擎计算视图和子视图的 frame 并且将它们布局;最后一步完成这一循环的是显示阶段;第三步完成此次循环的是显示阶段,如果有必要,那么通过调用视图的<code>draw</code>方法重绘视图的内容;</p>
<h3 id="updateConstraints"><a href="#updateConstraints" class="headerlink" title="updateConstraints()"></a>updateConstraints()</h3><p>这个方法用在自动布局中动态的改变视图的约束;和布局中的<code>layoutSubviews</code>方法和显示内容中的<code>draw</code>方法类似,<code>updateConstraints</code>只应该被重写,而不应该在你的代码中直接调用;一般来说,您应该在<code>updateConstraints</code>方法中仅仅实现必须要更新的约束;静态的约束应该设置在interface builder,视图的初始化方法(initializer)或者控制器的<code>viewDidLoad</code>中;</p>
<p>通常情况下,开启或者关闭约束,更改约束的优先级或者常量值,或者从视图层级中移除一个视图时都会设置一个内部的标记,这个标记将会在下一次更新周期触发<code>updateConstraints</code>方法调用;当然啦,也有手动的给视图打上需要更新约束的标记的方法,如下:</p>
<h3 id="setNeedsUpdateConstraints"><a href="#setNeedsUpdateConstraints" class="headerlink" title="setNeedsUpdateConstraints()"></a>setNeedsUpdateConstraints()</h3><p>调用<code>setNeedsUpdateConstraints</code>会保证在下一次的更新周期中更新约束;它通过标记视图的约束已更新来触发<code>updateConstraints</code>调用;这个方法和<code>setNeedsDisplay</code>,<code>setNeedsLayout</code>方法的工作机制类似;</p>
<h3 id="updateConstraintsIfNeeded"><a href="#updateConstraintsIfNeeded" class="headerlink" title="updateConstraintsIfNeeded()"></a>updateConstraintsIfNeeded()</h3><p>这个方法就等同于使用了自动布局的视图中的<code>layoutIfNeeded</code>方法;它会检查视图约束是否更新的标记(能够被自动设置,或者通过<code>setNeedsUpdateConstraints</code>设置,或者通过<code>invalidateInstrinsicContentSize</code>设置),如果它表明约束需要更新,它将立刻触发<code>updateConstraints</code>方法的调用而不需要等到运行循环的结束;</p>
<h3 id="invalidateIntrinsicContentSize"><a href="#invalidateIntrinsicContentSize" class="headerlink" title="invalidateIntrinsicContentSize()"></a>invalidateIntrinsicContentSize()</h3><p>一些使用自动布局的视图中会有一个<code>intrinsicContentSize</code>的属性,这是视图根据它的内容得到的自然尺寸;一个视图的<code>intrinsicContentSize</code>属性通常由所包含的元素的约束来决定,但是也可以通过重写来提供自定义的行为;调用<code>invalidateIntrinsicContentSize</code>会设置一个标记表示这个视图的<code>intrinsicContentSize</code>已经过期,需要在下一个布局阶段重新计算;</p>
<h2 id="它们是如何连接的"><a href="#它们是如何连接的" class="headerlink" title="它们是如何连接的"></a>它们是如何连接的</h2><p>视图的布局,显示以及约束都遵循着相似的模式,例如它们更新的方式以及如何在运行循环的不同点上强制更新;任意组件都有一个实际去更新的方法(<code>layoutSubviews</code>,<code>draw</code>,以及<code>updateConstraints</code>),你可以重写来手动操作视图,但是任何情况下都不要在你的代码中直接调用;这些方法仅仅在视图有标记,告诉系统视图的某些组件需要更新了,在主运行循环的后面被调用;有些操作会自动设置这个标志,也有一些方法能够让您手动的设置它;对于布局和约束的更新,如果您无法等到更新周期的到来(因为有些操作依赖最新的布局),有这么一些方法可以让你立即更新,并保证布局需要更新标记被正确标记;下面的表格列出了任意组件会怎样更新及其对应方法;</p>
<table>
<thead>
<tr>
<th>Method purposes</th>
<th>Layout</th>
<th>Display</th>
<th>Constraints</th>
</tr>
</thead>
<tbody><tr>
<td>Implement updates(override,don’t call explicitly)</td>
<td><code>layoutSubviews</code></td>
<td><code>draw</code></td>
<td><code>updateConstraints</code></td>
</tr>
<tr>
<td>Explicitly mark view as needing update on next update cycle</td>
<td><code>setNeedsLayout</code></td>
<td><code>setNeedsDisplay</code></td>
<td><code>setNeedsUpdateConstraints</code> <code>invalidateIntrinsicContentSize</code></td>
</tr>
<tr>
<td>Update iimmediately if view is marked as ‘dirty’</td>
<td><code>layoutIfNeeded</code></td>
<td></td>
<td><code>updateConstraintsIfNeeded</code></td>
</tr>
<tr>
<td>Actions that implicitly cause views to be updated</td>
<td><code>addSubview</code><br> Resizing视图,通过<code>setFrame</code>改变视图的<code>bounds</code>(不只是translation)<br>用户滑动UIScrollView<br>用户旋转设备</td>
<td>改变视图的<code>bounds</code></td>
<td>激活&#x2F;禁用约束<br>更改约束的值或者优先级<br>从视图层次结构中移除视图</td>
</tr>
</tbody></table>
<p>下面的流程图总结了<strong>更新周期</strong>和<strong>事件循环</strong>之间的交互,并指出了上文提到的方法在<strong>运行循环</strong>期间的位置;你可以在运行循环中的任意一点直接的调用<code>layoutIfNeeded</code>或者<code>updateConstraintsIfNeeded</code>,需要记住,这开销会很大;在循环的主运行循环的后面是更新周期,如果视图被设置特定的”需要更新约束”,”需要更新布局”或者”需要更新显示”的标记,在这个节点会进行更新约束,更新布局以及更新显示内容;一旦这些更新结束,主运行循环会重新开始;</p>
<p><img src="http://tech.gc.com/images/demystifying-ios-layout/update_cycle.png" alt="Update Cycle"><em><a href="https://i.stack.imgur.com/i9YuN.png">https://i.stack.imgur.com/i9YuN.png</a></em></p>
]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>SDWebimage设置图片时URL不变，但图片改变的解决办法</title>
    <url>/2018/07/17/SDWebimage%E8%AE%BE%E7%BD%AE%E5%9B%BE%E7%89%87%E6%97%B6URL%E4%B8%8D%E5%8F%98%EF%BC%8C%E4%BD%86%E5%9B%BE%E7%89%87%E6%94%B9%E5%8F%98%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<p>本篇文章转载自<a href="https://blog.csdn.net/xumugui007/article/details/51605546">SDWebImage支持URL不变时更新图片内容</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SDWebImage在iOS项目中是一个很常用的开源库，而且众所周知的是，它是基于URL作为Key来实现图片缓存机制的。在90%左右的情况下，</span><br><span class="line">图片与URL是一一对应的，即使服务器修改了图片也会相应的变更URL。但是在少数情况下，服务器修改了图片后不会变更相应的URL，也就是</span><br><span class="line">说图片本身的内容变了然而它的URL没有变化，那么按照对SDWebImage的常规使用方法的话，客户端肯定更新不到同一URL对应到服务器已变</span><br><span class="line">更的图片内容。</span><br></pre></td></tr></table></figure>

<p>基于这一现象，我们来进行分析。</p>
<p>客户端第一次请求图片时，Charles抓包得知response header里有一个名为Last-Modified、数据是时间戳的键值对。</p>
<p>客户端第二次及以后请求图片时，通过Charles抓包发现，服务器返回304 not modified状态，说明服务器在接收客户端请求后通过某种判断逻辑得出结论：“客户端已缓存的图片与服务器图片都是最新的”，那么服务器如何判断的呢？</p>
<p>通过查阅HTTP协议相关的资料得知，与服务器返回的Last-Modified相对应的request header里可以加一个名为If-Modified-Since的key，value即是服务器回传的服务端图片最后被修改的时间，第一次图片请求时If-Modified-Since的值为空，第二次及以后的客户端请求会把服务器回传的Last-Modified值作为If-Modified-Since的值传给服务器，这样服务器每次接收到图片请求时就将If-Modified-Since与Last-Modified进行比较，如果客户端图片已陈旧那么返回状态码200、Last-Modified、图片内容，客户端存储Last-Modified和图片；如果客户端图片是最新的那么返回304 Not Modified、不会返回Last-Modified、图片内容。</p>
<p>关于服务器的比较逻辑，需要强调一下。</p>
<p>经查资料得知，Apache比较时是看If-Modified-Since之后有没有更新图片，Nginx比较时是看If-Modified-Since与Last-Modified是否相等，所以对于Apache服务器环境客户端每次都要严格的存储服务器回传的Last-Modified以便下次请求时作为If-Modified-Since的值传给服务器，对于Nginx服务器环境客户端不必存储服务器回传的Last-Modified，每次请求时只需将图片自身的fileModificationDate作为If-Modified-Since的值传服务器即可。在实际开发中，如果遇到明明传了If-Modified-Since、服务器图片也变更了、但是客户端却请求不到最新的图片的情况时，那么就需要查看一下服务器对这两个时间戳的比较逻辑。</p>
<p>那么，现在我们可以回到SDWebImage上来了。通过查看SDWebImageDownloader的源码得知，它开放了一个headersFilter的block，意在让开发者可以对所有图片请求追加一些额外的header，这正合我意。那么我们就可以在诸如AppDelegate didFinishLaunching的地方追加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SDWebImageDownloader *imgDownloader = SDWebImageManager.sharedManager.imageDownloader;</span><br><span class="line">imgDownloader.headersFilter  = ^NSDictionary *(NSURL *url, NSDictionary *headers) &#123;</span><br><span class="line"> </span><br><span class="line">    NSFileManager *fm = [[NSFileManager alloc] init];</span><br><span class="line">    NSString *imgKey = [SDWebImageManager.sharedManager cacheKeyForURL:url];</span><br><span class="line">    NSString *imgPath = [SDWebImageManager.sharedManager.imageCache defaultCachePathForKey:imgKey];</span><br><span class="line">    NSDictionary *fileAttr = [fm attributesOfItemAtPath:imgPath error:nil];</span><br><span class="line"> </span><br><span class="line">    NSMutableDictionary *mutableHeaders = [headers mutableCopy];</span><br><span class="line"> </span><br><span class="line">    NSDate *lastModifiedDate = nil;</span><br><span class="line"> </span><br><span class="line">    if (fileAttr.count &gt; 0) &#123;</span><br><span class="line">        if (fileAttr.count &gt; 0) &#123;</span><br><span class="line">            lastModifiedDate = (NSDate *)fileAttr[NSFileModificationDate];</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];</span><br><span class="line">    formatter.timeZone = [NSTimeZone timeZoneWithAbbreviation:@&quot;GMT&quot;];</span><br><span class="line">    formatter.locale = [[NSLocale alloc] initWithLocaleIdentifier:@&quot;en_US&quot;];</span><br><span class="line">    formatter.dateFormat = @&quot;EEE, dd MMM yyyy HH:mm:ss z&quot;;</span><br><span class="line"> </span><br><span class="line">    NSString *lastModifiedStr = [formatter stringFromDate:lastModifiedDate];</span><br><span class="line">    lastModifiedStr = lastModifiedStr.length &gt; 0 ? lastModifiedStr : @&quot;&quot;;</span><br><span class="line">    [mutableHeaders setValue:lastModifiedStr forKey:@&quot;If-Modified-Since&quot;];</span><br><span class="line"> </span><br><span class="line">    return mutableHeaders;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后，加载图片的地方以前怎么写还是怎么写，但别忘了Option是SDWebImageRefreshCached</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSURL *imgURL = [NSURL URLWithString:@&quot;http://handy-img-storage.b0.upaiyun.com/3.jpg&quot;];</span><br><span class="line">[[self imageView] sd_setImageWithURL:imgURL</span><br><span class="line">                    placeholderImage:nil</span><br><span class="line">                             options:SDWebImageRefreshCached];</span><br></pre></td></tr></table></figure>

<p>经测试，服务器只修改图片不变更URL的时候，客户端也可以更新到最新的图片。</p>
<p>从以上第一段代码内容可以看出我采用的是与ngix服务器比较逻辑对应的代码，BTW:我测试的服务器是又拍云，说明又拍云的比较逻辑是等与不等的关系判断，不是大小关系的判断。</p>
<p>这里顺便说一下，如果服务器的环境是类似于Apache的比较逻辑时，客户端可以把Last-Modified存放在图片的名称上(这需要修改SDWebImage源码，不建议)，或者用一个plist文件存放图片key名称与时间的对应关系(这个不用修改源码)。</p>
<p>OK，到此这次的主题已得到完美解决。</p>
]]></content>
  </entry>
  <entry>
    <title>解决git clone速度慢的问题</title>
    <url>/2018/10/26/%E8%A7%A3%E5%86%B3git-clone%E9%80%9F%E5%BA%A6%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>之前一直以为是公司对网络的封锁,导致git clone速度慢,后来网上查找这个问题的时候得知不能怪公司,是因为咱们在这个局域网内…<br>扯多了,回到正题,解决问题,由于我的是Mac电脑,我说的只针对Mac电脑</p>
<h5 id="1-进入终端命令行模式-输入"><a href="#1-进入终端命令行模式-输入" class="headerlink" title="1. 进入终端命令行模式,输入"></a>1. 进入终端命令行模式,输入</h5><p><code>sudo vim /etc/hosts</code></p>
<h5 id="2-输入i进入编辑模式-移动到最后一行准备输入"><a href="#2-输入i进入编辑模式-移动到最后一行准备输入" class="headerlink" title="2. 输入i进入编辑模式,移动到最后一行准备输入"></a>2. 输入i进入编辑模式,移动到最后一行准备输入</h5><h5 id="3-用浏览器访问-http-tool-chinaz-com-使用-IP查询-工具获得github-com和github-global-ssl-fastly-net的ip地址"><a href="#3-用浏览器访问-http-tool-chinaz-com-使用-IP查询-工具获得github-com和github-global-ssl-fastly-net的ip地址" class="headerlink" title="3. 用浏览器访问 http://tool.chinaz.com 使用 IP查询 工具获得github.com和github.global.ssl.fastly.net的ip地址"></a>3. 用浏览器访问 <a href="http://tool.chinaz.com/">http://tool.chinaz.com</a> 使用 IP查询 工具获得github.com和github.global.ssl.fastly.net的ip地址</h5><h5 id="4-回到第2步中按如下格式输入"><a href="#4-回到第2步中按如下格式输入" class="headerlink" title="4. 回到第2步中按如下格式输入:"></a>4. 回到第2步中按如下格式输入:</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">192.30.253.112 github.com</span><br><span class="line">151.101.44.249 github.global.ssl.fastly.net</span><br></pre></td></tr></table></figure>
<h5 id="5-按-esc-键-然后输入-wq-保存文件并退出vim编辑模式-到此hosts文件修改结束"><a href="#5-按-esc-键-然后输入-wq-保存文件并退出vim编辑模式-到此hosts文件修改结束" class="headerlink" title="5. 按 esc 键,然后输入 :wq 保存文件并退出vim编辑模式,到此hosts文件修改结束"></a>5. 按 esc 键,然后输入 :wq 保存文件并退出vim编辑模式,到此hosts文件修改结束</h5><h5 id="6-更新DNS缓存-输入"><a href="#6-更新DNS缓存-输入" class="headerlink" title="6. 更新DNS缓存,输入"></a>6. 更新DNS缓存,输入</h5><p><code>sudo dscacheutil -flushcache </code></p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一个pod install失败的解决方法</title>
    <url>/2018/04/16/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%AApod-install%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>今天在网络看到一个demo,想把它clone下来运行一下看看效果,大家都知道一般clone下来的项目需要使用<code>pod install</code>命令安装一下第三方库的,这个demo也不例外;问题在于这个demo的cocoapods版本太低了(0.39.0)以至于Podfile中有些语法现如今都无法识别…以下截图是执行<code>pod install</code>命令之后给出了的错误提示:<br><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/master/Snip20180416_21.png"></p>
<p>项目的Podfile如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source &#x27;https://github.com/CocoaPods/Specs.git&#x27;</span><br><span class="line">use_frameworks!</span><br><span class="line"></span><br><span class="line">target &#x27;RTPagedCollectionViewLayout_Example&#x27;, :exclusive =&gt; true do</span><br><span class="line">  pod &#x27;RTPagedCollectionViewLayout&#x27;, :path =&gt; &#x27;../&#x27;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">target &#x27;RTPagedCollectionViewLayout_Tests&#x27;, :exclusive =&gt; true do</span><br><span class="line">  pod &#x27;RTPagedCollectionViewLayout&#x27;, :path =&gt; &#x27;../&#x27;</span><br><span class="line">  </span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>大概的意思就是不支持 :exclusive &#x3D;&gt; true语法，在cocoaPods 1.0之后exclusive语法已经被移除了</p>
<p><a href="https://github.com/CocoaPods/CocoaPods/issues/4705">这里是Stack Overflow上的解答</a></p>
<p>将相关的代码删除之后,注意<code>,</code>号也要删除;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source &#x27;https://github.com/CocoaPods/Specs.git&#x27;</span><br><span class="line">use_frameworks!</span><br><span class="line"></span><br><span class="line">target &#x27;RTPagedCollectionViewLayout_Example&#x27; do</span><br><span class="line">  pod &#x27;RTPagedCollectionViewLayout&#x27;, :path =&gt; &#x27;../&#x27;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">target &#x27;RTPagedCollectionViewLayout_Tests&#x27; do</span><br><span class="line">  pod &#x27;RTPagedCollectionViewLayout&#x27;, :path =&gt; &#x27;../&#x27;</span><br><span class="line">  </span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>再次执行<code>pod install</code>命令,结果如下<br><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/master/Snip20180416_22.png"><br>已经安装成功了,给了两个警告⚠️,你可以不用管它,有强迫症的同学可以在target前加上<code>platform :ios, &#39;7.1&#39;</code>,这个7.1是你的项目的Deployment Target…</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source &#x27;https://github.com/CocoaPods/Specs.git&#x27;</span><br><span class="line">use_frameworks!</span><br><span class="line"></span><br><span class="line">platform :ios, &#x27;7.1&#x27;</span><br><span class="line"></span><br><span class="line">target &#x27;RTPagedCollectionViewLayout_Example&#x27; do</span><br><span class="line">  pod &#x27;RTPagedCollectionViewLayout&#x27;, :path =&gt; &#x27;../&#x27;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">target &#x27;RTPagedCollectionViewLayout_Tests&#x27; do</span><br><span class="line">  pod &#x27;RTPagedCollectionViewLayout&#x27;, :path =&gt; &#x27;../&#x27;</span><br><span class="line">  </span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>再次运行<code>pod install</code>完美</p>
<p><img src="https://raw.githubusercontent.com/masterKing/markDownPictures/master/Snip20180416_23.png"></p>
]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
</search>
